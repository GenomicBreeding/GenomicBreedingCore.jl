<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GenomicBreedingCore.jl</title><meta name="title" content="Home · GenomicBreedingCore.jl"/><meta property="og:title" content="Home · GenomicBreedingCore.jl"/><meta property="twitter:title" content="Home · GenomicBreedingCore.jl"/><meta name="description" content="Documentation for GenomicBreedingCore.jl."/><meta property="og:description" content="Documentation for GenomicBreedingCore.jl."/><meta property="twitter:description" content="Documentation for GenomicBreedingCore.jl."/><meta property="og:url" content="https://GenomicBreeding.github.io/GenomicBreedingCore.jl/"/><meta property="twitter:url" content="https://GenomicBreeding.github.io/GenomicBreedingCore.jl/"/><link rel="canonical" href="https://GenomicBreeding.github.io/GenomicBreedingCore.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GenomicBreedingCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GenomicBreedingCore"><a class="docs-heading-anchor" href="#GenomicBreedingCore">GenomicBreedingCore</a><a id="GenomicBreedingCore-1"></a><a class="docs-heading-anchor-permalink" href="#GenomicBreedingCore" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl">GenomicBreedingCore</a>.</p><ul><li><a href="#GenomicBreedingCore.AbstractGB"><code>GenomicBreedingCore.AbstractGB</code></a></li><li><a href="#GenomicBreedingCore.BLR"><code>GenomicBreedingCore.BLR</code></a></li><li><a href="#GenomicBreedingCore.CV"><code>GenomicBreedingCore.CV</code></a></li><li><a href="#GenomicBreedingCore.DLModel"><code>GenomicBreedingCore.DLModel</code></a></li><li><a href="#GenomicBreedingCore.Fit"><code>GenomicBreedingCore.Fit</code></a></li><li><a href="#GenomicBreedingCore.GRM"><code>GenomicBreedingCore.GRM</code></a></li><li><a href="#GenomicBreedingCore.Genomes"><code>GenomicBreedingCore.Genomes</code></a></li><li><a href="#GenomicBreedingCore.Phenomes"><code>GenomicBreedingCore.Phenomes</code></a></li><li><a href="#GenomicBreedingCore.SimulatedEffects"><code>GenomicBreedingCore.SimulatedEffects</code></a></li><li><a href="#GenomicBreedingCore.TEBV"><code>GenomicBreedingCore.TEBV</code></a></li><li><a href="#GenomicBreedingCore.Trials"><code>GenomicBreedingCore.Trials</code></a></li><li><a href="#Base.:==-Tuple{GRM, GRM}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{SimulatedEffects, SimulatedEffects}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Trials, Trials}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Phenomes, Phenomes}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{CV, CV}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Fit, Fit}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{Genomes, Genomes}"><code>Base.:==</code></a></li><li><a href="#Base.:==-Tuple{TEBV, TEBV}"><code>Base.:==</code></a></li><li><a href="#Base.filter-Tuple{Genomes}"><code>Base.filter</code></a></li><li><a href="#Base.filter-Tuple{Phenomes}"><code>Base.filter</code></a></li><li><a href="#Base.filter-Tuple{Genomes, Float64}"><code>Base.filter</code></a></li><li><a href="#Base.hash-Tuple{CV, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{GRM, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{SimulatedEffects, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{Phenomes, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{TEBV, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{Genomes, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{Fit, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.hash-Tuple{Trials, UInt64}"><code>Base.hash</code></a></li><li><a href="#Base.merge-Tuple{Trials, Trials}"><code>Base.merge</code></a></li><li><a href="#Base.merge-Tuple{Genomes, Genomes}"><code>Base.merge</code></a></li><li><a href="#Base.merge-Tuple{Phenomes, Phenomes}"><code>Base.merge</code></a></li><li><a href="#Base.merge-Tuple{Genomes, Phenomes}"><code>Base.merge</code></a></li><li><a href="#Base.sum-Tuple{SimulatedEffects}"><code>Base.sum</code></a></li><li><a href="#GenomicBreedingCore.addcompositetrait-Tuple{Trials}"><code>GenomicBreedingCore.addcompositetrait</code></a></li><li><a href="#GenomicBreedingCore.addcompositetrait-Tuple{Phenomes}"><code>GenomicBreedingCore.addcompositetrait</code></a></li><li><a href="#GenomicBreedingCore.aggregateharvests-Tuple{Trials}"><code>GenomicBreedingCore.aggregateharvests</code></a></li><li><a href="#GenomicBreedingCore.analyse-Tuple{DataFrames.DataFrame}"><code>GenomicBreedingCore.analyse</code></a></li><li><a href="#GenomicBreedingCore.analyse"><code>GenomicBreedingCore.analyse</code></a></li><li><a href="#GenomicBreedingCore.checkdims-Tuple{Trials}"><code>GenomicBreedingCore.checkdims</code></a></li><li><a href="#GenomicBreedingCore.checkdims-Tuple{Fit}"><code>GenomicBreedingCore.checkdims</code></a></li><li><a href="#GenomicBreedingCore.checkdims-Tuple{Genomes}"><code>GenomicBreedingCore.checkdims</code></a></li><li><a href="#GenomicBreedingCore.checkdims-Tuple{TEBV}"><code>GenomicBreedingCore.checkdims</code></a></li><li><a href="#GenomicBreedingCore.checkdims-Tuple{Phenomes}"><code>GenomicBreedingCore.checkdims</code></a></li><li><a href="#GenomicBreedingCore.checkdims-Tuple{SimulatedEffects}"><code>GenomicBreedingCore.checkdims</code></a></li><li><a href="#GenomicBreedingCore.checkdims-Tuple{CV}"><code>GenomicBreedingCore.checkdims</code></a></li><li><a href="#GenomicBreedingCore.checkdims-Tuple{GRM}"><code>GenomicBreedingCore.checkdims</code></a></li><li><a href="#GenomicBreedingCore.clone-Tuple{CV}"><code>GenomicBreedingCore.clone</code></a></li><li><a href="#GenomicBreedingCore.clone-Tuple{GRM}"><code>GenomicBreedingCore.clone</code></a></li><li><a href="#GenomicBreedingCore.clone-Tuple{Fit}"><code>GenomicBreedingCore.clone</code></a></li><li><a href="#GenomicBreedingCore.clone-Tuple{Genomes}"><code>GenomicBreedingCore.clone</code></a></li><li><a href="#GenomicBreedingCore.clone-Tuple{Trials}"><code>GenomicBreedingCore.clone</code></a></li><li><a href="#GenomicBreedingCore.clone-Tuple{Phenomes}"><code>GenomicBreedingCore.clone</code></a></li><li><a href="#GenomicBreedingCore.clone-Tuple{TEBV}"><code>GenomicBreedingCore.clone</code></a></li><li><a href="#GenomicBreedingCore.countlevels-Tuple{DataFrames.DataFrame}"><code>GenomicBreedingCore.countlevels</code></a></li><li><a href="#GenomicBreedingCore.dimensions-Tuple{Genomes}"><code>GenomicBreedingCore.dimensions</code></a></li><li><a href="#GenomicBreedingCore.dimensions-Tuple{Phenomes}"><code>GenomicBreedingCore.dimensions</code></a></li><li><a href="#GenomicBreedingCore.dimensions-Tuple{TEBV}"><code>GenomicBreedingCore.dimensions</code></a></li><li><a href="#GenomicBreedingCore.dimensions-Tuple{Trials}"><code>GenomicBreedingCore.dimensions</code></a></li><li><a href="#GenomicBreedingCore.distances-Tuple{Phenomes}"><code>GenomicBreedingCore.distances</code></a></li><li><a href="#GenomicBreedingCore.distances-Tuple{Genomes}"><code>GenomicBreedingCore.distances</code></a></li><li><a href="#GenomicBreedingCore.divideintomockscaffolds-Tuple{Genomes}"><code>GenomicBreedingCore.divideintomockscaffolds</code></a></li><li><a href="#GenomicBreedingCore.estimatedistances-Tuple{Genomes}"><code>GenomicBreedingCore.estimatedistances</code></a></li><li><a href="#GenomicBreedingCore.estimateld-Tuple{Genomes}"><code>GenomicBreedingCore.estimateld</code></a></li><li><a href="#GenomicBreedingCore.extractphenomes-Tuple{TEBV}"><code>GenomicBreedingCore.extractphenomes</code></a></li><li><a href="#GenomicBreedingCore.extractphenomes-Tuple{Trials}"><code>GenomicBreedingCore.extractphenomes</code></a></li><li><a href="#GenomicBreedingCore.filterbymaf-Tuple{Genomes}"><code>GenomicBreedingCore.filterbymaf</code></a></li><li><a href="#GenomicBreedingCore.filterbymaxnalleles-Tuple{Genomes}"><code>GenomicBreedingCore.filterbymaxnalleles</code></a></li><li><a href="#GenomicBreedingCore.filterbypca-Tuple{Genomes}"><code>GenomicBreedingCore.filterbypca</code></a></li><li><a href="#GenomicBreedingCore.filterbysnplist-Tuple{Genomes}"><code>GenomicBreedingCore.filterbysnplist</code></a></li><li><a href="#GenomicBreedingCore.filterbysparsity-Tuple{Genomes}"><code>GenomicBreedingCore.filterbysparsity</code></a></li><li><a href="#GenomicBreedingCore.grmploidyaware-Tuple{Genomes}"><code>GenomicBreedingCore.grmploidyaware</code></a></li><li><a href="#GenomicBreedingCore.grmsimple-Tuple{Genomes}"><code>GenomicBreedingCore.grmsimple</code></a></li><li><a href="#GenomicBreedingCore.histallelefreqs-Tuple{Genomes}"><code>GenomicBreedingCore.histallelefreqs</code></a></li><li><a href="#GenomicBreedingCore.impute-Tuple{Genomes}"><code>GenomicBreedingCore.impute</code></a></li><li><a href="#GenomicBreedingCore.inflatediagonals!-Tuple{Matrix{Float64}}"><code>GenomicBreedingCore.inflatediagonals!</code></a></li><li><a href="#GenomicBreedingCore.knni-Tuple{}"><code>GenomicBreedingCore.knni</code></a></li><li><a href="#GenomicBreedingCore.knnioptim-Tuple{Genomes}"><code>GenomicBreedingCore.knnioptim</code></a></li><li><a href="#GenomicBreedingCore.loci-Tuple{Genomes}"><code>GenomicBreedingCore.loci</code></a></li><li><a href="#GenomicBreedingCore.loci_alleles-Tuple{Genomes}"><code>GenomicBreedingCore.loci_alleles</code></a></li><li><a href="#GenomicBreedingCore.maskmissing!-Tuple{Genomes}"><code>GenomicBreedingCore.maskmissing!</code></a></li><li><a href="#GenomicBreedingCore.plot-Tuple{Trials}"><code>GenomicBreedingCore.plot</code></a></li><li><a href="#GenomicBreedingCore.plot-Tuple{Phenomes}"><code>GenomicBreedingCore.plot</code></a></li><li><a href="#GenomicBreedingCore.plot"><code>GenomicBreedingCore.plot</code></a></li><li><a href="#GenomicBreedingCore.plot-Tuple{TEBV}"><code>GenomicBreedingCore.plot</code></a></li><li><a href="#GenomicBreedingCore.plot"><code>GenomicBreedingCore.plot</code></a></li><li><a href="#GenomicBreedingCore.removemissnaninf-Tuple{Trials}"><code>GenomicBreedingCore.removemissnaninf</code></a></li><li><a href="#GenomicBreedingCore.simulateallelefreqs!-Tuple{Matrix{Union{Missing, Float64}}, Vector{UInt64}, Union{Nothing, ProgressMeter.Progress}}"><code>GenomicBreedingCore.simulateallelefreqs!</code></a></li><li><a href="#GenomicBreedingCore.simulatechromstruct-Tuple{}"><code>GenomicBreedingCore.simulatechromstruct</code></a></li><li><a href="#GenomicBreedingCore.simulatecovarianceautocorrelated"><code>GenomicBreedingCore.simulatecovarianceautocorrelated</code></a></li><li><a href="#GenomicBreedingCore.simulatecovariancediagonal-Tuple{Int64, Vector{Float64}}"><code>GenomicBreedingCore.simulatecovariancediagonal</code></a></li><li><a href="#GenomicBreedingCore.simulatecovariancekinship-Tuple{Int64, Genomes}"><code>GenomicBreedingCore.simulatecovariancekinship</code></a></li><li><a href="#GenomicBreedingCore.simulatecovariancerandom"><code>GenomicBreedingCore.simulatecovariancerandom</code></a></li><li><a href="#GenomicBreedingCore.simulatecovariancespherical-Tuple{Int64, Float64}"><code>GenomicBreedingCore.simulatecovariancespherical</code></a></li><li><a href="#GenomicBreedingCore.simulateeffects-Tuple{}"><code>GenomicBreedingCore.simulateeffects</code></a></li><li><a href="#GenomicBreedingCore.simulategenomes-Tuple{}"><code>GenomicBreedingCore.simulategenomes</code></a></li><li><a href="#GenomicBreedingCore.simulategenomiceffects-Tuple{}"><code>GenomicBreedingCore.simulategenomiceffects</code></a></li><li><a href="#GenomicBreedingCore.simulateldblocks-Tuple{}"><code>GenomicBreedingCore.simulateldblocks</code></a></li><li><a href="#GenomicBreedingCore.simulatemating-Tuple{}"><code>GenomicBreedingCore.simulatemating</code></a></li><li><a href="#GenomicBreedingCore.simulateperpopμΣ-Tuple{}"><code>GenomicBreedingCore.simulateperpopμΣ</code></a></li><li><a href="#GenomicBreedingCore.simulatepopgroups-Tuple{}"><code>GenomicBreedingCore.simulatepopgroups</code></a></li><li><a href="#GenomicBreedingCore.simulateposandalleles-Tuple{}"><code>GenomicBreedingCore.simulateposandalleles</code></a></li><li><a href="#GenomicBreedingCore.simulatetrials-Tuple{}"><code>GenomicBreedingCore.simulatetrials</code></a></li><li><a href="#GenomicBreedingCore.slice-Tuple{Trials}"><code>GenomicBreedingCore.slice</code></a></li><li><a href="#GenomicBreedingCore.slice-Tuple{Genomes}"><code>GenomicBreedingCore.slice</code></a></li><li><a href="#GenomicBreedingCore.slice-Tuple{Phenomes}"><code>GenomicBreedingCore.slice</code></a></li><li><a href="#GenomicBreedingCore.sparsities-Tuple{Genomes}"><code>GenomicBreedingCore.sparsities</code></a></li><li><a href="#GenomicBreedingCore.summarise-Tuple{Vector{CV}}"><code>GenomicBreedingCore.summarise</code></a></li><li><a href="#GenomicBreedingCore.tabularise-Tuple{Vector{CV}}"><code>GenomicBreedingCore.tabularise</code></a></li><li><a href="#GenomicBreedingCore.tabularise"><code>GenomicBreedingCore.tabularise</code></a></li><li><a href="#GenomicBreedingCore.tabularise-Tuple{Trials}"><code>GenomicBreedingCore.tabularise</code></a></li><li><a href="#GenomicBreedingCore.tabularise-Tuple{Phenomes}"><code>GenomicBreedingCore.tabularise</code></a></li><li><a href="#GenomicBreedingCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}"><code>GenomicBreedingCore.trialsmodelsfomulae!</code></a></li><li><a href="#GenomicBreedingCore.@string2formula-Tuple{Any}"><code>GenomicBreedingCore.@string2formula</code></a></li><li><a href="#GenomicBreedingCore.@stringevaluation-Tuple{Any}"><code>GenomicBreedingCore.@stringevaluation</code></a></li></ul><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.AbstractGB"><a class="docstring-binding" href="#GenomicBreedingCore.AbstractGB"><code>GenomicBreedingCore.AbstractGB</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractGB</code></pre><p>The root abstract type for all core types in GenomicBreeding.jl package.</p><p>This type serves as the common ancestor for the type hierarchy in the package, enabling shared functionality and type-based dispatch across all derived types.</p><p><strong>Extended help</strong></p><p>All custom core types in GenomicBreeding.jl should subtype from <code>AbstractGB</code> to ensure consistency in the type system and to enable generic implementations of common operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.BLR"><a class="docstring-binding" href="#GenomicBreedingCore.BLR"><code>GenomicBreedingCore.BLR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BLR &lt;: AbstractGB</code></pre><p>Bayesian Linear Regression (BLR) model structure for phenotype analyses, genomic prediction and selection.</p><p><strong>Fields</strong></p><ul><li><code>entries::Vector{String}</code>: Names or identifiers for the observations</li><li><code>Xs::Dict{String,Matrix{Union{Bool,Float64}}}</code>: Design matrices for factors and numeric matrix for covariates, including intercept</li><li><code>Σs::Dict{String,Union{Nothing,Matrix{Float64},UniformScaling{Float64}}}</code>: Variance-covariance matrices for random effects</li><li><code>coefficients::Dict{String, Vector{Float64}}</code>: Dictionary of estimated coefficients/effects grouped by component</li><li><code>coefficient_names::Dict{String, Vector{String}}</code>: Dictionary of names for coefficients grouped by component</li><li><code>y::Vector{Float64}</code>: Response/dependent variable vector</li><li><code>ŷ::Vector{Float64}</code>: Fitted/predicted values</li><li><code>ϵ::Vector{Float64}</code>: Residuals (y - ŷ)</li><li><code>diagnostics::DataFrame</code>: Model diagnostics and convergence metrics</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">BLR(; n::Int64, p::Int64, var_comp::Dict{String, Int64} = Dict(&quot;σ²&quot; =&gt; 1))</code></pre><p>Creates a BLR model with specified dimensions and variance components.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: Number of observations</li><li><code>p::Int64</code>: Number of coefficients/effects (including intercept)</li><li><code>var_comp::Dict{String, Int64}</code>: Dictionary specifying variance components and their dimensions</li></ul><p><strong>Details</strong></p><p>The constructor initializes:</p><ul><li>Design matrices (Xs) with zeros, including an intercept component</li><li>Variance-covariance matrices (Σs) as identity matrices scaled by 1.0</li><li>Dictionaries for coefficients and their names, with &quot;intercept&quot; as default first component</li><li>Zero vectors for y, fitted values (ŷ), and residuals (ϵ)</li><li>Empty strings for entries and coefficient names (except &quot;intercept&quot;)</li><li>Empty DataFrame for model diagnostics</li></ul><p><strong>Requirements</strong></p><ul><li>At least one variance component (σ²) must be specified for residual variance</li><li>Total number of parameters (p) must equal sum of dimensions in variance components</li><li>Number of coefficients (p) must be ≥ 1</li><li>If p &gt; 1 and only residual variance is specified, a dummy variance component is added with p-1 dimensions</li></ul><p><strong>Notes</strong></p><p>The structure supports multiple random effects through the dictionary-based design,  where each component (except intercept) can have its own design matrix (X),  variance-covariance matrix (Σ), coefficients, and coefficient names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L193-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.CV"><a class="docstring-binding" href="#GenomicBreedingCore.CV"><code>GenomicBreedingCore.CV</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>Cross-validation struct</strong></p><p>Contains genomic prediction cross-validation details.</p><p><strong>Fields</strong></p><ul><li><code>replication</code>: replication name</li><li><code>fold</code>: fold name</li><li><code>fit</code>: genomic prediction model fit on the training set</li><li><code>validation_populations</code>: vector of validation populations corresponding to each validation entry</li><li><code>validation_entries</code>: corresponding vector of entries in the validation population/s</li><li><code>validation_y_true</code>: corresponding vector of observed phenotypes in the validation population/s</li><li><code>validation_y_pred</code>: corresponding vector of predicted phenotypes in the validation population/s</li><li><code>metrics</code>: dictionary of genomic prediction accuracy metrics on the validation population/s</li></ul><p><strong>Constructor</strong></p><p>Uses the default constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L518-L535">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.DLModel"><a class="docstring-binding" href="#GenomicBreedingCore.DLModel"><code>GenomicBreedingCore.DLModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DLModel &lt;: AbstractGB</code></pre><p>A mutable struct representing a deep learning model for genomic breeding analysis.</p><p><strong>Fields</strong></p><ul><li><code>model::Any</code>: The neural network model (typically a Flux.jl Chain).</li><li><code>dev::Any</code>: Device information (e.g., CPU or GPU).</li><li><code>μ_y::Float64</code>: Mean of the target variable.</li><li><code>σ_y::Float64</code>: Standard deviation of the target variable.</li><li><code>row_names::Vector{String}</code>: Names of the rows in the dataset.</li><li><code>feature_groups::Vector{String}</code>: Groups to which features belong.</li><li><code>feature_names::Vector{String}</code>: Names of the features used in the model.</li><li><code>training_state::Any</code>: State information related to training (e.g., optimizer state).</li><li><code>training_progress::DataFrame</code>: DataFrame tracking training progress metrics.</li><li><code>training_observed::Vector{Float64}</code>: Observed values in the training set.</li><li><code>training_predicted::Vector{Float64}</code>: Predicted values for the training set.</li><li><code>training_labels::Vector{String}</code>: Labels for the training set samples.</li><li><code>validation_observed::Vector{Float64}</code>: Observed values in the validation set.</li><li><code>validation_predicted::Vector{Float64}</code>: Predicted values for the validation set.</li><li><code>validation_labels::Vector{String}</code>: Labels for the validation set samples.</li><li><code>stats_training::Dict</code>: Dictionary containing training statistics.</li><li><code>stats_validation::Dict</code>: Dictionary containing validation statistics.</li></ul><p><strong>Usage</strong></p><p>Create and manage deep learning models for genomic breeding tasks, including tracking training and validation metrics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L417-L443">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.Fit"><a class="docstring-binding" href="#GenomicBreedingCore.Fit"><code>GenomicBreedingCore.Fit</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>Genomic prediction model fit</strong></p><p>Contains genomic prediction model fit details.</p><p><strong>Fields</strong></p><ul><li><code>model</code>: name of the genomic prediction model used</li><li><code>b_hat_labels</code>: names of the loci-alleles used</li><li><code>b_hat</code>: effects of the loci-alleles</li><li><code>trait</code>: name of the trait</li><li><code>entries</code>: names of the entries used in the current cross-validation replication and fold</li><li><code>populations</code>: names of the populations used in the current cross-validation replication and fold</li><li><code>y_true</code>: corresponding observed phenotype values</li><li><code>y_pred</code>: corresponding predicted phenotype values</li><li><code>metrics</code>: dictionary of genomic prediction accuracy metrics, including Pearson&#39;s correlation, mean absolute error and root mean-squared error</li><li><code>lux_model</code>: Pending(Nothing or a trained Lux neural network model)</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Fit(; n=1, l=10)
where:
- n::Int64: Number of entries
- l::Int64: Number of loci-alleles</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L464-L488">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.GRM"><a class="docstring-binding" href="#GenomicBreedingCore.GRM"><code>GenomicBreedingCore.GRM</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>Genomic relationship matrix struct</strong></p><p>Contains genomic relationship matrix as well as the corresponding entries and loci-alleles used to compute it.</p><p><strong>Fields</strong></p><ul><li><code>entries</code>: names of the <code>n</code> entries corresponding to the rows and columns of the genomic relationship matrix</li><li><code>loci_alleles</code>: names of the loci-alleles used to compute the genomic relationship matrix</li><li><code>genomic_relationship_matrix</code>: <code>n x n</code> matrix of genomic relationship values between entries</li></ul><p><strong>Constructor</strong></p><p>Uses the default constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L547-L559">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.Genomes"><a class="docstring-binding" href="#GenomicBreedingCore.Genomes"><code>GenomicBreedingCore.Genomes</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>Genomes struct</strong></p><p>Containes unique entries and loci_alleles where allele frequencies can have missing values</p><p><strong>Fields</strong></p><ul><li><code>entries</code>: names of the <code>n</code> entries or samples</li><li><code>populations</code>: name/s of the population/s each entries or samples belong to</li><li><code>loci_alleles</code>: names of the <code>p</code> loci-alleles combinations (<code>p</code> = <code>l</code> loci x <code>a-1</code> alleles) including the chromsome or scaffold name, position, all alleles and current allele separated by tabs (&quot;\t&quot;)</li><li><code>allele_frequencies</code>: <code>n x p</code> matrix of allele frequencies between 0 and 1 which can have missing values</li><li><code>mask</code>: <code>n x p</code> matrix of boolean mask for selective analyses and slicing</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Genomes(; n::Int64 = 1, p::Int64 = 2)</code></pre><p>where:</p><ul><li><code>n::Int64=1</code>: Number of entries in the genomic dataset</li><li><code>p::Int64=2</code>: Number of locus-allele combinations in the genomic dataset</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = Genomes(n=2, p=2)
Genomes([&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])

julia&gt; fieldnames(Genomes)
(:entries, :populations, :loci_alleles, :allele_frequencies, :mask)

julia&gt; genomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;];

julia&gt; genomes.populations = [&quot;pop_1&quot;, &quot;pop_1&quot;];

julia&gt; genomes.loci_alleles = [&quot;chr1\t12345\tA|T\tA&quot;, &quot;chr2\t678910\tC|D\tD&quot;];

julia&gt; genomes.allele_frequencies = [0.5 0.25; 0.9 missing];

julia&gt; genomes.mask = [true true; true false];

julia&gt; genomes
Genomes([&quot;entry_1&quot;, &quot;entry_2&quot;], [&quot;pop_1&quot;, &quot;pop_1&quot;], [&quot;chr1\t12345\tA|T\tA&quot;, &quot;chr2\t678910\tC|D\tD&quot;], Union{Missing, Float64}[0.5 0.25; 0.9 missing], Bool[1 1; 1 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L17-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.Phenomes"><a class="docstring-binding" href="#GenomicBreedingCore.Phenomes"><code>GenomicBreedingCore.Phenomes</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>Phenomes struct</strong></p><p>Constains unique entries and traits where phenotype data can have missing values</p><p><strong>Fields</strong></p><ul><li><code>entries</code>: names of the <code>n</code> entries or samples</li><li><code>populations</code>: name/s of the population/s each entries or samples belong to</li><li><code>traits</code>: names of the <code>t</code> traits</li><li><code>phenotypes</code>: <code>n x t</code> matrix of numeric (<code>R</code>) phenotype data which can have missing values</li><li><code>mask</code>: <code>n x t</code> matrix of boolean mask for selective analyses and slicing</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Phenomes(; n::Int64 = 1, t::Int64 = 2)</code></pre><p>where:</p><ul><li><code>n::Int64=1</code>: Number of entries in the phenomic dataset</li><li><code>t::Int64=2</code>: Number of traits in the phenomic dataset</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=2, t=2)
Phenomes([&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])

julia&gt; fieldnames(Phenomes)
(:entries, :populations, :traits, :phenotypes, :mask)

julia&gt; phenomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;];

julia&gt; phenomes.populations = [&quot;pop_A&quot;, &quot;pop_B&quot;];

julia&gt; phenomes.traits = [&quot;height&quot;, &quot;yield&quot;];

julia&gt; phenomes.phenotypes = [200.0 2.5; 150.0 missing];

julia&gt; phenomes.mask = [true true; true false];

julia&gt; phenomes
Phenomes([&quot;entry_1&quot;, &quot;entry_2&quot;], [&quot;pop_A&quot;, &quot;pop_B&quot;], [&quot;height&quot;, &quot;yield&quot;], Union{Missing, Float64}[200.0 2.5; 150.0 missing], Bool[1 1; 1 0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L71-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.SimulatedEffects"><a class="docstring-binding" href="#GenomicBreedingCore.SimulatedEffects"><code>GenomicBreedingCore.SimulatedEffects</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>SimulatedEffects struct</strong></p><p>Contains the various simulated genetic, environmental and GxE effects.</p><p><strong>Fields</strong></p><ul><li><code>id::Vector{String}</code>: Vector of identifiers</li><li><code>year::Float64</code>: Year effect</li><li><code>season::Float64</code>: Season effect</li><li><code>site::Float64</code>: Site effect</li><li><code>seasons_x_year::Float64</code>: Interaction effect between seasons and years</li><li><code>harvests_x_season_x_year::Float64</code>: Interaction effect between harvests, seasons and years</li><li><code>sites_x_harvest_x_season_x_year::Float64</code>: Interaction effect between sites, harvests, seasons and years</li><li><code>field_layout::Matrix{Int64}</code>: 2D matrix representing field layout</li><li><code>replications_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Replication interaction effects</li><li><code>blocks_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Block interaction effects</li><li><code>rows_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Row interaction effects</li><li><code>cols_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Column interaction effects</li><li><code>additive_genetic::Vector{Float64}</code>: Additive genetic effects</li><li><code>dominance_genetic::Vector{Float64}</code>: Dominance genetic effects</li><li><code>epistasis_genetic::Vector{Float64}</code>: Epistasis genetic effects</li><li><code>additive_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Additive allele interaction effects</li><li><code>dominance_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Dominance allele interaction effects</li><li><code>epistasis_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}</code>: Epistasis allele interaction effects</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SimulatedEffects()</code></pre><p>Creates a new SimulatedEffects instance with default values:</p><ul><li>Empty strings for IDs (vector of size 6)</li><li>0.0 for all float values</li><li>4x4 zero matrix for field_layout</li><li>Single-element zero vectors for all vector fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L340-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.TEBV"><a class="docstring-binding" href="#GenomicBreedingCore.TEBV"><code>GenomicBreedingCore.TEBV</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>Trial-estimated breeding values (TEBV) struct</strong></p><p>Contains trial-estimated breeding values as generated by <code>analyse(trials::Trials, ...)</code>.</p><p><strong>Fields</strong></p><ul><li><code>traits</code>: names of the traits <code>t</code> traits</li><li><code>formulae</code>: best-fitting formula for each trait</li><li><code>models</code>: best-fitting linear mixed model for each trait which may be MixedModes.jl model or a tuple of coefficient names, the coefficients and the design matrix from Bayesian linear regression</li><li><code>df_BLUEs</code>: vector of data frames of best linear unbiased estimators or fixed effects table of each best fitting model</li><li><code>df_BLUPs</code>: vector of data frames of best linear unbiased predictors or random effects table of each best fitting model</li><li><code>phenomes</code>: vector of Phenomes structs each containing the breeding values</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1, t=1)]);

julia&gt; tebv.traits
1-element Vector{String}:
 &quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L298-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.Trials"><a class="docstring-binding" href="#GenomicBreedingCore.Trials"><code>GenomicBreedingCore.Trials</code></a> — <span class="docstring-category">Type</span></summary><section><div><p><strong>Trials struct</strong></p><p>Contains phenotype data across years, seasons, harvest, sites, populations, replications, blocks, rows, and columns</p><p><strong>Fields</strong></p><ul><li><code>phenotypes</code>: <code>n x t</code> matrix of numeric phenotype data which can have missing values</li><li><code>traits</code>: names of the traits <code>t</code> traits</li><li><code>years</code>: names of the years corresponding to each row in the phenotype matrix</li><li><code>seasons</code>: names of the seasons corresponding to each row in the phenotype matrix</li><li><code>harvests</code>: names of the harvests corresponding to each row in the phenotype matrix</li><li><code>sites</code>: names of the sites corresponding to each row in the phenotype matrix</li><li><code>replications</code>: names of the replications corresponding to each row in the phenotype matrix</li><li><code>blocks</code>: names of the blocks corresponding to each row in the phenotype matrix</li><li><code>rows</code>: names of the rows corresponding to each row in the phenotype matrix</li><li><code>cols</code>: names of the cols corresponding to each row in the phenotype matrix</li><li><code>entries</code>: names of the entries corresponding to each row in the phenotype matrix</li><li><code>populations</code>: names of the populations corresponding to each row in the phenotype matrix</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Trials(; n::Int64 = 2, p::Int64 = 2)</code></pre><p>where:</p><ul><li><code>n::Int64=1</code>: Number of entries in the trials</li><li><code>t::Int64=2</code>: Number of traits in the trials</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=1, t=2)
Trials(Union{Missing, Float64}[missing missing], [&quot;&quot;, &quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;], [&quot;&quot;])

julia&gt; fieldnames(Trials)
(:phenotypes, :traits, :years, :seasons, :harvests, :sites, :replications, :blocks, :rows, :cols, :entries, :populations)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/all_structs.jl#L125-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{CV, CV}"><a class="docstring-binding" href="#Base.:==-Tuple{CV, CV}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(x::CV, y::CV)::Bool</code></pre><p>Compare two CV (Cross-Validation) structs for equality.</p><p>This method overloads the equality operator (<code>==</code>) for CV structs by comparing their hash values. Two CV structs are considered equal if they have identical values for all fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::CV</code>: First CV struct to compare</li><li><code>y::CV</code>: Second CV struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the CV structs are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; cv_1 = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit.metrics);

julia&gt; cv_2 = clone(cv_1);

julia&gt; cv_3 = clone(cv_1); cv_3.replication = &quot;other_replication&quot;;

julia&gt; cv_1 == cv_2
true

julia&gt; cv_1 == cv_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/cv/cv.jl#L88-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{Fit, Fit}"><a class="docstring-binding" href="#Base.:==-Tuple{Fit, Fit}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(x::Fit, y::Fit)::Bool</code></pre><p>Compare two <code>Fit</code> structs for equality based on their hash values.</p><p>This method defines equality comparison for <code>Fit</code> structs by comparing their hash values. Two <code>Fit</code> structs are considered equal if they have identical hash values, which means they have the same values for all their fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::Fit</code>: First Fit struct to compare</li><li><code>y::Fit</code>: Second Fit struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the Fit structs are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit_1 = Fit(n=1, l=4);

julia&gt; fit_2 = Fit(n=1, l=4);

julia&gt; fit_3 = Fit(n=1, l=2);

julia&gt; fit_1 == fit_2
true

julia&gt; fit_1 == fit_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/fit/fit.jl#L85-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{GRM, GRM}"><a class="docstring-binding" href="#Base.:==-Tuple{GRM, GRM}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(x::GRM, y::GRM)::Bool</code></pre><p>Compare two GRM structs for equality.</p><p>Overloads the equality operator (<code>==</code>) for GRM structs by comparing their hash values. Two GRM structs are considered equal if they have identical values for all their fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::GRM</code>: First GRM struct to compare</li><li><code>y::GRM</code>: Second GRM struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the GRM structs are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; grm_1 = GRM(string.([&quot;entries_1&quot;, &quot;entries_2&quot;]), string.([&quot;chr1	123	A|T	A&quot;, &quot;chr1	456	C|G	G&quot;]), Float64.(rand(2,2)));

julia&gt; grm_2 = clone(grm_1);

julia&gt; grm_3 = GRM(string.([&quot;entries_1&quot;, &quot;entries_2&quot;]), string.([&quot;chr1	123	A|T	A&quot;, &quot;chr1	456	C|G	G&quot;]), Float64.(rand(2,2)));

julia&gt; grm_1 == grm_2
true

julia&gt; grm_1 == grm_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/grm/grm.jl#L64-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{Genomes, Genomes}"><a class="docstring-binding" href="#Base.:==-Tuple{Genomes, Genomes}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">==(x::Genomes, y::Genomes)::Bool</code></pre><p>Compare two <code>Genomes</code> structs for equality by comparing their hash values.</p><p>This method implements equality comparison for <code>Genomes</code> structs by utilizing their hash values, ensuring that two genomes are considered equal if and only if they have identical structural properties and content.</p><p><strong>Arguments</strong></p><ul><li><code>x::Genomes</code>: First Genomes struct to compare</li><li><code>y::Genomes</code>: Second Genomes struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the genomes are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes_1 = genomes = Genomes(n=2,p=4);

julia&gt; genomes_2 = genomes = Genomes(n=2,p=4);

julia&gt; genomes_3 = genomes = Genomes(n=1,p=2);

julia&gt; genomes_1 == genomes_2
true

julia&gt; genomes_1 == genomes_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L79-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{Phenomes, Phenomes}"><a class="docstring-binding" href="#Base.:==-Tuple{Phenomes, Phenomes}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">==(x::Phenomes, y::Phenomes)::Bool</code></pre><p>Compare two <code>Phenomes</code> structs for equality using their hash values.</p><p>This method implements equality comparison for <code>Phenomes</code> objects by comparing their hash values, ensuring that two phenomes with identical structure and content are considered equal.</p><p><strong>Arguments</strong></p><ul><li><code>x::Phenomes</code>: First phenomes object to compare</li><li><code>y::Phenomes</code>: Second phenomes object to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the phenomes are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes_1 = phenomes = Phenomes(n=2, t=4);

julia&gt; phenomes_2 = phenomes = Phenomes(n=2, t=4);

julia&gt; phenomes_3 = phenomes = Phenomes(n=1, t=2);

julia&gt; phenomes_1 == phenomes_2
true

julia&gt; phenomes_1 == phenomes_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/phenomes.jl#L72-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{SimulatedEffects, SimulatedEffects}"><a class="docstring-binding" href="#Base.:==-Tuple{SimulatedEffects, SimulatedEffects}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(x::SimulatedEffects, y::SimulatedEffects)::Bool</code></pre><p>Defines equality comparison for SimulatedEffects structs by comparing their hash values.</p><p>This method overloads the == operator for SimulatedEffects type and determines if two SimulatedEffects instances are equal by comparing their hash values rather than doing a field-by-field comparison.</p><p><strong>Arguments</strong></p><ul><li><code>x::SimulatedEffects</code>: First SimulatedEffects instance to compare</li><li><code>y::SimulatedEffects</code>: Second SimulatedEffects instance to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: true if the hash values of both instances are equal, false otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; effects_1 = SimulatedEffects();

julia&gt; effects_2 = SimulatedEffects();

julia&gt; effects_3 = SimulatedEffects(); effects_3.id[1] = &quot;SOMETHING_ELSE&quot;;

julia&gt; effects_1 == effects_2
true

julia&gt; effects_1 == effects_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L33-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{TEBV, TEBV}"><a class="docstring-binding" href="#Base.:==-Tuple{TEBV, TEBV}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">==(x::TEBV, y::TEBV)::Bool</code></pre><p>Compare two TEBV (Trial-Estimated Breeding Values) objects for equality.</p><p>This method implements equality comparison for TEBV structs by comparing their hash values. Two TEBV objects are considered equal if they have identical values for all their fields: traits, formulae, models, df<em>BLUEs, df</em>BLUPs, and phenomes.</p><p><strong>Arguments</strong></p><ul><li><code>x::TEBV</code>: First TEBV object to compare</li><li><code>y::TEBV</code>: Second TEBV object to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the TEBV objects are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv_1 = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; tebv_2 = clone(tebv_1);

julia&gt; tebv_3 = TEBV(traits=[&quot;SOMETHING_ELSE&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; tebv_1 == tebv_2
true

julia&gt; tebv_1 == tebv_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/tebv.jl#L83-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Tuple{Trials, Trials}"><a class="docstring-binding" href="#Base.:==-Tuple{Trials, Trials}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">==(x::Trials, y::Trials)::Bool</code></pre><p>Compare two <code>Trials</code> structs for equality by comparing their hash values.</p><p>Two <code>Trials</code> structs are considered equal if they have identical hash values, which implies they have the same configuration parameters (number of trials <code>n</code> and time steps <code>t</code>).</p><p><strong>Arguments</strong></p><ul><li><code>x::Trials</code>: First Trials struct to compare</li><li><code>y::Trials</code>: Second Trials struct to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the Trials structs are equal, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials_1 = trials = Trials(n=2, t=4);

julia&gt; trials_2 = trials = Trials(n=2, t=4);

julia&gt; trials_3 = trials = Trials(n=1, t=2);

julia&gt; trials_1 == trials_2
true

julia&gt; trials_1 == trials_3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L65-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.filter-Tuple{Genomes, Float64}"><a class="docstring-binding" href="#Base.filter-Tuple{Genomes, Float64}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filter(
    genomes::Genomes,
    maf::Float64;
    max_entry_sparsity::Float64 = 0.0,
    max_locus_sparsity::Float64 = 0.0,
    max_prop_pc_varexp::Float64 = 0.90,
    max_entry_sparsity_percentile::Float64 = 0.90,
    max_locus_sparsity_percentile::Float64 = 0.50,
    chr_pos_allele_ids::Union{Nothing,Vector{String}} = nothing,
    match_alleles::Bool = true,
    verbose::Bool = false,
)::Tuple{Genomes, Dict{String,Vector{String}}}</code></pre><p>Filter genomic data based on multiple criteria including sparsity, minor allele frequency (MAF), principal component analysis (PCA), and a list of loci-allele combinations.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A <code>Genomes</code> struct containing the genomic data.</li><li><code>maf::Float64</code>: The minimum allele frequency threshold.</li><li><code>max_entry_sparsity::Float64</code>: The maximum allowable sparsity for entries. Default is 0.0.</li><li><code>max_locus_sparsity::Float64</code>: The maximum allowable sparsity for loci. Default is 0.0.</li><li><code>max_prop_pc_varexp::Float64</code>: The maximum proportion of variance explained by the first two principal components (PC1 and PC2). Default is 0.90.</li><li><code>max_entry_sparsity_percentile::Float64</code>: The percentile threshold for entry sparsity. Default is 0.90.</li><li><code>max_locus_sparsity_percentile::Float64</code>: The percentile threshold for locus sparsity. Default is 0.50.</li><li><code>chr_pos_allele_ids::Union{Nothing, Vector{String}}</code>: A vector of loci-allele combination names in the format &quot;chromosome\tposition\tallele&quot;. If <code>nothing</code>, no filtering is applied. Default is <code>nothing</code>.</li><li><code>match_alleles::Bool</code>: If <code>true</code>, matches alleles exactly when filtering by SNP list. If <code>false</code>, matches only chromosome and position. Default is <code>true</code>.</li><li><code>verbose::Bool</code>: If <code>true</code>, prints detailed progress information during the filtering process. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Genomes, Dict{String, Vector{String}}}</code>: A tuple containing:<ul><li>A <code>Genomes</code> struct with filtered genomic data.</li><li>A dictionary of omitted loci-allele names categorized by the filtering criteria.</li></ul></li></ul><p><strong>Details</strong></p><p>This function filters genomic data based on multiple criteria including sparsity, minor allele frequency (MAF), principal component analysis (PCA), and a list of loci-allele combinations. The function performs the following steps:</p><ol><li><strong>Input Validation</strong>: Ensures that the <code>Genomes</code> struct is not corrupted and that the filtering thresholds are within valid ranges.</li><li><strong>Filter by Sparsity</strong>: Removes the sparsest entries and loci-alleles until the maximum allowable sparsity thresholds are met.</li><li><strong>Filter by MAF</strong>: Removes loci-alleles with minor allele frequencies below the specified threshold.</li><li><strong>Filter by PCA</strong>: Removes outlier loci-alleles based on the proportion of variance explained by the first two principal components.</li><li><strong>Filter by SNP List</strong>: Retains only the specified loci-allele combinations, with optional exact allele matching.</li><li><strong>Verbose Output</strong>: If <code>verbose</code> is <code>true</code>, prints detailed progress information during each filtering step.</li></ol><p><strong>Notes</strong></p><ul><li>The function uses multi-threading to improve performance on large datasets.</li><li>The <code>match_alleles</code> parameter provides flexibility in SNP list filtering.</li><li>The function ensures that the filtered genomic data retains a minimum number of entries and loci-alleles.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the <code>Genomes</code> struct is corrupted or any of the filtering thresholds are out of range.</li><li><code>ErrorException</code>: If no loci-alleles are retained after filtering.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, sparsity=0.01, verbose=false);

julia&gt; filtered_genomes_1, omitted_loci_alleles_1 = filter(genomes, 0.1);

julia&gt; filtered_genomes_2, omitted_loci_alleles_2 = filter(genomes, 0.1, chr_pos_allele_ids=genomes.loci_alleles[1:1000]);

julia&gt; size(genomes.allele_frequencies)
(100, 3000)

julia&gt; prod(size(filtered_genomes_1.allele_frequencies)) &lt; prod(size(genomes.allele_frequencies))
true

julia&gt; prod(size(filtered_genomes_2.allele_frequencies)) &lt; prod(size(filtered_genomes_1.allele_frequencies))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L989-L1058">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.filter-Tuple{Genomes}"><a class="docstring-binding" href="#Base.filter-Tuple{Genomes}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filter(genomes::Genomes; verbose::Bool = false)::Genomes</code></pre><p>Filter a Genomes struct by removing entries and loci with missing data based on the mask matrix.</p><p><strong>Description</strong></p><p>This function filters a Genomes struct by:</p><ol><li>Removing rows (entries) where any column has a false value in the mask matrix</li><li>Removing columns (loci) where any row has a false value in the mask matrix</li></ol><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Input Genomes struct containing genetic data and a mask matrix</li><li><code>verbose::Bool</code>: Optional flag to control verbose output (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new filtered Genomes struct with complete data (no missing values)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(verbose=false); genomes.mask[1:10, 42:100] .= false;
    
julia&gt; filtered_genomes = filter(genomes);

julia&gt; size(filtered_genomes.allele_frequencies)
(90, 9941)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L127-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.filter-Tuple{Phenomes}"><a class="docstring-binding" href="#Base.filter-Tuple{Phenomes}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filter(phenomes::Phenomes)::Phenomes</code></pre><p>Filter a Phenomes struct by removing rows (entries) and columns (traits) as indicated by the mask matrix.  An entry or trait is removed if it contains at least one false value in the mask.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: The Phenomes struct to be filtered, containing entries, populations, traits, phenotypes, and a boolean mask matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new Phenomes struct with filtered entries and traits, where the mask matrix is all true.</li></ul><p><strong>Details</strong></p><p>The function uses the mean of rows and columns in the mask matrix to identify which entries and traits should be kept. Only entries and traits with a mean of 1.0 (all true values) are retained in the filtered result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = fill(0.0, 10,3);

julia&gt; phenomes.mask .= true; phenomes.mask[6:10, 1] .= false;
    
julia&gt; filtered_phenomes = filter(phenomes);

julia&gt; size(filtered_phenomes.phenotypes)
(5, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/filter.jl#L93-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{CV, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{CV, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(x::CV, h::UInt)::UInt</code></pre><p>Compute a hash value for a CV (Cross-Validation) struct.</p><p>This method defines how CV structs should be hashed, which is useful for using CV objects in hash-based collections like Sets or as Dict keys.</p><p><strong>Arguments</strong></p><ul><li><code>x::CV</code>: The CV struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with the new hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value for the CV struct</li></ul><p><strong>Implementation Details</strong></p><p>The hash is computed by combining the following fields:</p><ul><li>replication</li><li>fold</li><li>fit</li><li>validation_populations</li><li>validation_entries</li><li>validation<em>y</em>true</li><li>validation<em>y</em>pred</li><li>metrics</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; cv = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit.metrics);

julia&gt; typeof(hash(cv))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/cv/cv.jl#L43-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{Fit, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{Fit, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(x::Fit, h::UInt)::UInt</code></pre><p>Calculate a hash value for a <code>Fit</code> struct.</p><p>This method implements hashing for the <code>Fit</code> type by combining the hashes of its core components in a specific order. The hash is computed using the following fields:</p><ul><li>model</li><li>b_hat (estimated effects)</li><li>trait</li><li>entries</li><li>populations</li><li>metrics</li><li>y_true (observed values)</li><li>y_pred (predicted values)</li></ul><p><strong>Arguments</strong></p><ul><li><code>x::Fit</code>: The Fit struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: The computed hash value</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; typeof(hash(fit))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/fit/fit.jl#L45-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{GRM, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{GRM, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(x::GRM, h::UInt)::UInt</code></pre><p>Compute a hash value for a GRM (Genomic Relationship Matrix) struct.</p><p>This method defines how GRM structs should be hashed, making them usable in  hash-based collections like Sets or as Dict keys. The hash is computed by  iteratively combining the hash values of all fields in the struct.</p><p><strong>Arguments</strong></p><ul><li><code>x::GRM</code>: The GRM struct to be hashed</li><li><code>h::UInt</code>: The initial hash value to be combined with the struct&#39;s hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A combined hash value for the entire GRM struct</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; grm = GRM(string.([&quot;entries_1&quot;, &quot;entries_2&quot;]), string.([&quot;chr1	123	A|T	A&quot;, &quot;chr1	456	C|G	G&quot;]), Float64.(rand(2,2)));

julia&gt; typeof(hash(grm))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/grm/grm.jl#L31-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{Genomes, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{Genomes, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(x::Genomes, h::UInt)::UInt</code></pre><p>Compute a hash value for a <code>Genomes</code> struct.</p><p>This hash function considers three key components of the <code>Genomes</code> struct:</p><ul><li>entries</li><li>populations</li><li>loci_alleles</li></ul><p>For performance reasons, <code>allele_frequencies</code> and <code>mask</code> fields are deliberately excluded  from the hash computation.</p><p><strong>Arguments</strong></p><ul><li><code>x::Genomes</code>: The Genomes struct to hash</li><li><code>h::UInt</code>: The hash seed value</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value for the Genomes struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = Genomes(n=2, p=2);

julia&gt; typeof(hash(genomes))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L39-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{Phenomes, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{Phenomes, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(x::Phenomes, h::UInt)::UInt</code></pre><p>Compute a hash value for a <code>Phenomes</code> struct by recursively hashing its internal fields.</p><p><strong>Arguments</strong></p><ul><li><code>x::Phenomes</code>: The Phenomes struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value for the entire Phenomes struct</li></ul><p><strong>Note</strong></p><p>This function is used for dictionary operations and computing hash-based data structures. The hash is computed by combining hashes of all internal fields: entries, populations, traits, phenotypes, and mask.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=2, t=2);

julia&gt; typeof(hash(phenomes))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/phenomes.jl#L38-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{SimulatedEffects, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{SimulatedEffects, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hash(x::SimulatedEffects, h::UInt)::UInt</code></pre><p>Compute a hash value for a <code>SimulatedEffects</code> object.</p><p>This method implements custom hashing for <code>SimulatedEffects</code> by iterating through all fields of the object and combining their hash values with the provided seed hash <code>h</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::SimulatedEffects</code>: The object to be hashed</li><li><code>h::UInt</code>: The hash seed value</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: The computed hash value</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; effects = SimulatedEffects();

julia&gt; typeof(hash(effects))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{TEBV, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{TEBV, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(x::TEBV, h::UInt)::UInt</code></pre><p>Calculate a hash value for a TEBV (Trial-Estimated Breeding Value) struct.</p><p>This method implements hashing for TEBV objects by combining the hash values of selected fields:</p><ul><li>traits: Vector of trait names</li><li>formulae: Vector of formula strings</li><li>phenomes: Vector of Phenomes objects</li></ul><p>Note: For performance reasons, the following fields are deliberately excluded from the hash calculation:</p><ul><li>models</li><li>df_BLUEs</li><li>df_BLUPs</li></ul><p><strong>Arguments</strong></p><ul><li><code>x::TEBV</code>: The TEBV struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with the object&#39;s hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A unique hash value for the TEBV object</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; typeof(hash(tebv))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/tebv.jl#L41-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{Trials, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{Trials, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(x::Trials, h::UInt)::UInt</code></pre><p>Compute a hash value for a <code>Trials</code> struct by recursively hashing all of its fields.</p><p>This method implements hash functionality for the <code>Trials</code> type, allowing <code>Trials</code>  objects to be used as dictionary keys or in hash-based collections.</p><p><strong>Arguments</strong></p><ul><li><code>x::Trials</code>: The Trials struct to be hashed</li><li><code>h::UInt</code>: The hash value to be mixed with the object&#39;s hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt</code>: A hash value for the entire Trials struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=2, t=2);

julia&gt; typeof(hash(trials))
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L33-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.merge-Tuple{Genomes, Genomes}"><a class="docstring-binding" href="#Base.merge-Tuple{Genomes, Genomes}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge(
    genomes::Genomes,
    other::Genomes;
    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),
    verbose::Bool = true
)::Genomes</code></pre><p>Merge two Genomes structs by combining their entries and loci_alleles while resolving conflicts in allele frequencies.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: First Genomes struct to merge</li><li><code>other::Genomes</code>: Second Genomes struct to merge</li><li><code>conflict_resolution::Tuple{Float64,Float64}</code>: Weights for resolving conflicts between allele frequencies (must sum to 1.0)</li><li><code>verbose::Bool</code>: If true, displays a progress bar during merging</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new Genomes struct containing the merged data</li></ul><p><strong>Details</strong></p><p>The function performs the following operations:</p><ol><li>If the loci_alleles are identical and there are no overlapping entries, performs a quick merge:<ul><li>Concatenates entries, populations, allele frequencies, and mask without conflict resolution.</li></ul></li><li>Combines unique entries and loci_alleles from both input structs</li><li>Resolves population conflicts by concatenating conflicting values</li><li>For overlapping entries and loci:<ul><li>If allele frequencies match, uses the existing value</li><li>If frequencies differ, applies weighted average using conflict_resolution</li><li>For missing values, uses available non-missing value</li><li>Resolves mask conflicts using weighted average</li></ul></li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n = 100; l = 5_000; n_alleles = 2;

julia&gt; all = simulategenomes(n=n, l=l, n_alleles=n_alleles, verbose=false);

julia&gt; genomes = slice(all, idx_entries=collect(1:Int(floor(n*0.75))), idx_loci_alleles=collect(1:Int(floor(l*(n_alleles-1)*0.75))));

julia&gt; other = slice(all, idx_entries=collect(Int(floor(n*0.50)):n), idx_loci_alleles=collect(Int(floor(l*(n_alleles-1)*0.50)):l*(n_alleles-1)));

julia&gt; merged_genomes = merge(genomes, other, conflict_resolution=(0.75, 0.25), verbose=false);

julia&gt; size(merged_genomes.allele_frequencies)
(100, 5000)

julia&gt; sum(ismissing.(merged_genomes.allele_frequencies))
123725</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/merge.jl#L1-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.merge-Tuple{Genomes, Phenomes}"><a class="docstring-binding" href="#Base.merge-Tuple{Genomes, Phenomes}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge(genomes::Genomes, phenomes::Phenomes; keep_all::Bool=true)::Tuple{Genomes,Phenomes}</code></pre><p>Merge <code>Genomes</code> and <code>Phenomes</code> structs based on their entries, combining genomic and phenotypic data.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A struct containing genomic data including entries, populations, and allele frequencies</li><li><code>phenomes::Phenomes</code>: A struct containing phenotypic data including entries, populations, and phenotypes</li><li><code>keep_all::Bool=true</code>: If true, performs a union of entries; if false, performs an intersection</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Genomes,Phenomes}</code>: A tuple containing:<ul><li>A new <code>Genomes</code> struct with merged entries and corresponding genomic data</li><li>A new <code>Phenomes</code> struct with merged entries and corresponding phenotypic data</li></ul></li></ul><p><strong>Details</strong></p><ul><li>Maintains dimensional consistency between input and output structs</li><li>Handles population conflicts by creating a combined population name</li><li>Preserves allele frequencies and phenotypic data for matched entries</li><li>When <code>keep_all=true</code>, includes all entries from both structs</li><li>When <code>keep_all=false</code>, includes only entries present in both structs</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=10, verbose=false);

julia&gt; trials, effects = simulatetrials(genomes=slice(genomes, idx_entries=collect(1:5), idx_loci_alleles=collect(1:length(genomes.loci_alleles))), f_add_dom_epi=[0.90 0.05 0.05;], n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=2, verbose=false);

julia&gt; phenomes = Phenomes(n=5, t=1);

julia&gt; phenomes.entries = trials.entries[1:5];

julia&gt; phenomes.populations = trials.populations[1:5];

julia&gt; phenomes.traits = trials.traits;

julia&gt; phenomes.phenotypes = trials.phenotypes[1:5, :];

julia&gt; phenomes.mask .= true;

julia&gt; genomes_merged_1, phenomes_merged_1 = merge(genomes, phenomes, keep_all=true);

julia&gt; size(genomes_merged_1.allele_frequencies), size(phenomes_merged_1.phenotypes)
((10, 10000), (10, 1))

julia&gt; genomes_merged_2, phenomes_merged_2 = merge(genomes, phenomes, keep_all=false);

julia&gt; size(genomes_merged_2.allele_frequencies), size(phenomes_merged_2.phenotypes)
((5, 10000), (5, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/merge.jl#L291-L341">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.merge-Tuple{Phenomes, Phenomes}"><a class="docstring-binding" href="#Base.merge-Tuple{Phenomes, Phenomes}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge(
    phenomes::Phenomes,
    other::Phenomes;
    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),
    verbose::Bool = true
)::Phenomes</code></pre><p>Merge two <code>Phenomes</code> structs into a single combined struct, handling overlapping entries and traits.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: The first Phenomes struct to merge</li><li><code>other::Phenomes</code>: The second Phenomes struct to merge</li><li><code>conflict_resolution::Tuple{Float64,Float64}</code>: Weights for resolving conflicts between overlapping values (must sum to 1.0)</li><li><code>verbose::Bool</code>: Whether to display a progress bar during merging</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new merged Phenomes struct containing all entries and traits from both input structs</li></ul><p><strong>Details</strong></p><p>The merge operation combines:</p><ul><li>All unique entries from both structs</li><li>All unique traits from both structs</li><li>Phenotype values and masks, using weighted averaging for conflicts</li><li>Population information, marking conflicts with a &quot;CONFLICT&quot; prefix</li></ul><p>For overlapping entries and traits:</p><ul><li>Identical values are preserved as-is</li><li>Different values are combined using the weights specified in <code>conflict_resolution</code></li><li>Missing values are handled by using the available non-missing value</li><li>Population conflicts are marked in the format &quot;CONFLICT (pop1, pop2)&quot;</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If either Phenomes struct is corrupted (invalid dimensions)</li><li><code>ArgumentError</code>: If conflict_resolution weights don&#39;t sum to 1.0 or aren&#39;t a 2-tuple</li><li><code>ErrorException</code>: If the merging operation produces an invalid result</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; all = Phenomes(n=10, t=3); all.entries = string.(&quot;entry_&quot;, 1:10); all.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; all.phenotypes = rand(10,3);

julia&gt; phenomes = slice(all, idx_entries=collect(1:7), idx_traits=[1,2]);

julia&gt; other = slice(all, idx_entries=collect(5:10), idx_traits=[2,3]);

julia&gt; merged_phenomes = merge(phenomes, other, conflict_resolution=(0.75, 0.25), verbose=false);

julia&gt; size(merged_phenomes.phenotypes)
(10, 3)

julia&gt; sum(ismissing.(merged_phenomes.phenotypes))
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/merge.jl#L1-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.merge-Tuple{Trials, Trials}"><a class="docstring-binding" href="#Base.merge-Tuple{Trials, Trials}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge(trials::Trials, other::Trials; conflict_resolution::Tuple{Float64,Float64}=(0.5, 0.5), verbose::Bool=true)::Trials</code></pre><p>Merge two <code>Trials</code> structs into a single combined <code>Trials</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: The first Trials struct to merge</li><li><code>other::Trials</code>: The second Trials struct to merge</li><li><code>conflict_resolution::Tuple{Float64,Float64}</code>: Weights for resolving conflicts when the same trait measurement exists in both trials.  Default is (0.5, 0.5), meaning equal weights. Must sum to 1.0</li><li><code>verbose::Bool</code>: Whether to print progress information. Default is <code>true</code></li></ul><p><strong>Returns</strong></p><ul><li><code>::Trials</code>: A new merged Trials struct containing combined data from both input trials</li></ul><p><strong>Details</strong></p><p>The function performs an outer join of the two trial datasets, combining them based on their identifying columns  (years, seasons, harvests, sites, replications, blocks, rows, cols, entries, populations).</p><p>For traits that exist in both trials:</p><ul><li>If a measurement exists in only one trial, that value is used</li><li>If measurements exist in both trials, they are combined using weighted average based on conflict_resolution weights</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If either input Trials struct is corrupted (invalid dimensions)</li><li><code>ArgumentError</code>: If conflict_resolution is not a 2-element tuple summing to 1.0</li><li><code>ArgumentError</code>: If the resulting merged Trials struct is corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials_all, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false); 

julia&gt; trials = slice(trials_all, entries=sort(unique(trials_all.entries))[1:(end-1)], traits=trials_all.traits[1:(end-1)]); 

julia&gt; other = slice(trials_all, entries=sort(unique(trials_all.entries))[2:end], traits=trials_all.traits[2:end]);

julia&gt; trials_merged = merge(trials, other, conflict_resolution=(0.5, 0.5), verbose=false);

julia&gt; dimensions(trials_merged)[&quot;n_missing&quot;] &gt; dimensions(trials_all)[&quot;n_missing&quot;]
true

julia&gt; trials = slice(trials_all, entries=sort(unique(trials_all.entries))[1:50]); 

julia&gt; other = slice(trials_all, entries=sort(unique(trials_all.entries))[51:end]);

julia&gt; trials_merged = merge(trials, other, conflict_resolution=(0.5, 0.5), verbose=false);

julia&gt; dimensions(trials_merged) == dimensions(trials_all)
true

julia&gt; trials = slice(trials_all, traits=trials_all.traits[1:1]); 

julia&gt; other = slice(trials_all, traits=trials_all.traits[2:end]);

julia&gt; trials_merged = merge(trials, other, conflict_resolution=(0.5, 0.5), verbose=false);

julia&gt; dimensions(trials_merged) == dimensions(trials_all)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/merge.jl#L1-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.sum-Tuple{SimulatedEffects}"><a class="docstring-binding" href="#Base.sum-Tuple{SimulatedEffects}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sum(effects::SimulatedEffects)::Vector{Float64}</code></pre><p>Sum up all simulated effects to generate the simulated phenotype values. The function iterates through all fields of the SimulatedEffects struct (except :id and :field_layout) and adds their values element-wise to produce a vector of phenotypic values.</p><p><strong>Arguments</strong></p><ul><li><code>effects::SimulatedEffects</code>: A struct containing various genetic and environmental effects</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: A vector containing the summed effects (phenotypic values)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; effects = SimulatedEffects();

julia&gt; sum(effects)
1-element Vector{Float64}:
 0.0

julia&gt; effects.additive_genetic[1] = pi;

julia&gt; sum(effects)
1-element Vector{Float64}:
 3.141592653589793</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L131-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.addcompositetrait-Tuple{Phenomes}"><a class="docstring-binding" href="#GenomicBreedingCore.addcompositetrait-Tuple{Phenomes}"><code>GenomicBreedingCore.addcompositetrait</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">addcompositetrait(phenomes::Phenomes; composite_trait_name::String, formula_string::String)::Phenomes</code></pre><p>Create a new composite trait by combining existing traits using mathematical operations.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing the original trait data</li><li><code>composite_trait_name::String</code>: Name for the new composite trait</li><li><code>formula_string::String</code>: Mathematical formula describing how to combine existing traits.  Supports traits as variables and the following operations:<ul><li>Basic arithmetic: +, -, *, /, ^, %</li><li>Functions: abs(), sqrt(), log(), log2(), log10()</li><li>Parentheses for operation precedence</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new Phenomes struct with the composite trait added as the last column</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = rand(10,3);

julia&gt; phenomes_new = addcompositetrait(phenomes, composite_trait_name = &quot;some_wild_composite_trait&quot;, formula_string = &quot;A&quot;);

julia&gt; phenomes_new.phenotypes[:, end] == phenomes.phenotypes[:, 1]
true

julia&gt; phenomes_new = addcompositetrait(phenomes, composite_trait_name = &quot;some_wild_composite_trait&quot;, formula_string = &quot;(A^B) + (C/A) - sqrt(abs(B-A)) + log(1.00 + C)&quot;);

julia&gt; phenomes_new.phenotypes[:, end] == (phenomes.phenotypes[:,1].^phenomes.phenotypes[:,2]) .+ (phenomes.phenotypes[:,3]./phenomes.phenotypes[:,1]) .- sqrt.(abs.(phenomes.phenotypes[:,2].-phenomes.phenotypes[:,1])) .+ log.(1.00 .+ phenomes.phenotypes[:,3])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/merge.jl#L243-L274">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.addcompositetrait-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.addcompositetrait-Tuple{Trials}"><code>GenomicBreedingCore.addcompositetrait</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">addcompositetrait(trials::Trials; composite_trait_name::String, formula_string::String)::Trials</code></pre><p>Create a new composite trait by combining existing traits using a mathematical formula.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A Trials struct containing phenotypic data</li><li><code>composite_trait_name::String</code>: Name for the new composite trait</li><li><code>formula_string::String</code>: Mathematical formula defining how to combine existing traits</li></ul><p><strong>Formula Syntax</strong></p><p>The formula can include:</p><ul><li>Trait names (e.g., &quot;trait<em>1&quot;, &quot;trait</em>2&quot;)</li><li>Mathematical operators: +, -, *, /, ^, %</li><li>Functions: abs(), sqrt(), log(), log2(), log10()</li><li>Parentheses for grouping operations</li></ul><p><strong>Returns</strong></p><ul><li><code>Trials</code>: A new Trials struct with the added composite trait</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; trials_new = addcompositetrait(trials, composite_trait_name = &quot;some_wild_composite_trait&quot;, formula_string = &quot;trait_1&quot;);

julia&gt; trials_new.phenotypes[:, end] == trials.phenotypes[:, 1]
true

julia&gt; trials_new = addcompositetrait(trials, composite_trait_name = &quot;some_wild_composite_trait&quot;, formula_string = &quot;(trait_1^(trait_2/100)) + (trait_3/trait_1) - sqrt(abs(trait_2-trait_1)) + log(1.00 + trait_3)&quot;);

julia&gt; trials_new.phenotypes[:, end] == (trials.phenotypes[:,1].^(trials.phenotypes[:,2]/100)) .+ (trials.phenotypes[:,3]./trials.phenotypes[:,1]) .- sqrt.(abs.(trials.phenotypes[:,2].-trials.phenotypes[:,1])) .+ log.(1.00 .+ trials.phenotypes[:,3])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L517-L551">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.aggregateharvests-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.aggregateharvests-Tuple{Trials}"><code>GenomicBreedingCore.aggregateharvests</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">aggregateharvests(
    trials::Trials; 
    traits::Union{Vector{String}, Nothing} = nothing,
    grouping::Vector{String} = [&quot;years&quot;, &quot;seasons&quot;, &quot;sites&quot;, &quot;replications&quot;, &quot;blocks&quot;, &quot;rows&quot;, &quot;cols&quot;, &quot;entries&quot;, &quot;populations&quot;],
    f::Function=x -&gt; sum(skipmissing(x))
)::Tuple{Trials, DataFrame}</code></pre><p>Aggregate harvest data from a <code>Trials</code> struct by specified grouping variables.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: Input trials struct containing harvest data</li><li><code>traits::Union{Vector{String}, Nothing}</code>: Vector of trait names to aggregate (default: all traits)</li><li><code>grouping::Vector{String}</code>: Vector of column names to group by (default: [&quot;years&quot;, &quot;seasons&quot;, &quot;sites&quot;, &quot;replications&quot;, &quot;blocks&quot;, &quot;rows&quot;, &quot;cols&quot;, &quot;entries&quot;, &quot;populations&quot;])</li><li><code>f::Function</code>: Aggregation function to apply (default: sum of non-missing values)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Trials, DataFrame}</code>: A tuple containing:<ul><li>Aggregated trials struct with combined harvest data</li><li>DataFrame with harvest counts per year, season, and site</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(n=5, l=1000, verbose=false), verbose=false);

julia&gt; trials_agg_1, df_n_harvests_1 = aggregateharvests(trials);

julia&gt; length(trials.entries) &gt; length(trials_agg_1.entries)
true

julia&gt; trials_agg_2, df_n_harvests_2 = aggregateharvests(trials, traits=[&quot;trait_1&quot;]);

julia&gt; length(trials.traits) &gt; length(trials_agg_2.traits)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L411-L446">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.analyse"><a class="docstring-binding" href="#GenomicBreedingCore.analyse"><code>GenomicBreedingCore.analyse</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">analyse(
    trials::Trials,
    formula_string::String = &quot;&quot;;
    traits::Union{Nothing,Vector{String}} = nothing,
    max_levels::Int64 = 100,
    max_time_per_model::Int64 = 60,
    covariates_continuous::Union{Nothing,Vector{String}} = nothing,
    verbose::Bool = true
)::TEBV</code></pre><p>Analyze trial data using linear mixed models to estimate Best Linear Unbiased Estimates (BLUEs)  and Best Linear Unbiased Predictions (BLUPs).</p><p><strong>Arguments</strong></p><ul><li><code>trials</code>: A Trials struct containing the experimental data</li><li><code>formula_string</code>: Optional model formula string. If empty, automatic model selection is performed</li><li><code>traits</code>: Optional vector of trait names to analyze. If nothing, all traits are analyzed</li><li><code>max_levels</code>: Maximum number of levels for non-entry random effects (default: 100)</li><li><code>max_time_per_model</code>: Maximum fitting time in seconds per model (default: 60)</li><li><code>covariates_continuous</code>: Optional vector of continuous covariates to include in models</li><li><code>verbose</code>: Whether to display analysis progress (default: true)</li></ul><p><strong>Returns</strong></p><p>A <code>TEBV</code> struct containing:</p><ul><li><code>traits</code>: Vector of analyzed trait names</li><li><code>formulae</code>: Vector of best-fitting model formulae</li><li><code>models</code>: Vector of fitted LinearMixedModel objects</li><li><code>df_BLUEs</code>: Vector of DataFrames containing BLUEs</li><li><code>df_BLUPs</code>: Vector of DataFrames containing BLUPs</li><li><code>phenomes</code>: Vector of Phenomes objects with predicted values</li></ul><p><strong>Details</strong></p><p>The function implements a mixed model fitting strategy with the following principles:</p><ul><li>Avoids over-parameterization</li><li>Uses unstructured variance-covariance matrix for random effects</li><li>Prefers REML over ML estimation</li><li>Compares BLUEs vs BLUPs of entries</li><li>Handles both parallel and iterative model fitting based on model complexity</li></ul><p><strong>Notes</strong></p><ul><li>Models are fitted using REML</li><li>Simple models are fitted in parallel while complex models are fitted iteratively to avoid memory issues</li><li>Returns empty results if no models can be successfully fitted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);

julia&gt; tebv_1 = analyse(trials, &quot;trait_1 ~ 1 + (1|entries)&quot;, max_levels=50, verbose=false);

julia&gt; tebv_1.traits
3-element Vector{String}:
 &quot;trait_1&quot;
 &quot;trait_2&quot;
 &quot;trait_3&quot;

julia&gt; tebv_2 = analyse(trials, max_levels=50, verbose=false);

julia&gt; mean(tebv_2.phenomes[1].phenotypes) &lt; mean(tebv_2.phenomes[2].phenotypes)
true

julia&gt; trials = addcompositetrait(trials, composite_trait_name = &quot;covariate&quot;, formula_string = &quot;(trait_1 + trait_2) / (trait_3 + 0.0001)&quot;);

julia&gt; tebv_3 = Suppressor.@suppress analyse(trials, &quot;y ~ 1 + covariate + entries + (1|blocks)&quot;, max_levels=50, verbose=false);

julia&gt; mean(tebv_3.phenomes[1].phenotypes) &lt; mean(tebv_3.phenomes[2].phenotypes)
true

julia&gt; tebv_4 = Suppressor.@suppress analyse(trials, max_levels=50, covariates_continuous=[&quot;covariate&quot;], verbose=false);

julia&gt; mean(tebv_4.phenomes[1].phenotypes) &lt; mean(tebv_4.phenomes[2].phenotypes)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/lmm.jl#L598-L672">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.analyse-Tuple{DataFrames.DataFrame}"><a class="docstring-binding" href="#GenomicBreedingCore.analyse-Tuple{DataFrames.DataFrame}"><code>GenomicBreedingCore.analyse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">analyse(
    df::DataFrame; 
    formulae::Vector{String},
    idx_parallel_models::Vector{Int64},
    idx_iterative_models::Vector{Int64},
    max_time_per_model::Int64 = 60,
    verbose::Bool=false
)::Tuple{String, Any, DataFrame, DataFrame, Phenomes}</code></pre><p>Fit univariate linear mixed models to extract entry effects from the best-fitting model.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: Input data frame containing trial data with columns for entries, traits, and other experimental factors</li><li><code>formulae::Vector{String}</code>: Vector of model formulae strings to be tested</li><li><code>idx_parallel_models::Vector{Int64}</code>: Indices of simpler models to be fitted in parallel</li><li><code>idx_iterative_models::Vector{Int64}</code>: Indices of complex models to be fitted iteratively</li><li><code>max_time_per_model::Int64</code>: Maximum time in seconds allowed for fitting each model (default: 60)</li><li><code>verbose::Bool</code>: Whether to display progress information (default: false)</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li>String: Formula of the best-fitting model</li><li>Any: The fitted model object</li><li>DataFrame: BLUEs (Best Linear Unbiased Estimates) results</li><li>DataFrame: BLUPs (Best Linear Unbiased Predictions) results</li><li>Phenomes: Struct containing consolidated phenotypic predictions</li></ol><p><strong>Details</strong></p><p>The function implements a mixed model fitting strategy with the following principles:</p><ul><li>Avoids over-parameterization</li><li>Uses unstructured variance-covariance matrix for random effects</li><li>Prefers REML over ML estimation</li><li>Compares BLUEs vs BLUPs of entries</li><li>Handles both parallel and iterative model fitting based on model complexity</li></ul><p><strong>Notes</strong></p><ul><li>All formulae must model the same trait</li><li>Models are fitted using REML</li><li>Simple models are fitted in parallel while complex models are fitted iteratively to avoid memory issues</li><li>Returns empty results if no models can be successfully fitted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; df = tabularise(trials);

julia&gt; formulae, n_levels = trialsmodelsfomulae!(df; trait = &quot;trait_1&quot;, max_levels = 10);

julia&gt; idx_parallel_models::Vector{Int64} = findall(n_levels .&lt;= (15));

julia&gt; idx_iterative_models::Vector{Int64} = findall((n_levels .&lt;= (15)) .!= true);

julia&gt; formula_string, model, df_BLUEs, df_BLUPs, phenomes = analyse(df, formulae=formulae, idx_parallel_models=idx_parallel_models, idx_iterative_models=idx_iterative_models);

julia&gt; length(phenomes.entries) == length(unique(df.entries))
true

julia&gt; df_2 = df[(df.years .== df.years[1]) .&amp;&amp; (df.harvests .== df.harvests[1]) .&amp;&amp; (df.seasons .== df.seasons[1]) .&amp;&amp; (df.sites .== df.sites[1]) .&amp;&amp; (df.replications .== df.replications[1]), :];

julia&gt; formula_string_2, model_2, df_BLUEs_2, df_BLUPs_2, phenomes_2 = analyse(df_2, formulae=[&quot;trait_1 ~ 1 + 1|entries&quot;]);

julia&gt; cor(phenomes_2.phenotypes[sortperm(phenomes_2.entries),1], df_2.trait_1[sortperm(df_2.entries)]) &gt; 0.99
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/lmm.jl#L297-L363">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.checkdims-Tuple{CV}"><a class="docstring-binding" href="#GenomicBreedingCore.checkdims-Tuple{CV}"><code>GenomicBreedingCore.checkdims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkdims(cv::CV; verbose::Bool=false)::Bool</code></pre><p>Check dimension compatibility of the fields of the CV struct.</p><p>The function verifies that:</p><ul><li>The fit object dimensions are valid</li><li>The number of validation populations matches the number of validation entries</li><li>The number of validation true values matches the number of validation predictions</li><li>The number of metrics matches the number of metrics in the fit object</li></ul><p><strong>Arguments</strong></p><ul><li><code>blr::CV</code>: The CV struct to check dimensions for</li><li><code>verbose::Bool=false</code>: If true, prints the dimensions of each field for debugging</li></ul><p><strong>Returns:</strong></p><ul><li><code>true</code> if all dimensions are compatible</li><li><code>false</code> if any dimension mismatch is found</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; cv = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit.metrics);

julia&gt; checkdims(cv)
true

julia&gt; cv.validation_y_true = [0.0, 0.0];

julia&gt; checkdims(cv)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/cv/cv.jl#L125-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.checkdims-Tuple{Fit}"><a class="docstring-binding" href="#GenomicBreedingCore.checkdims-Tuple{Fit}"><code>GenomicBreedingCore.checkdims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkdims(fit::Fit; verbose::Bool=false)::Bool</code></pre><p>Check dimension compatibility of the internal fields of a <code>Fit</code> struct.</p><p>This function verifies that all vector fields in the <code>Fit</code> struct have compatible dimensions:</p><ul><li>Length of <code>entries</code>, <code>populations</code>, <code>y_true</code>, and <code>y_pred</code> must be equal (denoted as <code>n</code>)</li><li>Length of <code>b_hat</code> and <code>b_hat_labels</code> must be equal (denoted as <code>l</code>)</li></ul><p>Returns <code>true</code> if all dimensions are compatible, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>fit::Fit</code>: The Fit struct to check dimensions for</li><li><code>verbose::Bool=false</code>: If true, prints the dimensions of each field for debugging</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if dimensions are compatible, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=4);

julia&gt; checkdims(fit)
true

julia&gt; fit.b_hat_labels = [&quot;chr1\t1\tA|T\tA&quot;];

julia&gt; checkdims(fit)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/fit/fit.jl#L121-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.checkdims-Tuple{GRM}"><a class="docstring-binding" href="#GenomicBreedingCore.checkdims-Tuple{GRM}"><code>GenomicBreedingCore.checkdims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkdims(grm::GRM; verbose::Bool=false)::Bool</code></pre><p>Check dimension compatibility of the GRM (Genomic Relationship Matrix) struct fields.</p><p><strong>Arguments</strong></p><ul><li><code>grm::GRM</code>: A Genomic Relationship Matrix struct containing entries and relationship matrix</li><li><code>verbose::Bool=false</code>: If true, prints the dimensions of each field for debugging</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the number of entries matches the dimensions of the genomic relationship matrix</li><li><code>false</code> if there is a mismatch between the number of entries and matrix dimensions</li></ul><p><strong>Details</strong></p><p>The function verifies that:</p><ol><li>The number of entries equals the number of rows in the genomic relationship matrix</li><li>The number of entries equals the number of columns in the genomic relationship matrix</li></ol><p>(The genomic relationship matrix should be square with dimensions matching the number of entries)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; grm = GRM(string.([&quot;entries_1&quot;, &quot;entries_2&quot;]), string.([&quot;chr1	123	A|T	A&quot;, &quot;chr1	456	C|G	G&quot;]), Float64.(rand(2,2)));

julia&gt; checkdims(grm)
true

julia&gt; grm.entries = [&quot;dummy_entry&quot;];

julia&gt; checkdims(grm)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/grm/grm.jl#L99-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.checkdims-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.checkdims-Tuple{Genomes}"><code>GenomicBreedingCore.checkdims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkdims(genomes::Genomes; verbose::Bool=false)::Bool</code></pre><p>Check dimension compatibility of the fields in a <code>Genomes</code> struct.</p><p>Returns <code>true</code> if all dimensions are compatible, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing genomic data</li><li><code>verbose::Bool=false</code>: If true, prints the dimensions of each field for debugging</li></ul><p><strong>Details</strong></p><p>Verifies that:</p><ul><li>Number of entries matches number of populations (n)</li><li>Entry names are unique</li><li>Number of loci alleles matches width of frequency matrix (p) </li><li>Locus-allele combinations are unique</li><li>Entries are unique</li><li>Dimensions of frequency matrix (n×p) match mask matrix dimensions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = Genomes(n=2,p=4);

julia&gt; checkdims(genomes)
false

julia&gt; genomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;];

julia&gt; genomes.loci_alleles = [&quot;chr1\t1\tA|T\tA&quot;, &quot;chr1\t2\tC|G\tG&quot;, &quot;chr2\t3\tA|T\tA&quot;, &quot;chr2\t4\tG|T\tG&quot;];

julia&gt; checkdims(genomes)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L115-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.checkdims-Tuple{Phenomes}"><a class="docstring-binding" href="#GenomicBreedingCore.checkdims-Tuple{Phenomes}"><code>GenomicBreedingCore.checkdims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkdims(y::Phenomes; verbose::Bool=false)::Bool</code></pre><p>Verify dimensional compatibility between all fields of a Phenomes struct.</p><p>Checks if:</p><ul><li>Number of entries matches the number of rows in phenotypes matrix</li><li>All entry names are unique</li><li>Number of populations matches number of entries</li><li>Number of traits matches number of columns in phenotypes matrix</li><li>All trait names are unique</li><li>Dimensions of mask matrix match phenotypes matrix</li></ul><p><strong>Arguments</strong></p><ul><li><code>y::Phenomes</code>: A Phenomes struct containing phenotypic data</li><li><code>verbose::Bool=false</code>: If true, prints the dimensions of each field for debugging</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if all dimensions are compatible, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; y = Phenomes(n=2, t=2);

julia&gt; checkdims(y)
false

julia&gt; y.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;];

julia&gt; y.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; checkdims(y)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/phenomes.jl#L107-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.checkdims-Tuple{SimulatedEffects}"><a class="docstring-binding" href="#GenomicBreedingCore.checkdims-Tuple{SimulatedEffects}"><code>GenomicBreedingCore.checkdims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkdims(effects::SimulatedEffects)::Bool</code></pre><p>Check dimension compatibility of the fields of the SimulatedEffects struct.</p><p><strong>Arguments</strong></p><ul><li><code>effects::SimulatedEffects</code>: A SimulatedEffects struct containing various genetic and experimental effects</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if all dimensions are compatible, <code>false</code> otherwise</li></ul><p>Verifies that:</p><ul><li><code>id</code> has length 6</li><li><code>field_layout</code> has 4 columns </li><li>All following vectors have the same length (n):<ul><li><code>replications_x_site_x_harvest_x_season_x_year</code></li><li><code>blocks_x_site_x_harvest_x_season_x_year</code></li><li><code>rows_x_site_x_harvest_x_season_x_year</code></li><li><code>cols_x_site_x_harvest_x_season_x_year</code></li><li><code>additive_genetic</code></li><li><code>dominance_genetic</code></li><li><code>epistasis_genetic</code></li><li><code>additive_allele_x_site_x_harvest_x_season_x_year</code></li><li><code>dominance_allele_x_site_x_harvest_x_season_x_year</code></li><li><code>epistasis_allele_x_site_x_harvest_x_season_x_year</code></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; effects = SimulatedEffects();

julia&gt; typeof(hash(effects))
UInt64</code></pre><p>jldoctest; setup = :(using GenomicBreedingCore) julia&gt; effects = SimulatedEffects();</p><p>julia&gt; checkdims(effects) true</p><p>julia&gt; effects.id = [&quot;beaking_change&quot;];</p><p>julia&gt; checkdims(effects) false ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L69-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.checkdims-Tuple{TEBV}"><a class="docstring-binding" href="#GenomicBreedingCore.checkdims-Tuple{TEBV}"><code>GenomicBreedingCore.checkdims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkdims(y::TEBV; verbose::Bool=false)::Bool</code></pre><p>Check if all fields in the TEBV struct have compatible dimensions. The function verifies that the length of all arrays in the TEBV struct match the number of traits.</p><p><strong>Arguments</strong></p><ul><li><code>tebv::TEBV</code>: A TEBV (Trial-estimated Breeding Values) struct containing traits, formulae, models, BLUEs, BLUPs, and phenomes.</li><li><code>verbose::Bool=false</code>: If true, prints the dimensions of each field for debugging</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: Returns <code>true</code> if all fields have matching dimensions (equal to the number of traits), <code>false</code> otherwise.</li></ul><p><strong>Details</strong></p><p>The function checks if the following fields have the same length as <code>traits</code>:</p><ul><li>formulae</li><li>unique models</li><li>unique BLUEs DataFrames</li><li>unique BLUPs DataFrames</li><li>unique phenomes</li></ul><p><strong>Examples</strong></p><p>``<code>jldoctest; setup = :(using GenomicBreedingCore, MixedModels, DataFrames)</code> julia&gt; tebv = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df<em>BLUEs=[DataFrame(x=1)], df</em>BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);</p><p>julia&gt; checkdims(tebv) true ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/tebv.jl#L119-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.checkdims-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.checkdims-Tuple{Trials}"><code>GenomicBreedingCore.checkdims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">checkdims(trials::Trials; verbose::Bool=false)::Bool</code></pre><p>Check dimension compatibility of all fields in a <code>Trials</code> struct.</p><p>This function verifies that the dimensions of all vector fields in the <code>Trials</code> struct are  consistent with the size of the phenotypes matrix. Specifically, it checks:</p><ul><li>Number of traits (<code>t</code>) matches number of columns in phenotypes and length of traits vector</li><li>Number of entries (<code>n</code>) matches number of rows in phenotypes and length of:<ul><li>years</li><li>seasons</li><li>harvests</li><li>sites</li><li>replications</li><li>blocks</li><li>rows</li><li>cols</li><li>entries</li><li>populations</li></ul></li></ul><p>Returns <code>true</code> if all dimensions are compatible, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A Trials struct containing trial data</li><li><code>verbose::Bool=false</code>: If true, prints the dimensions of each field for debugging</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if dimensions are compatible, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=1, t=2);

julia&gt; trials.entries = [&quot;entry_1&quot;]; trials.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; checkdims(trials)
true

julia&gt; trials.entries = [&quot;entering_2_entries&quot;, &quot;instead_of_just_1&quot;];

julia&gt; checkdims(trials)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L100-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.clone-Tuple{CV}"><a class="docstring-binding" href="#GenomicBreedingCore.clone-Tuple{CV}"><code>GenomicBreedingCore.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(x::CV)::CV</code></pre><p>Create a deep copy of a CV (cross-validation) object.</p><p>Creates a new CV object with deep copies of all fields from the input object. The clone function ensures that modifications to the cloned object do not affect  the original object.</p><p><strong>Arguments</strong></p><ul><li><code>x::CV</code>: The CV object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>CV</code>: A new CV object containing deep copies of all fields from the input</li></ul><p><strong>Example</strong></p><p>Clone a CV object</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; cv = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit.metrics);

julia&gt; copy_cv = clone(cv)
CV(&quot;replication_1&quot;, &quot;fold_1&quot;, Fit(&quot;&quot;, [&quot;&quot;, &quot;&quot;], [0.0, 0.0], &quot;&quot;, [&quot;&quot;], [&quot;&quot;], [0.0], [0.0], Dict(&quot;&quot; =&gt; 0.0), nothing), [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], Dict(&quot;&quot; =&gt; 0.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/cv/cv.jl#L1-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.clone-Tuple{Fit}"><a class="docstring-binding" href="#GenomicBreedingCore.clone-Tuple{Fit}"><code>GenomicBreedingCore.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(x::Fit)::Fit</code></pre><p>Create a deep copy of a Fit object, duplicating all its fields.</p><p>This function performs a deep clone of the input Fit object, ensuring that all nested structures and arrays are also copied, preventing any shared references between the original and the cloned object.</p><p><strong>Arguments</strong></p><ul><li><code>x::Fit</code>: The Fit object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>Fit</code>: A new Fit object with identical but independent values</li></ul><p><strong>Fields copied</strong></p><ul><li><code>model</code>: The statistical model</li><li><code>b_hat_labels</code>: Labels for the estimated parameters</li><li><code>b_hat</code>: Estimated parameters</li><li><code>trait</code>: The trait being analyzed</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>metrics</code>: Performance metrics</li><li><code>y_true</code>: Observed values</li><li><code>y_pred</code>: Predicted values</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=1, l=2);

julia&gt; copy_fit = clone(fit)
Fit(&quot;&quot;, [&quot;&quot;, &quot;&quot;], [0.0, 0.0], &quot;&quot;, [&quot;&quot;], [&quot;&quot;], [0.0], [0.0], Dict(&quot;&quot; =&gt; 0.0), nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/fit/fit.jl#L1-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.clone-Tuple{GRM}"><a class="docstring-binding" href="#GenomicBreedingCore.clone-Tuple{GRM}"><code>GenomicBreedingCore.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(x::GRM)::GRM</code></pre><p>Create a deep copy of a GRM (Genomic Relationship Matrix) object.</p><p>Creates a new GRM object with deep copies of all fields from the input object. The clone function ensures that modifications to the cloned object do not affect  the original object.</p><p><strong>Arguments</strong></p><ul><li><code>x::GRM</code>: The GRM object to be cloned </li></ul><p><strong>Returns</strong></p><ul><li><code>GRM</code>: A new GRM object containing deep copies of the entries, loci<em>alleles,         and genomic</em>relationship_matrix fields from the input</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; grm = GRM(string.([&quot;entries_1&quot;, &quot;entries_2&quot;]), string.([&quot;chr1	123	A|T	A&quot;, &quot;chr1	456	C|G	G&quot;]), Float64.(rand(2,2)));

julia&gt; copy_grm = clone(grm);

julia&gt; (copy_grm.entries == grm.entries) &amp;&amp; (copy_grm.loci_alleles == grm.loci_alleles) &amp;&amp; (copy_grm.genomic_relationship_matrix == grm.genomic_relationship_matrix)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/grm/grm.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.clone-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.clone-Tuple{Genomes}"><code>GenomicBreedingCore.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(x::Genomes)::Genomes</code></pre><p>Create a deep copy of a <code>Genomes</code> object.</p><p>This function performs a deep clone of all fields in the <code>Genomes</code> object, including:</p><ul><li>entries</li><li>populations </li><li>loci_alleles</li><li>allele_frequencies</li><li>mask</li></ul><p>Returns a new <code>Genomes</code> instance with identical but independent data.</p><p><strong>Arguments</strong></p><ul><li><code>x::Genomes</code>: The source Genomes object to clone</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new Genomes object containing deep copies of all fields</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = Genomes(n=2, p=2);

julia&gt; copy_genomes = clone(genomes)
Genomes([&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.clone-Tuple{Phenomes}"><a class="docstring-binding" href="#GenomicBreedingCore.clone-Tuple{Phenomes}"><code>GenomicBreedingCore.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(x::Phenomes)::Phenomes</code></pre><p>Create a deep copy of a <code>Phenomes</code> object, including all its fields.</p><p>This function performs a deep copy of the following fields:</p><ul><li>entries: Vector of entry names</li><li>populations: Vector of population identifiers</li><li>traits: Vector of trait names</li><li>phenotypes: Matrix of phenotypic values</li><li>mask: Matrix of boolean masks</li></ul><p>Returns a new <code>Phenomes</code> object with identical structure but independent memory allocation.</p><p><strong>Arguments</strong></p><ul><li><code>x::Phenomes</code>: The source Phenomes object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new Phenomes object containing deep copies of all fields</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=2, t=2);

julia&gt; copy_phenomes = clone(phenomes)
Phenomes([&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/phenomes.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.clone-Tuple{TEBV}"><a class="docstring-binding" href="#GenomicBreedingCore.clone-Tuple{TEBV}"><code>GenomicBreedingCore.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(x::TEBV)::TEBV</code></pre><p>Create a deep copy of a TEBV (Trial-Estimated Breeding Value) object.</p><p>Returns a new TEBV instance with all fields deeply copied from the input object, ensuring complete independence between the original and cloned objects.</p><p><strong>Arguments</strong></p><ul><li><code>x::TEBV</code>: The source TEBV object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>TEBV</code>: A new TEBV object containing deep copies of all fields from the input</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv = TEBV(traits=[&quot;&quot;], formulae=[&quot;&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; copy_tebv = clone(tebv);

julia&gt; copy_tebv.traits == tebv.traits
true

julia&gt; copy_tebv.phenomes == tebv.phenomes
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/tebv.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.clone-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.clone-Tuple{Trials}"><code>GenomicBreedingCore.clone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">clone(x::Trials)::Trials</code></pre><p>Create a deep copy of a <code>Trials</code> object, including all its fields.</p><p>This function performs a complete deep copy of the input <code>Trials</code> object, ensuring that all nested data structures are also copied rather than referenced.</p><p><strong>Arguments</strong></p><ul><li><code>x::Trials</code>: The source <code>Trials</code> object to be cloned</li></ul><p><strong>Returns</strong></p><ul><li><code>Trials</code>: A new <code>Trials</code> object containing copies of all data from the input</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=2, t=2);

julia&gt; copy_trials = clone(trials)
Trials(Union{Missing, Float64}[missing missing; missing missing], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.countlevels-Tuple{DataFrames.DataFrame}"><a class="docstring-binding" href="#GenomicBreedingCore.countlevels-Tuple{DataFrames.DataFrame}"><code>GenomicBreedingCore.countlevels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">countlevels(df::DataFrame; column_names::Vector{String})::Int64</code></pre><p>Count the total number of unique values (factor levels) across specified columns in a DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: Input DataFrame to analyze</li><li><code>column_names::Vector{String}</code>: Vector of column names to count unique values from</li></ul><p><strong>Returns</strong></p><ul><li><code>Int64</code>: Sum of unique values across all specified columns</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any of the specified column names are not found in the DataFrame</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/lmm.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.dimensions-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.dimensions-Tuple{Genomes}"><code>GenomicBreedingCore.dimensions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dimensions(genomes::Genomes)::Dict{String, Int64}</code></pre><p>Calculate various dimensional metrics of a Genomes struct.</p><p>Returns a dictionary containing the following metrics:</p><ul><li><code>&quot;n_entries&quot;</code>: Number of unique entries/samples</li><li><code>&quot;n_populations&quot;</code>: Number of unique populations</li><li><code>&quot;n_loci_alleles&quot;</code>: Total number of loci-allele combinations</li><li><code>&quot;n_chr&quot;</code>: Number of chromosomes</li><li><code>&quot;n_loci&quot;</code>: Number of unique loci across all chromosomes</li><li><code>&quot;max_n_alleles&quot;</code>: Maximum number of alleles observed at any locus</li><li><code>&quot;n_missing&quot;</code>: Count of missing values in allele frequencies</li></ul><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A valid Genomes struct containing genetic data</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String,Int64}</code>: Dictionary containing dimensional metrics</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Genomes struct is corrupted (fails dimension check)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; dimensions(genomes)
Dict{String, Int64} with 7 entries:
  &quot;n_entries&quot;      =&gt; 100
  &quot;n_chr&quot;          =&gt; 7
  &quot;n_loci&quot;         =&gt; 1000
  &quot;n_loci_alleles&quot; =&gt; 3000
  &quot;n_populations&quot;  =&gt; 1
  &quot;n_missing&quot;      =&gt; 0
  &quot;max_n_alleles&quot;  =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L172-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.dimensions-Tuple{Phenomes}"><a class="docstring-binding" href="#GenomicBreedingCore.dimensions-Tuple{Phenomes}"><code>GenomicBreedingCore.dimensions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dimensions(phenomes::Phenomes)::Dict{String, Int64}</code></pre><p>Calculate various dimensional statistics of a <code>Phenomes</code> struct.</p><p>Returns a dictionary containing counts of:</p><ul><li><code>&quot;n_entries&quot;</code>: unique entries in the dataset</li><li><code>&quot;n_populations&quot;</code>: unique populations</li><li><code>&quot;n_traits&quot;</code>: number of traits</li><li><code>&quot;n_total&quot;</code>: total number of phenotypic observations (entries × traits)</li><li><code>&quot;n_zeroes&quot;</code>: number of zero values in phenotypes</li><li><code>&quot;n_missing&quot;</code>: number of missing values</li><li><code>&quot;n_nan&quot;</code>: number of NaN values</li><li><code>&quot;n_inf&quot;</code>: number of infinite values</li></ul><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing phenotypic data</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String,Int64}</code>: Dictionary with dimensional statistics</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Phenomes struct dimensions are inconsistent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = fill(0.0, 10,3);

julia&gt; dimensions(phenomes)
Dict{String, Int64} with 8 entries:
  &quot;n_total&quot;       =&gt; 30
  &quot;n_zeroes&quot;      =&gt; 30
  &quot;n_nan&quot;         =&gt; 0
  &quot;n_entries&quot;     =&gt; 10
  &quot;n_traits&quot;      =&gt; 3
  &quot;n_inf&quot;         =&gt; 0
  &quot;n_populations&quot; =&gt; 1
  &quot;n_missing&quot;     =&gt; 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/phenomes.jl#L165-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.dimensions-Tuple{TEBV}"><a class="docstring-binding" href="#GenomicBreedingCore.dimensions-Tuple{TEBV}"><code>GenomicBreedingCore.dimensions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dimensions(tebv::TEBV)::Dict{String, Int64}</code></pre><p>Calculate various dimensional metrics for a TEBV (Trial-Estimated Breeding Values) struct.</p><p><strong>Arguments</strong></p><ul><li><code>tebv::TEBV</code>: A TEBV struct containing traits, formulae, models, BLUEs, BLUPs, and phenomes data</li></ul><p><strong>Returns</strong></p><p>A dictionary containing the following counts:</p><ul><li><code>&quot;n_entries&quot;</code>: Number of unique entries across all phenomes</li><li><code>&quot;n_populations&quot;</code>: Number of unique populations across all phenomes</li><li><code>&quot;n_traits&quot;</code>: Number of traits in the TEBV struct</li><li><code>&quot;n_total&quot;</code>: Total number of observations across all traits</li><li><code>&quot;n_zeroes&quot;</code>: Total number of zero values across all traits</li><li><code>&quot;n_missing&quot;</code>: Total number of missing values across all traits</li><li><code>&quot;n_nan&quot;</code>: Total number of NaN values across all traits</li><li><code>&quot;n_inf&quot;</code>: Total number of Infinite values across all traits</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the TEBV struct dimensions are inconsistent or corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tebv = TEBV(traits=[&quot;trait_1&quot;], formulae=[&quot;trait_1 ~ 1 + 1|entries&quot;], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);

julia&gt; dimensions(tebv)
Dict{String, Int64} with 8 entries:
  &quot;n_total&quot;       =&gt; 1
  &quot;n_zeroes&quot;      =&gt; 0
  &quot;n_nan&quot;         =&gt; 0
  &quot;n_entries&quot;     =&gt; 1
  &quot;n_traits&quot;      =&gt; 1
  &quot;n_inf&quot;         =&gt; 0
  &quot;n_populations&quot; =&gt; 1
  &quot;n_missing&quot;     =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/tebv.jl#L170-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.dimensions-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.dimensions-Tuple{Trials}"><code>GenomicBreedingCore.dimensions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dimensions(trials::Trials)::Dict{String, Int64}</code></pre><p>Calculate dimensional statistics of a <code>Trials</code> struct, returning a dictionary with counts of various elements.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A <code>Trials</code> struct containing trial data</li></ul><p><strong>Returns</strong></p><p>A <code>Dict{String, Int64}</code> with the following keys:</p><ul><li><code>&quot;n_traits&quot;</code>: Number of unique traits</li><li><code>&quot;n_years&quot;</code>: Number of unique years</li><li><code>&quot;n_seasons&quot;</code>: Number of unique seasons</li><li><code>&quot;n_harvests&quot;</code>: Number of unique harvests</li><li><code>&quot;n_sites&quot;</code>: Number of unique sites</li><li><code>&quot;n_replications&quot;</code>: Number of unique replications</li><li><code>&quot;n_blocks&quot;</code>: Number of unique blocks</li><li><code>&quot;n_rows&quot;</code>: Number of unique rows</li><li><code>&quot;n_cols&quot;</code>: Number of unique columns</li><li><code>&quot;n_entries&quot;</code>: Number of unique entries</li><li><code>&quot;n_populations&quot;</code>: Number of unique populations</li><li><code>&quot;n_total&quot;</code>: Total number of phenotype observations (entries × traits)</li><li><code>&quot;n_zeroes&quot;</code>: Count of zero values in phenotypes</li><li><code>&quot;n_missing&quot;</code>: Count of missing values in phenotypes</li><li><code>&quot;n_nan&quot;</code>: Count of NaN values in phenotypes</li><li><code>&quot;n_inf&quot;</code>: Count of Inf values in phenotypes</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Trials struct dimensions are inconsistent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=1, t=2);

julia&gt; trials.entries = [&quot;entry_1&quot;]; trials.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; dimensions(trials)
Dict{String, Int64} with 16 entries:
  &quot;n_zeroes&quot;       =&gt; 0
  &quot;n_harvests&quot;     =&gt; 1
  &quot;n_nan&quot;          =&gt; 0
  &quot;n_entries&quot;      =&gt; 1
  &quot;n_traits&quot;       =&gt; 2
  &quot;n_seasons&quot;      =&gt; 1
  &quot;n_rows&quot;         =&gt; 1
  &quot;n_blocks&quot;       =&gt; 1
  &quot;n_missing&quot;      =&gt; 2
  &quot;n_inf&quot;          =&gt; 0
  &quot;n_total&quot;        =&gt; 2
  &quot;n_replications&quot; =&gt; 1
  &quot;n_years&quot;        =&gt; 1
  &quot;n_sites&quot;        =&gt; 1
  &quot;n_cols&quot;         =&gt; 1
  &quot;n_populations&quot;  =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L178-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.distances-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.distances-Tuple{Genomes}"><code>GenomicBreedingCore.distances</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distances(
    genomes::Genomes; 
    distance_metrics::Vector{String}=[&quot;euclidean&quot;, &quot;correlation&quot;, &quot;mad&quot;, &quot;rmsd&quot;, &quot;χ²&quot;],
    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,
    include_loci_alleles::Bool = true,
    include_entries::Bool = true,
    include_counts::Bool = true,
    verbose::Bool = false
)::Tuple{Vector{String},Vector{String},Dict{String,Matrix{Float64}}}</code></pre><p>Calculate pairwise distances/similarity metrics between loci-alleles and entries in a <code>Genomes</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Input Genomes object</li><li><code>distance_metrics::Vector{String}</code>: Vector of distance metrics to calculate. Valid options:<ul><li>&quot;euclidean&quot;: Euclidean distance</li><li>&quot;correlation&quot;: Pearson correlation coefficient </li><li>&quot;mad&quot;: Mean absolute deviation</li><li>&quot;rmsd&quot;: Root mean square deviation </li><li>&quot;χ²&quot;: Chi-square distance</li></ul></li><li><code>idx_loci_alleles::Union{Nothing, Vector{Int64}}</code>: Optional indices of loci-alleles to include. If nothing, randomly samples 100 loci-alleles.</li><li><code>include_loci_alleles::Bool</code>: Whether to calculate distances between loci-alleles. Defaults to true.</li><li><code>include_entries::Bool</code>: Whether to calculate distances between entries. Defaults to true.</li><li><code>include_counts::Bool</code>: Whether to include matrices showing number of valid pairs used. Defaults to true.</li><li><code>verbose::Bool</code>: Whether to show progress bars. Defaults to false.</li></ul><p><strong>Returns</strong></p><p>Tuple containing:</p><ol><li>Vector of loci-allele names used</li><li>Vector of entry names  </li><li>Dictionary mapping &quot;{dimension}|{metric}&quot; to distance matrices, where:<ul><li>dimension is either &quot;loci_alleles&quot; or &quot;entries&quot;</li><li>metric is one of the distance metrics or &quot;counts&quot; (number of valid pairs used)</li><li>matrices contain pairwise distances/correlations (-Inf where insufficient data)</li></ul></li></ol><p><strong>Details</strong></p><ul><li>For loci-alleles, calculates distances between allele frequency profiles across entries</li><li>For entries, calculates distances between entries based on their allele frequencies</li><li>Requires at least 2 valid (non-missing, finite) pairs to calculate metrics</li><li>Includes count matrices showing number of valid pairs used per calculation</li><li>Multi-threaded implementation which uses indexing on pre-allocated vectors and matrices which should avoid data races</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; (loci_alleles_names, entries, dist) = distances(genomes, distance_metrics=[&quot;correlation&quot;, &quot;χ²&quot;]);

julia&gt; sort(string.(keys(dist))) == [&quot;entries|correlation&quot;, &quot;entries|counts&quot;, &quot;entries|χ²&quot;, &quot;loci_alleles|correlation&quot;, &quot;loci_alleles|counts&quot;, &quot;loci_alleles|χ²&quot;]
true

julia&gt; C = dist[&quot;entries|correlation&quot;]; C[diagind(C)] == repeat([1], length(genomes.entries))
true

julia&gt; χ² = dist[&quot;loci_alleles|χ²&quot;]; χ²[diagind(χ²)] == repeat([0.0], 100)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L390-L448">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.distances-Tuple{Phenomes}"><a class="docstring-binding" href="#GenomicBreedingCore.distances-Tuple{Phenomes}"><code>GenomicBreedingCore.distances</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distances(
    phenomes::Phenomes; 
    distance_metrics::Vector{String}=[&quot;euclidean&quot;, &quot;correlation&quot;, &quot;mad&quot;, &quot;rmsd&quot;, &quot;χ²&quot;],
    standardise_traits::Bool = false
)::Tuple{Vector{String}, Vector{String}, Dict{String, Matrix{Float64}}}</code></pre><p>Calculate pairwise distances/correlations between traits and entries in a phenotypic dataset.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing phenotypic data</li><li><code>distance_metrics::Vector{String}</code>: Vector of distance metrics to compute. Valid options are:<ul><li>&quot;euclidean&quot;: Euclidean distance</li><li>&quot;correlation&quot;: Pearson correlation coefficient</li><li>&quot;mad&quot;: Mean absolute deviation</li><li>&quot;rmsd&quot;: Root mean square deviation</li><li>&quot;χ²&quot;: Chi-square distance</li></ul></li><li><code>standardise_traits::Bool</code>: If true, standardizes traits to mean=0 and sd=1 before computing distances</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li>Vector of trait names</li><li>Vector of entry names</li><li>Dictionary mapping &quot;{dimension}|{metric}&quot; to distance matrices, where:<ul><li>dimension ∈ [&quot;traits&quot;, &quot;entries&quot;]</li><li>metric ∈ distance_metrics ∪ [&quot;counts&quot;]</li><li>&quot;counts&quot; matrices contain the number of non-missing pairs used in calculations</li></ul></li></ol><p><strong>Notes</strong></p><ul><li>Pairs with fewer than 2 non-missing values result in -Inf distance values</li><li>For correlation calculations, traits with near-zero variance (&lt; 1e-7) are skipped</li><li>χ² distance adds machine epsilon to denominator to avoid division by zero</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = rand(10,3); phenomes.phenotypes[2,2] = missing;

julia&gt; (traits, entries, dist) = distances(phenomes, distance_metrics=[&quot;correlation&quot;, &quot;χ²&quot;]);

julia&gt; sort(string.(keys(dist))) == [&quot;entries|correlation&quot;, &quot;entries|counts&quot;, &quot;entries|χ²&quot;, &quot;traits|correlation&quot;, &quot;traits|counts&quot;, &quot;traits|χ²&quot;]
true

julia&gt; C = dist[&quot;entries|correlation&quot;]; C[diagind(C)] == repeat([1], length(phenomes.entries))
true

julia&gt; dist[&quot;traits|counts&quot;][:, 2] == dist[&quot;traits|counts&quot;][2, :] == repeat([9], length(phenomes.traits))
true

julia&gt; dist[&quot;entries|counts&quot;][:, 2] == dist[&quot;entries|counts&quot;][2, :] == repeat([2], length(phenomes.entries))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/phenomes.jl#L222-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.divideintomockscaffolds-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.divideintomockscaffolds-Tuple{Genomes}"><code>GenomicBreedingCore.divideintomockscaffolds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ddivideintomockscaffolds(
    genomes::Genomes;
    max_n_loci_per_chrom::Int64 = 100_000,
    verbose::Bool = false,
)::Vector{String}</code></pre><p>Divide genomic loci into mock scaffolds based on a maximum number of loci per chromosome.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing genomic data</li><li><code>max_n_loci_per_chrom::Int64</code>: Maximum number of loci per chromosome (default: 100,000)</li><li><code>verbose::Bool</code>: If true, prints additional information during execution (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: A vector containing mock scaffold assignments for each locus</li></ul><p><strong>Description</strong></p><p>This function takes a Genomes struct and divides the loci into mock scaffolds based on the  specified maximum number of loci per chromosome. It creates scaffold names in the format  &quot;mock<em>scaffold</em>X&quot; where X is the scaffold number.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Genomes struct dimensions are invalid or corrupted</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=20, sparsity=0.3, verbose=false);

julia&gt; mock_scaffolds = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);

julia&gt; sum(mock_scaffolds .== mock_scaffolds[1]) == Int64(length(genomes.loci_alleles) / 100)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/impute.jl#L60-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.estimatedistances-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.estimatedistances-Tuple{Genomes}"><code>GenomicBreedingCore.estimatedistances</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimatedistances(
    genomes::Genomes;
    LD::Matrix{Float64},
    idx_focal_locus::Int64,
    idx_loci_alleles_per_chrom::Vector{Int64},
    min_loci_corr::Float64,
    min_l_loci::Int64,
    verbose::Bool = false,
)::Matrix{Float64}</code></pre><p>Estimate pairwise distances between entries based on loci most linked to a focal locus.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A <code>Genomes</code> struct containing the genomic data.</li><li><code>LD::Matrix{Float64}</code>: A linkage disequilibrium (LD) matrix.</li><li><code>idx_focal_locus::Int64</code>: The local index of the focal locus, i.e. index at the current chromosome or mock scaffold.</li><li><code>idx_loci_alleles_per_chrom::Vector{Int64}</code>: A vector of global indices for loci-alleles per chromosome, i.e. indices corresponding the whole <code>genomes.allele_frequencies</code> matrix.</li><li><code>min_loci_corr::Float64</code>: The minimum correlation threshold for loci to be considered linked.</li><li><code>min_l_loci::Int64</code>: The minimum number of loci required to be linked to the focal locus.</li><li><code>verbose::Bool</code>: If <code>true</code>, prints detailed progress information.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A matrix of pairwise distances between entries, estimated using the mean absolute difference (MAD) in allele frequencies of loci most linked to the focal locus.</li></ul><p><strong>Details</strong></p><p>This function calculates pairwise distances between entries in a genomic dataset. The distances are based on loci that are most correlated with a specified focal locus. The function uses the following steps:</p><ul><li>Input Validation: Checks the validity of the input arguments, ensuring the Genomes struct is not corrupted, the LD matrix is square, and the indices are within valid ranges.</li><li>Identify Linked Loci: Determines which loci are most linked to the focal locus based on the provided LD matrix and correlation threshold. If the number of linked loci is below the specified minimum, the top loci are selected based on their correlation values.</li><li>Estimate Distances: Calculates pairwise distances between entries using the mean absolute difference (MAD) in allele frequencies of the selected loci.</li><li>Output: Returns a matrix of pairwise distances.</li></ul><p><strong>Notes</strong></p><ul><li>The function identifies loci most linked to the focal locus based on the provided LD matrix and correlation threshold.</li><li>If all loci have undetermined level of linkage with the focal locus (i.e. -Inf values in the LD matrix), then all the loci-alleles are selected to estimate distances.</li><li>If the number of linked loci is below the specified minimum, then the minimum number of loci most correlated to the focal locus are selected to estimate distances.</li><li>Pairwise distances are estimated using the mean absolute difference (MAD) in allele frequencies of the selected loci.</li><li>Intermediate results and progress can be printed if verbose is set to true.</li></ul><p><strong>Throws</strong></p><ul><li>ArgumentError: If the input arguments are invalid or the Genomes struct is corrupted.</li><li>ArgumentError: If there are less than 2 indices for loci-alleles in the current chromosome.</li><li>ArgumentError: If the LD matrix is not square.</li><li>ArgumentError: If the LD matrix and the vector of indices are incompatible.</li><li>ArgumentError: If the focal locus index is out of range.</li><li>ArgumentError: If the minimum correlation threshold is out of range.</li><li>ArgumentError: If the minimum number of loci is out of range. </li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=40, l=1_000, sparsity=0.3, verbose=false);

julia&gt; chromosomes = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);

julia&gt; chroms_uniq, LDs = estimateld(genomes, chromosomes=chromosomes);

julia&gt; rm.(readdir()[.!isnothing.(match.(Regex(&quot;jld2&quot;), readdir()))]);

julia&gt; k = 1; LD = LDs[k]; chrom = chroms_uniq[k]; idx_focal_locus = 1;

julia&gt; idx_loci_alleles_per_chrom = findall(chromosomes .== chrom);

julia&gt; min_loci_corr = 0.9; min_l_loci = 2;

julia&gt; D = estimatedistances(genomes, LD=LD, idx_focal_locus=idx_focal_locus, idx_loci_alleles_per_chrom=idx_loci_alleles_per_chrom, min_loci_corr=min_loci_corr, min_l_loci=min_l_loci);

julia&gt; size(D) == (length(genomes.entries), length(genomes.entries))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/impute.jl#L280-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.estimateld-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.estimateld-Tuple{Genomes}"><code>GenomicBreedingCore.estimateld</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimateld(
    genomes::Genomes;
    chromosomes::Union{Nothing,Vector{String}} = nothing,
    verbose::Bool = false,
)::Tuple{Vector{String},Vector{Matrix{Float64}}}</code></pre><p>Calculate linkage disequilibrium (LD) matrices for each chromosome in the given genomic data.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing genomic data</li><li><code>chromosomes::Union{Nothing, Vector{String}}</code>: Optional vector of chromosome names to analyse. If nothing, all chromosomes in the data will be used</li><li><code>verbose::Bool</code>: If true, prints progress information during computation</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{String}, Vector{Matrix{Float64}}}</code>: A tuple containing:<ul><li>A vector of unique chromosome names.</li><li>A vector of LD matrices corresponding to each chromosome.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=30, l=1_000, sparsity=0.3, verbose=false);

julia&gt; chroms_uniq, LDs_all_chroms = estimateld(genomes);

julia&gt; chrom, pos, allele = loci_alleles(genomes);

julia&gt; rm.(readdir()[.!isnothing.(match.(Regex(&quot;jld2&quot;), readdir()))]);

julia&gt; mock_scaffolds = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);

julia&gt; mock_scaffolds_uniq, LDs_mock_scaffolds = estimateld(genomes, chromosomes=mock_scaffolds);

julia&gt; rm.(readdir()[.!isnothing.(match.(Regex(&quot;jld2&quot;), readdir()))]);

julia&gt; length(LDs_all_chroms) == length(chroms_uniq) == length(unique(chrom))
true

julia&gt; length(LDs_mock_scaffolds) == length(mock_scaffolds_uniq) == Int(length(chrom) / 100)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/impute.jl#L132-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.extractphenomes-Tuple{TEBV}"><a class="docstring-binding" href="#GenomicBreedingCore.extractphenomes-Tuple{TEBV}"><code>GenomicBreedingCore.extractphenomes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extractphenomes(tebv::TEBV)::Phenomes</code></pre><p>Extract phenotypic values from a Trial-Estimated Breeding Value (TEBV) object.</p><p>This function processes phenotypic data from a TEBV object, handling intercept effects and merging multiple phenomes if present. It performs the following operations:</p><ol><li>Validates input TEBV dimensions</li><li>Processes intercept effects if present by:<ul><li>Identifying intercept terms</li><li>Combining intercept values with trait effects</li><li>Adjusting trait names and phenotypic values accordingly</li></ul></li><li>Merges multiple phenomes if present</li><li>Renames traits to match input TEBV traits if dimensions align</li><li>Validates output Phenomes dimensions</li></ol><p><strong>Arguments</strong></p><ul><li><code>tebv::TEBV</code>: A Trial Estimated Breeding Value object containing phenotypic data</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A Phenomes object containing processed phenotypic values</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input TEBV or output Phenomes dimensions are invalid</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);

julia&gt; tebv = analyse(trials, max_levels=50, verbose=false);

julia&gt; phenomes = extractphenomes(tebv);

julia&gt; phenomes.traits == [&quot;trait_1&quot;, &quot;trait_2&quot;, &quot;trait_3&quot;]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/tebv.jl#L244-L281">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.extractphenomes-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.extractphenomes-Tuple{Trials}"><code>GenomicBreedingCore.extractphenomes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extractphenomes(trials::Trials)::Phenomes</code></pre><p>Convert a <code>Trials</code> struct into a <code>Phenomes</code> struct by extracting phenotypic values across different environments.</p><p><strong>Details</strong></p><ul><li>Combines trait measurements with their environmental contexts</li><li>Creates unique trait identifiers by combining trait names with environment variables</li><li>Environment variables include: years, harvests, seasons, sites, and replications</li><li>For single environment scenarios, trait names remain without environmental suffixes</li></ul><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A Trials struct containing phenotypic measurements across different environments</li></ul><p><strong>Returns</strong></p><ul><li>A Phenomes struct containing:<ul><li><code>phenotypes</code>: Matrix of phenotypic values (entries × traits)</li><li><code>entries</code>: Vector of entry names</li><li><code>populations</code>: Vector of population names</li><li><code>traits</code>: Vector of trait names (with environmental contexts)</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If duplicate entries exist within year-harvest-season-site-replication combinations</li><li><code>ErrorException</code>: If dimensional validation fails during Phenomes construction</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; phenomes = extractphenomes(trials);

julia&gt; size(phenomes.phenotypes)
(100, 384)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L320-L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.filterbymaf-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.filterbymaf-Tuple{Genomes}"><code>GenomicBreedingCore.filterbymaf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filterbymaf(
    genomes::Genomes;
    maf::Float64 = 0.01,
    verbose::Bool = false,
)::Genomes</code></pre><p>Filter genomic data by removing loci with minor allele frequencies (MAF) below a specified threshold.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A <code>Genomes</code> struct containing the genomic data.</li><li><code>maf::Float64</code>: The minimum allele frequency threshold. Default is 0.01.</li><li><code>verbose::Bool</code>: If <code>true</code>, prints detailed progress information during the filtering process. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A <code>Genomes</code> struct with filtered genomic data.</li></ul><p><strong>Details</strong></p><p>This function filters genomic data by removing loci with minor allele frequencies (MAF) below a specified threshold. The function performs the following steps:</p><ol><li><strong>Input Validation</strong>: Ensures that the <code>Genomes</code> struct is not corrupted and that the <code>maf</code> argument is within the valid range (0.0 to 1.0). Throws an <code>ArgumentError</code> if any argument is out of range.</li><li><strong>Early Return for maf = 0.0</strong>: If <code>maf</code> is set to 0.0, the function returns the original <code>Genomes</code> struct without filtering.</li><li><strong>Calculate MAF</strong>: Computes the mean allele frequency for each locus, skipping missing values.</li><li><strong>Filter Loci</strong>: Identifies loci that pass the MAF threshold and retains only those loci:<ul><li>If all loci pass the MAF threshold, the function returns the original <code>Genomes</code> struct.</li><li>If no loci pass the MAF threshold, the function throws an <code>ErrorException</code>.</li></ul></li><li><strong>Verbose Output</strong>: If <code>verbose</code> is <code>true</code>, prints detailed progress information during the filtering process.</li><li><strong>Output</strong>: Returns the filtered <code>Genomes</code> struct.</li></ol><p><strong>Notes</strong></p><ul><li>The function uses multi-threading to compute the mean allele frequencies for each locus, improving performance on large datasets.</li><li>The <code>verbose</code> option provides additional insights into the filtering process by printing progress information.</li><li>The function ensures that the filtered genomic data retains a minimum number of loci.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the <code>Genomes</code> struct is corrupted.</li><li><code>ArgumentError</code>: If the <code>maf</code> argument is out of range.</li><li><code>ErrorException</code>: If all loci are filtered out based on the MAF threshold.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; filtered_genomes = filterbymaf(genomes, maf=0.05);

julia&gt; length(genomes.loci_alleles) &gt;= length(filtered_genomes.loci_alleles)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L508-L556">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.filterbymaxnalleles-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.filterbymaxnalleles-Tuple{Genomes}"><code>GenomicBreedingCore.filterbymaxnalleles</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filterbymaxnalleles(genomes::Genomes; max_n_alleles::Int64 = Inf, verbose::Bool = false) -&gt; Genomes</code></pre><p>Filter loci in a <code>Genomes</code> object by the maximum allowed number of alleles per locus.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Input <code>Genomes</code> struct to be filtered. The function expects <code>genomes.loci_alleles</code> to be a tab-separated string (one entry per locus) where each locus&#39;s alleles are represented as a single string with alleles separated by <code>&quot;|&quot;</code>.</li><li><code>max_n_alleles::Int64 = Inf</code>: Maximum number of alleles permitted at a locus. Loci with more than this number of alleles are removed. If <code>max_n_alleles</code> is <code>Inf</code> (the default) no filtering is performed.</li><li><code>verbose::Bool = false</code>: If <code>true</code>, prints informational messages about early returns or filtering actions.</li></ul><p><strong>Returns</strong></p><ul><li>A new <code>Genomes</code> object containing only the loci that have at most <code>max_n_alleles</code> alleles. The returned object is produced by calling <code>slice</code> with the indices of loci that pass the threshold.</li></ul><p><strong>Details</strong></p><ul><li>Validates the input <code>genomes</code> with <code>checkdims</code>; throws <code>ArgumentError</code> if the struct is invalid.</li><li>Throws <code>ArgumentError</code> if <code>max_n_alleles &lt; 1</code>.</li><li>If <code>max_n_alleles</code> is <code>Inf</code>, the original <code>genomes</code> is returned unchanged.</li><li>The function determines allele counts by splitting <code>genomes.loci_alleles</code> on <code>&#39;	&#39;</code> into per-locus entries, then splitting each locus entry on <code>&quot;|&quot;</code> and counting elements. Loci with count ≤ <code>max_n_alleles</code> are retained.</li><li>If no loci remain after filtering, an <code>ErrorException</code> is thrown indicating that all loci were filtered out.</li><li>This function relies on the specific format of <code>genomes.loci_alleles</code> (tab-separated loci and pipe-separated alleles). Ensure that field conforms to this format before calling.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the <code>Genomes</code> struct is corrupted.</li><li><code>ArgumentError</code>: If the <code>max_n_alleles</code> argument is out of range.</li><li><code>ErrorException</code>: If all loci are filtered out based on the <code>max_n_alleles</code> threshold.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; filtered_genomes = filterbymaxnalleles(genomes, max_n_alleles=4);

julia&gt; length(genomes.loci_alleles) == length(filtered_genomes.loci_alleles)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L597-L632">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.filterbypca-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.filterbypca-Tuple{Genomes}"><code>GenomicBreedingCore.filterbypca</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filterbypca(
    genomes::Genomes;
    max_prop_pc_varexp::Float64 = 0.9,
    verbose::Bool = false,
)::Genomes</code></pre><p>Filter genomic data by removing outlier loci-alleles based on principal component analysis (PCA).</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A <code>Genomes</code> struct containing the genomic data.</li><li><code>max_prop_pc_varexp::Float64</code>: The maximum proportion of variance explained by the first two principal components (PC1 and PC2). Default is 0.9.</li><li><code>verbose::Bool</code>: If <code>true</code>, prints detailed progress information during the filtering process. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A <code>Genomes</code> struct with filtered genomic data.</li></ul><p><strong>Details</strong></p><p>This function filters genomic data by removing outlier loci-alleles based on principal component analysis (PCA). The function performs the following steps:</p><ol><li><strong>Input Validation</strong>: Ensures that the <code>Genomes</code> struct is not corrupted and that the <code>max_prop_pc_varexp</code> argument is within the valid range (0.0 to Inf). Throws an <code>ArgumentError</code> if any argument is out of range.</li><li><strong>Early Return for max<em>prop</em>pc_varexp = Inf</strong>: If <code>max_prop_pc_varexp</code> is set to Inf, the function returns the original <code>Genomes</code> struct without filtering.</li><li><strong>Extract Non-Missing Loci-Alleles</strong>: Identifies loci-alleles that are non-missing and have non-zero variance across all entries.</li><li><strong>Standardize Allele Frequencies</strong>: Standardizes the allele frequencies per locus-allele in preparation for PCA.</li><li><strong>Perform PCA</strong>: Conducts PCA on the standardized allele frequencies and calculates the proportion of variance explained by the first two principal components (PC1 and PC2).</li><li><strong>Identify Outliers</strong>: Identifies loci-alleles that are outliers based on the specified proportion of variance explained by PC1 and PC2.</li><li><strong>Filter Outliers</strong>: Removes the identified outlier loci-alleles from the genomic data.</li><li><strong>Verbose Output</strong>: If <code>verbose</code> is <code>true</code>, prints detailed progress information during the filtering process.</li><li><strong>Output</strong>: Returns the filtered <code>Genomes</code> struct.</li></ol><p><strong>Notes</strong></p><ul><li>The function uses PCA to identify outlier loci-alleles based on the proportion of variance explained by the first two principal components.</li><li>The <code>verbose</code> option provides additional insights into the filtering process by printing progress information.</li><li>The function ensures that the filtered genomic data retains a minimum number of loci-alleles.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the <code>Genomes</code> struct is corrupted.</li><li><code>ArgumentError</code>: If the <code>max_prop_pc_varexp</code> argument is out of range.</li><li><code>ErrorException</code>: If there are less than 10 loci-alleles left after removing fixed and missing values across all entries.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; filtered_genomes = filterbypca(genomes, max_prop_pc_varexp=0.9);

julia&gt; length(filtered_genomes.loci_alleles) &lt;= length(genomes.loci_alleles)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L670-L719">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.filterbysnplist-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.filterbysnplist-Tuple{Genomes}"><code>GenomicBreedingCore.filterbysnplist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filterbysnplist(
    genomes::Genomes;
    chr_pos_allele_ids::Union{Nothing,Vector{String}} = nothing,
    match_alleles::Bool = true,
    verbose::Bool = false,
)::Genomes</code></pre><p>Filter genomic data by retaining only the specified loci or loci-allele combinations.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A <code>Genomes</code> struct containing the genomic data.</li><li><code>chr_pos_allele_ids::Union{Nothing, Vector{String}}</code>: A vector of loci or loci-allele combination names in the format &quot;chromosome\tposition&quot; or &quot;chromosome\tposition\tallele&quot;. If <code>nothing</code>, no filtering is applied. Default is <code>nothing</code>.</li><li><code>match_alleles::Bool</code>: If <code>true</code>, matches both loci coordinates (chromosome and position) and alleles. If <code>false</code>, matches only by chromosome and position regardless of alleles. Default is <code>true</code>.</li><li><code>verbose::Bool</code>: If <code>true</code>, prints detailed progress information during the filtering process. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A <code>Genomes</code> struct with filtered genomic data.</li></ul><p><strong>Details</strong></p><p>This function filters genomic data by retaining only the specified loci or loci-allele combinations. The function performs the following steps:</p><ol><li><strong>Input Validation</strong>: Ensures that the <code>Genomes</code> struct is not corrupted.</li><li><strong>Early Return for No Filtering</strong>: If no IDs are provided, returns the original <code>Genomes</code> struct.</li><li><strong>Parse Input IDs</strong>: Parses the input IDs and validates their format.</li><li><strong>Extract Available IDs</strong>: Gets the current loci or loci-allele combinations from the <code>Genomes</code> struct.</li><li><strong>Filter Data</strong>: Identifies and retains only the specified combinations.</li><li><strong>Verbose Output</strong>: If enabled, prints detailed progress information.</li><li><strong>Final Check</strong>: Ensures that filtering retains at least some data.</li></ol><p><strong>Notes</strong></p><ul><li>Uses multi-threading for parsing and filtering operations</li><li>When <code>match_alleles=false</code>, matches only chromosome and position</li><li>Preserves the original data structure while filtering unwanted entries</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the <code>Genomes</code> struct is corrupted or input IDs are malformed</li><li><code>ErrorException</code>: If no data remains after filtering</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; chr_pos_allele_ids = sample(genomes.loci_alleles, 100, replace=false); sort!(chr_pos_allele_ids);

julia&gt; filtered_genomes = filterbysnplist(genomes, chr_pos_allele_ids=chr_pos_allele_ids);

julia&gt; size(filtered_genomes.allele_frequencies)
(100, 100)

julia&gt; chr_pos_allele_ids_no_alleles = unique([join(split(x, &quot;	&quot;)[1:2], &quot;	&quot;) for x in chr_pos_allele_ids]);

julia&gt; filtered_genomes_2 = filterbysnplist(genomes, chr_pos_allele_ids=chr_pos_allele_ids_no_alleles, match_alleles=false);

julia&gt; size(filtered_genomes_2.allele_frequencies, 2) &gt; size(filtered_genomes.allele_frequencies, 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L802-L859">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.filterbysparsity-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.filterbysparsity-Tuple{Genomes}"><code>GenomicBreedingCore.filterbysparsity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filterbysparsity(
    genomes::Genomes;
    max_entry_sparsity::Float64 = 0.0,
    max_locus_sparsity::Float64 = 0.0,
    max_entry_sparsity_percentile::Float64 = 0.90,
    max_locus_sparsity_percentile::Float64 = 0.50,
    verbose::Bool = false,
)::Genomes</code></pre><p>Filter genomic data by removing entries and loci with high sparsity.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A <code>Genomes</code> struct containing the genomic data.</li><li><code>max_entry_sparsity::Float64</code>: The maximum allowable sparsity for entries. Default is 0.0.</li><li><code>max_locus_sparsity::Float64</code>: The maximum allowable sparsity for loci. Default is 0.0.</li><li><code>max_entry_sparsity_percentile::Float64</code>: The percentile threshold for entry sparsity used in iteratively filtering out the sparsest entries. Default is 0.90.</li><li><code>max_locus_sparsity_percentile::Float64</code>: The percentile threshold for locus sparsity used in iteratively filtering out sparsest loci. Default is 0.50.</li><li><code>max_iter::Int64</code>: The maximum number of iterations to perform during filtering. Default is 10.</li><li><code>verbose::Bool</code>: If <code>true</code>, prints detailed progress information during the filtering process. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A <code>Genomes</code> struct with filtered genomic data.</li></ul><p><strong>Details</strong></p><p>This function filters genomic data by iteratively removing entries and loci with high sparsity. The function performs the following steps:</p><ol><li><strong>Input Validation</strong>: Ensures that the <code>Genomes</code> struct is not corrupted and that the sparsity thresholds are within the valid range (0.0 to 1.0). Throws an <code>ArgumentError</code> if any argument is out of range.</li><li><strong>Calculate Sparsities</strong>: Computes the sparsities of entries and loci in the genomic data.</li><li><strong>Initial Check</strong>: Checks if the input <code>Genomes</code> struct passes all the filtering thresholds. If so, returns the original <code>Genomes</code> struct.</li><li><strong>Iterative Filtering</strong>: Iteratively removes the sparsest loci and entries until the maximum allowable sparsity thresholds are met:<ul><li><strong>Remove Sparsest Loci</strong>: Removes loci with sparsity above the specified percentile threshold or maximum loci sparsity, whichever is higher.</li><li><strong>Remove Sparsest Entries</strong>: Removes entries with sparsity above the specified percentile threshold or maximum entries sparsity, whichever is higher.</li><li><strong>Check for Convergence</strong>: If the maximum sparsity levels are not improving, the function may terminate early to avoid infinite loops.</li></ul></li><li><strong>Verbose Output</strong>: If <code>verbose</code> is <code>true</code>, prints detailed progress information during each iteration.</li><li><strong>Final Check</strong>: Ensures that there are remaining entries and loci after filtering. Throws an <code>ErrorException</code> if all entries or loci are filtered out.</li><li><strong>Output</strong>: Returns the filtered <code>Genomes</code> struct.</li></ol><p><strong>Notes</strong></p><ul><li>The function uses percentile thresholds to iteratively remove the sparsest loci and entries.</li><li>The <code>verbose</code> option provides additional insights into the filtering process by printing progress information.</li><li>The function ensures that the filtered genomic data retains a minimum number of entries and loci.</li><li>If one of <code>max_entry_sparsity</code> or <code>max_locus_sparsity</code> is set to 1.00, the other threshold may not be met because</li></ul><p>filtering out entries/loci further will mean filtering the other but the requirement at 100% maximum sparsity is already met.  At instances like this, you may manually reduced the maximum sparsity level from 1.00.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the <code>Genomes</code> struct is corrupted.</li><li><code>ArgumentError</code>: If any of the sparsity thresholds are out of range.</li><li><code>ErrorException</code>: If all entries and/or loci are filtered out based on the sparsity thresholds.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, sparsity=0.02, verbose=false);

julia&gt; filtered_genomes = filterbysparsity(genomes);

julia&gt; size(genomes.allele_frequencies)
(100, 3000)

julia&gt; size(filtered_genomes.allele_frequencies)
(73, 785)

julia&gt; entry_sparsities, locus_sparsities = sparsities(filtered_genomes);

julia&gt; maximum(entry_sparsities) == maximum(locus_sparsities) == 0.0
true

julia&gt; filtered_genomes_2 = filterbysparsity(genomes, max_entry_sparsity=0.05, max_locus_sparsity=0.05);

julia&gt; prod(size(filtered_genomes_2.allele_frequencies)) &gt; prod(size(filtered_genomes.allele_frequencies))
true

julia&gt; entry_sparsities, locus_sparsities = sparsities(filtered_genomes_2);

julia&gt; (maximum(entry_sparsities) &lt;= 0.05) &amp;&amp; (maximum(locus_sparsities) &lt;= 0.05)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L208-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.grmploidyaware-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.grmploidyaware-Tuple{Genomes}"><code>GenomicBreedingCore.grmploidyaware</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grmploidyaware(
    genomes::Genomes;
    ploidy::Int64 = 2,
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    verbose::Bool = false
)::Matrix{Float64}</code></pre><p>Generate a ploidy-aware genetic relationship matrix (GRM) based on the methods described in  Bell et al. (2017) and VanRaden et al. (2008).</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>ploidy::Int64</code>: Number of chromosome copies in the organism (default: 2)</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific entries (default: nothing)</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific loci/alleles (default: nothing)</li><li><code>verbose::Bool</code>: If true, displays a heatmap of the resulting GRM (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A symmetric genetic relationship matrix with dimensions (n × n), where n is the number of entries</li></ul><p><strong>Details</strong></p><p>The function implements the following steps:</p><ol><li>Extracts and processes genomic data</li><li>Calculates allele frequencies and centers the data</li><li>Computes the GRM using VanRaden&#39;s method</li><li>Ensures matrix invertibility by adding small values to the diagonal if necessary</li></ol><p><strong>Note</strong></p><p>The diagonal elements may be slightly inflated to ensure matrix invertibility for downstream analyses.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(l=1_000, verbose=false);

julia&gt; grm = grmploidyaware(genomes);

julia&gt; size(grm.genomic_relationship_matrix), issymmetric(grm.genomic_relationship_matrix)
((100, 100), true)

julia&gt; det(grm.genomic_relationship_matrix) &gt; eps(Float64)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/grm/calc.jl#L144-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.grmsimple-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.grmsimple-Tuple{Genomes}"><code>GenomicBreedingCore.grmsimple</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">grmsimple(
    genomes::Genomes;
    idx_entries::Union{Nothing,Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,
    verbose::Bool = false
)::Matrix{Float64}</code></pre><p>Generate a simple genetic relationship matrix (GRM) from genomic data.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genomic data structure containing allele frequencies</li><li><code>idx_entries::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific entries/individuals</li><li><code>idx_loci_alleles::Union{Nothing,Vector{Int64}}</code>: Optional indices to select specific loci/alleles</li><li><code>verbose::Bool</code>: If true, displays a heatmap visualization of the GRM</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A symmetric positive definite genetic relationship matrix</li></ul><p><strong>Details</strong></p><p>The function computes a genetic relationship matrix by:</p><ol><li>Converting genomic data to a numerical matrix</li><li>Computing GRM as G * G&#39; / ncol(G)</li><li>Adding small positive values to diagonal elements if necessary to ensure matrix invertibility</li></ol><p><strong>Notes</strong></p><ul><li>The resulting matrix is always symmetric</li><li>Diagonal elements may be slightly inflated to ensure matrix invertibility</li><li>The matrix dimensions will be n×n where n is the number of entries/individuals</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(l=1_000, verbose=false);

julia&gt; grm = grmsimple(genomes);

julia&gt; size(grm.genomic_relationship_matrix), issymmetric(grm.genomic_relationship_matrix)
((100, 100), true)

julia&gt; det(grm.genomic_relationship_matrix) &gt; eps(Float64)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/grm/calc.jl#L72-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.histallelefreqs-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.histallelefreqs-Tuple{Genomes}"><code>GenomicBreedingCore.histallelefreqs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">histallelefreqs(genomes::Genomes)::Nothing</code></pre><p>Plot a histogram of allele frequencies from a Genomes object.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes object containing allele frequency data in its <code>allele_frequencies</code> field</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: Displays a histogram plot and returns nothing</li></ul><p><strong>Description</strong></p><p>Creates and displays a vertical histogram of non-missing allele frequencies using UnicodePlots. The histogram shows frequency distribution in the range [0,1] with 50 bins.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; genomes = simulategenomes(n=100, l=10_000, n_alleles=3, n_populations=3, verbose=false);

julia&gt; histallelefreqs(genomes)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_mating.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.impute-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.impute-Tuple{Genomes}"><code>GenomicBreedingCore.impute</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">impute(
    genomes::Genomes;
    max_n_loci_per_chrom::Int64 = 100_000,
    n_reps::Int64 = 2,
    optim_n::Int64 = 10,
    min_l_loci::Int64 = 10,
    min_k_entries::Int64 = 2,
    verbose::Bool = false,
)::Tuple{Genomes, Float64}</code></pre><p>Impute missing allele frequencies in a genomic dataset using optimised allele frequency k-nearest neighbours imputation (AF-kNNi).</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A <code>Genomes</code> struct containing the genomic data.</li><li><code>max_n_loci_per_chrom::Int64</code>: The maximum number of loci per chromosome. Default is 100,000.</li><li><code>n_reps::Int64</code>: The number of repetitions for cross-validation during optimisation. Default is 2.</li><li><code>optim_n::Int64</code>: The number of optimisation steps for each parameter. Default is 10.</li><li><code>min_l_loci::Int64</code>: The minimum number of loci required to be linked to the focal locus. Default is 10.</li><li><code>min_k_entries::Int64</code>: The minimum number of nearest neighbours required for imputation. Default is 2.</li><li><code>verbose::Bool</code>: If <code>true</code>, prints detailed progress information. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Genomes, Float64}</code>: A tuple containing:<ul><li>An updated <code>Genomes</code> struct with imputed allele frequencies.</li><li>The mean absolute error (MAE) of the imputed values.</li></ul></li></ul><p><strong>Details</strong></p><p>This function imputes missing allele frequencies in a genomic dataset using an optimised k-nearest neighbors (KNN) imputation method. The function performs the following steps:</p><ul><li>Input Validation: Checks the validity of the input arguments, ensuring the Genomes struct is not corrupted, the number of entries and loci are within valid ranges, and the parameters are correctly specified.</li><li>Chromosome Division: Divides the allele frequencies into mock scaffolds if the number of loci per chromosome exceeds the specified maximum.</li><li>Linkage Disequilibrium (LD) Estimation: Estimates LD between loci using Pearson&#39;s correlation for each chromosome.</li><li>Imputation Process: For each locus-allele per chromosome:<ul><li>Identifies entries with missing data.</li><li>Optimises the parameters min<em>loci</em>corr and max<em>entries</em>dist using cross-validation.</li><li>Computes distances between entries using the optimised min<em>loci</em>corr.</li><li>Imputes missing data using the weighted means of the nearest neighbors based on the optimised max<em>entries</em>dist.</li></ul></li><li>Output: Returns the updated Genomes struct with imputed allele frequencies and the mean absolute error (MAE) of the imputed values.</li></ul><p><strong>Notes</strong></p><ul><li>The function is designed to handle the following cases:<ul><li>If all loci have undetermined level of linkage with the focal locus (i.e. -Inf values in the LD matrix), then all the loci-alleles are selected to estimate distances.</li><li>If the number of linked loci is below the specified minimum, then the minimum number of loci most correlated to the focal locus are selected to estimate distances.</li><li>If the number of nearest neighbours is less than the specified minimum, then then the minimum number of closest neighbours are used in to compute the weighted average allele frequency.</li></ul></li><li>The verbose option provides additional insights into the imputation process by printing progress information.</li><li>The function is designed to handle large genomic datasets efficiently by dividing loci into mock scaffolds if necessary.</li></ul><p><strong>Throws</strong></p><ul><li>ArgumentError: If the Genomes struct is corrupted.</li><li>ArgumentError: If the number of entries in the Genomes struct is less than 2.</li><li>ArgumentError: If the number of loci per chromosome is less than 10.</li><li>ArgumentError: If n_reps is not between 1 and the number of entries.</li><li>ArgumentError: If min<em>l</em>loci is not between 10 and the number of loci per chromosome.</li><li>ArgumentError: If min<em>k</em>entries is not between 2 and the number of entries.</li><li>ErrorException: If an error occurs during the imputation process.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, sparsity=0.3, verbose=false);

julia&gt; genomes_imputed, mae = impute(genomes);

julia&gt; dimensions(genomes)[&quot;n_missing&quot;] == 30_000
true

julia&gt; dimensions(genomes_imputed)[&quot;n_missing&quot;] == 0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/impute.jl#L689-L757">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.inflatediagonals!-Tuple{Matrix{Float64}}"><a class="docstring-binding" href="#GenomicBreedingCore.inflatediagonals!-Tuple{Matrix{Float64}}"><code>GenomicBreedingCore.inflatediagonals!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inflatediagonals!(X::Matrix{Float64}; max_iter::Int64=1_000, verbose::Bool=false)::Nothing</code></pre><p>Ensure matrix invertibility by iteratively inflating diagonal elements until both the determinant is nonzero and the matrix is positive definite.</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: Input square symmetric matrix to be modified in-place</li><li><code>max_iter::Int64=1_000</code>: Maximum number of iterations</li><li><code>verbose::Bool=false</code>: If true, prints information about the inflation process</li></ul><p><strong>Details</strong></p><p>The function adds progressively larger values to the diagonal elements until the matrix becomes invertible (det(X) &gt; eps(Float64)) and positive definite, or the maximum number  of iterations is reached. The initial inflation value ϵ is set to the maximum absolute  value in the matrix and increases slightly in each iteration by a factor of (1 + eps(Float64)).</p><p>The function returns early if the matrix is already positive definite and has a nonzero determinant.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the input matrix is not symmetric</li><li><code>ArgumentError</code>: If the input matrix is not square</li><li><code>ArgumentError</code>: If the input matrix contains NaN values</li><li><code>ArgumentError</code>: If the input matrix contains Inf values</li></ul><p><strong>Returns</strong></p><p><code>Nothing</code>. The input matrix <code>X</code> is modified in-place.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x::Vector{Float64} = rand(10);

julia&gt; X::Matrix{Float64} = x * x&#39;;

julia&gt; inflatediagonals!(X);

julia&gt; det(X) &gt; eps(Float64)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/grm/calc.jl#L1-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.knni-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.knni-Tuple{}"><code>GenomicBreedingCore.knni</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">knni(; qs::Vector{Float64}, d::Vector{Float64}, max_entries_dist::Float64 = 0.1, min_k_entries::Int64 = 2)::Float64</code></pre><p>Impute missing allele frequencies using the k-nearest neighbours (kNN) method based on distances.</p><p><strong>Arguments</strong></p><ul><li><code>qs::Vector{Float64}</code>: A vector of non-missing allele frequencies at the focal locus.</li><li><code>d::Vector{Float64}</code>: A vector of distances corresponding to the entries in <code>qs</code>.</li><li><code>max_entries_dist::Float64</code>: The maximum distance threshold to consider an entry as a neighbour. Default is 0.1.</li><li><code>min_k_entries::Int64</code>: The minimum number of nearest neighbours required for imputation. Default is 2.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The imputed allele frequency at the focal locus.</li></ul><p><strong>Details</strong></p><p>This function imputes missing allele frequencies at a focal locus using the k-nearest neighbours (KNN) method. The function performs the following steps:</p><ul><li>Input Validation: Ensures that the lengths of qs and d are equal. Throws an ArgumentError if they are not.</li><li>Identify Nearest Neighbors: Finds the indices of the nearest neighbours within the specified distance threshold (max<em>entries</em>dist). If the number of neighbours is less than the minimum required (min<em>k</em>entries), the nearest neighbours are selected based on the smallest distances.</li><li>Impute Missing Data: Calculates the weighted mean of the allele frequencies of the nearest neighbours. The weights are based on the inverse of the distances to the focal locus, ensuring that closer neighbours have a higher influence on the imputed value.</li><li>Output: Returns the imputed allele frequency.</li></ul><p><strong>Notes</strong></p><ul><li>The function uses a small epsilon value (eps(Float64)) to avoid division by zero when calculating weights.</li><li>If the sum of distances is infinite, a uniform weight is assigned to each neighbour.</li><li>The function is designed to handle cases where the number of nearest neighbours is less than the specified minimum by selecting the closest available neighbours.</li></ul><p><strong>Throws</strong></p><ul><li>ArgumentError: If the lengths of qs and d are not equal.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=50, l=1_000, sparsity=0.3, verbose=false);

julia&gt; chromosomes = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);

julia&gt; chroms_uniq, LDs = estimateld(genomes, chromosomes=chromosomes);

julia&gt; rm.(readdir()[.!isnothing.(match.(Regex(&quot;jld2&quot;), readdir()))]);

julia&gt; k = 1; LD = LDs[k]; chrom = chroms_uniq[k]; idx_focal_locus = 1;

julia&gt; idx_loci_alleles_per_chrom = findall(chromosomes .== chrom);

julia&gt; min_loci_corr = 0.9; min_l_loci = 2;

julia&gt; D = estimatedistances(genomes, LD=LD, idx_focal_locus=idx_focal_locus, idx_loci_alleles_per_chrom=idx_loci_alleles_per_chrom, min_loci_corr=min_loci_corr, min_l_loci=min_l_loci);

julia&gt; i = findall(ismissing.(genomes.allele_frequencies[:, idx_focal_locus]))[1];

julia&gt; idx_entries_not_missing = findall(.!ismissing.(genomes.allele_frequencies[:, idx_focal_locus]));

julia&gt; qs::Vector{Float64} = genomes.allele_frequencies[idx_entries_not_missing, idx_focal_locus];

julia&gt; d = D[i, idx_entries_not_missing];

julia&gt; q̄ = knni(qs=qs, d=d, max_entries_dist=0.25, min_k_entries=2);

julia&gt; q̄ &gt; 0.0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/impute.jl#L428-L488">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.knnioptim-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.knnioptim-Tuple{Genomes}"><code>GenomicBreedingCore.knnioptim</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">knnioptim(
    genomes::Genomes;
    j::Int64,
    idx_focal_locus::Int64,
    idx_loci_alleles_per_chrom::Vector{Int64},
    idx_entries_not_missing::Vector{Int64},
    LD::Matrix{Float64},
    n_reps::Int64 = 2,
    optim_n::Int64 = 10,
    min_l_loci::Int64 = 10,
    min_k_entries::Int64 = 2,
    verbose::Bool = false,
)::Dict{String,Float64}</code></pre><p>Optimise parameters for allele frequency k-nearest neighbours imputation (AF-kNNi) using cross-validation, i.e. the  minimum loci correlation (<code>min_loci_corr</code>) and maximum entries distance (<code>max_entries_dist</code>).</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A <code>Genomes</code> struct containing the genomic data.</li><li><code>j::Int64</code>: The global index of the locus for which imputation is performed, i.e. index corresponding to the whole <code>genomes.allele_frequencies</code> matrix.</li><li><code>idx_focal_locus::Int64</code>: The local index of the focal locus, i.e. index at the current chromosome or mock scaffold.</li><li><code>idx_loci_alleles_per_chrom::Vector{Int64}</code>: A vector of global indices for loci-alleles per chromosome, i.e. indices corresponding the whole <code>genomes.allele_frequencies</code> matrix.</li><li><code>idx_entries_not_missing::Vector{Int64}</code>: A vector of indices for entries with non-missing data at the focal locus.</li><li><code>LD::Matrix{Float64}</code>: A linkage disequilibrium (LD) matrix.</li><li><code>n_reps::Int64</code>: The number of repetitions for cross-validation. Default is 2.</li><li><code>optim_n::Int64</code>: The number of optimisation steps for each parameter. Default is 10.</li><li><code>min_l_loci::Int64</code>: The minimum number of loci required to be linked to the focal locus. Default is 10.</li><li><code>min_k_entries::Int64</code>: The minimum number of nearest neighbours required for imputation. Default is 2.</li><li><code>verbose::Bool</code>: If <code>true</code>, prints detailed progress information and plots the mean absolute error (MAE) heatmap. Default is <code>false</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String, Float64}</code>: A dictionary containing the optimised parameters:<ul><li><code>&quot;min_loci_corr&quot;</code>: The optimised minimum correlation threshold for loci to be considered linked.</li><li><code>&quot;max_entries_dist&quot;</code>: The optimised maximum distance threshold to consider an entry as a neighbor.</li><li><code>&quot;mae&quot;</code>: The mean absolute error (MAE) of the optimised parameters.</li></ul></li></ul><p><strong>Details</strong></p><p>This function optimises the minimum loci correlation (<code>min_loci_corr</code>) and maximum entries distance (<code>max_entries_dist</code>) for allele frequency k-nearest neighbours imputation (AF-kNNi) using cross-validation. The function performs the following steps:</p><ul><li>Input Validation: Ensures that there are at least 2 entries with non-missing data at the focal locus. Throws an ArgumentError if this condition is not met.</li><li>Parameter Ranges: Defines the ranges for the minimum correlation threshold (<code>min_loci_corr</code>) and the maximum distance threshold (max<em>entries</em>dist) for optimisation.</li><li>Cross-Validation: For each combination of <code>min_loci_corr</code> and <code>max_entries_dist</code>, the function:<ul><li>Estimates pairwise distances between entries using the <code>estimatedistances</code> function.</li><li>Samples entries with non-missing data to simulate missing data.</li><li>Performs AF-kNNi using the <code>knni</code> function and calculates the mean absolute error (MAE) for the imputed values.</li></ul></li><li>Optimisation: Identifies the combination of parameters that minimises the MAE.</li><li>Output: Returns a dictionary containing the optimised parameters and the corresponding MAE. If verbose is true, prints detailed progress information and plots a heatmap of the MAE.</li></ul><p><strong>Notes</strong></p><ul><li>The function is designed to handle the following cases:<ul><li>If all loci have undetermined level of linkage with the focal locus (i.e. -Inf values in the LD matrix), then all the loci-alleles are selected to estimate distances.</li><li>If the number of linked loci is below the specified minimum, then the minimum number of loci most correlated to the focal locus are selected to estimate distances.</li><li>If the number of nearest neighbours is less than the specified minimum, then then the minimum number of closest neighbours are used in to compute the weighted average allele frequency.</li></ul></li><li>The verbose option provides additional insights into the optimisation process by printing the parameters and plotting the MAE heatmap.</li></ul><p><strong>Throws</strong></p><ul><li>ArgumentError: If there are less than 2 entries with non-missing data at the focal locus. </li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=123, l=1_000, sparsity=0.3, rel_dist_multiplier=10.0, verbose=false);

julia&gt; chromosomes = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);

julia&gt; chroms_uniq, LDs = estimateld(genomes, chromosomes=chromosomes);

julia&gt; rm.(readdir()[.!isnothing.(match.(Regex(&quot;jld2&quot;), readdir()))]);

julia&gt; k = 1; LD = LDs[k]; chrom = chroms_uniq[k]; j = idx_focal_locus = 1;

julia&gt; idx_loci_alleles_per_chrom = findall(chromosomes .== chrom);

julia&gt; min_loci_corr = 0.9; min_l_loci = 2;

julia&gt; D = estimatedistances(genomes, LD=LD, idx_focal_locus=idx_focal_locus, idx_loci_alleles_per_chrom=idx_loci_alleles_per_chrom, min_loci_corr=min_loci_corr, min_l_loci=min_l_loci);

julia&gt; i = findall(ismissing.(genomes.allele_frequencies[:, idx_focal_locus]))[1];

julia&gt; idx_entries_not_missing = findall(.!ismissing.(genomes.allele_frequencies[:, idx_focal_locus]));

julia&gt; params = knnioptim(genomes, j=j, idx_focal_locus=idx_focal_locus, idx_loci_alleles_per_chrom=idx_loci_alleles_per_chrom, idx_entries_not_missing=idx_entries_not_missing, LD=LD);

julia&gt; params[&quot;min_loci_corr&quot;] &gt; 0.5
true

julia&gt; params[&quot;max_entries_dist&quot;] &lt; 0.5
true

julia&gt; params[&quot;mae&quot;] &lt; 0.1
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/impute.jl#L525-L616">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.loci-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.loci-Tuple{Genomes}"><code>GenomicBreedingCore.loci</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loci(genomes::Genomes; verbose::Bool = false)::Tuple{Vector{String},Vector{Int64},Vector{Int64},Vector{Int64}}</code></pre><p>Extract genomic positional information from a <code>Genomes</code> object, returning a tuple of vectors containing chromosome names, positions, and locus boundary indices.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes object containing genomic data</li><li><code>verbose::Bool = false</code>: If true, displays a progress bar during computation</li></ul><p><strong>Returns</strong></p><p>A tuple containing four vectors:</p><ul><li><code>chromosomes::Vector{String}</code>: Names of chromosomes</li><li><code>positions::Vector{Int64}</code>: Positions within chromosomes</li><li><code>loci_ini_idx::Vector{Int64}</code>: Starting indices for each locus</li><li><code>loci_fin_idx::Vector{Int64}</code>: Ending indices for each locus</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; chromosomes, positions, loci_ini_idx, loci_fin_idx = loci(genomes);

julia&gt; length(chromosomes), length(positions), length(loci_ini_idx), length(loci_fin_idx)
(1000, 1000, 1000, 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L319-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.loci_alleles-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.loci_alleles-Tuple{Genomes}"><code>GenomicBreedingCore.loci_alleles</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">loci_alleles(genomes::Genomes; verbose::Bool = false)::Tuple{Vector{String},Vector{Int64},Vector{String}}</code></pre><p>Extract chromosomes, positions, and alleles information from a <code>Genomes</code> object.</p><p>Returns a tuple of three vectors containing:</p><ol><li>Chromosomes identifiers as strings</li><li>Base-pair positions as integers</li><li>Allele identifiers as strings</li></ol><p>Each vector has length equal to the total number of loci-allele combinations in the genome. The function processes the data in parallel using multiple threads for performance optimization.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A valid Genomes object containing loci and allele information</li><li><code>verbose::Bool = false</code>: If true, displays a progress bar during extraction</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{String},Vector{Int64},Vector{String}}</code>: A tuple containing three vectors:<ul><li>chromosomes: Vector of chromosome identifiers</li><li>positions: Vector of base-pair positions</li><li>alleles: Vector of allele identifiers</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Genomes struct dimensions are invalid or corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; chromosomes, positions, alleles = loci_alleles(genomes);

julia&gt; length(chromosomes), length(positions), length(alleles)
(3000, 3000, 3000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L255-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.maskmissing!-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.maskmissing!-Tuple{Genomes}"><code>GenomicBreedingCore.maskmissing!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maskmissing!(genomes::Genomes; verbose::Bool = false)</code></pre><p>Update the mask matrix for missing values in the genomes struct.</p><p>This function updates the mask matrix in a <code>Genomes</code> struct by marking positions where allele frequencies are not missing. The mask is set to <code>true</code> for non-missing values and <code>false</code> for missing values.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing genomic data including allele frequencies and mask matrix</li><li><code>verbose::Bool=false</code>: If true, displays a progress bar during computation</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the dimensions in the Genomes struct are inconsistent</li></ul><p><strong>Effects</strong></p><ul><li>Modifies the <code>mask</code> field of the input <code>genomes</code> struct in-place</li></ul><p><strong>Threads</strong></p><ul><li>Uses multi-threading for parallel computation across loci</li><li>Uses a thread lock for safe concurrent access to shared memory</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=10, sparsity=0.3, verbose=false);

julia&gt; round(1.00 - mean(genomes.mask), digits=10)
0.0

julia&gt; maskmissing!(genomes);

julia&gt; round(1.00 - mean(genomes.mask), digits=10)
0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/impute.jl#L1-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.plot"><a class="docstring-binding" href="#GenomicBreedingCore.plot"><code>GenomicBreedingCore.plot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot(fit::Fit, distribution::Any=[TDist(1), Normal()][2], α::Float64=0.05)</code></pre><p>Generate diagnostic plots for genetic association analysis results.</p><p><strong>Arguments</strong></p><ul><li><code>fit::Fit</code>: A Fit object containing the association analysis results, specifically the <code>b_hat</code> field with effect sizes</li><li><code>distribution::Any</code>: The null distribution for p-value calculation. Defaults to Normal distribution</li><li><code>α::Float64</code>: Significance level for multiple testing correction (Bonferroni). Defaults to 0.05</li></ul><p><strong>Returns</strong></p><p>Displays three plots:</p><ul><li>Histogram showing the distribution of effect sizes</li><li>Manhattan plot showing -log10(p-values) across loci with Bonferroni threshold</li><li>Q-Q plot comparing observed vs expected -log10(p-values)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; distribution = [TDist(1), Normal()][2];

julia&gt; fit = Fit(n=100, l=10_000); fit.b_hat = rand(distribution, 10_000);  α = 0.05;

julia&gt; GenomicBreedingCore.plot(fit);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/fit/fit.jl#L172-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.plot"><a class="docstring-binding" href="#GenomicBreedingCore.plot"><code>GenomicBreedingCore.plot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plot(genomes::Genomes, seed::Int64 = 42)::Nothing</code></pre><p>Generate visualization plots for allele frequencies in genomic data.</p><p>For each population in the dataset, creates three plots:</p><ol><li>Histogram of per-entry allele frequencies</li><li>Histogram of mean allele frequencies per locus</li><li>Correlation heatmap of allele frequencies between loci</li></ol><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing allele frequency data</li><li><code>seed::Int64=42</code>: Random seed for reproducibility of sampling loci</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: Displays plots but doesn&#39;t return any value</li></ul><p><strong>Notes</strong></p><ul><li>Uses up to 100 randomly sampled loci for visualization</li><li>Handles missing values in the data</li><li>Displays folded frequency spectra (both q and 1-q)</li><li>Will throw ArgumentError if the Genomes struct is corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; GenomicBreedingCore.plot(genomes)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/genomes.jl#L660-L690">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.plot-Tuple{Phenomes}"><a class="docstring-binding" href="#GenomicBreedingCore.plot-Tuple{Phenomes}"><code>GenomicBreedingCore.plot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot(phenomes::Phenomes; nbins::Int64 = 10)::Nothing</code></pre><p>Generate diagnostic plots for phenotypic data stored in a <code>Phenomes</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing phenotypic data</li><li><code>nbins::Int64=10</code>: Number of bins for the histograms (optional)</li></ul><p><strong>Description</strong></p><p>For each population in the dataset:</p><ol><li>Creates histograms showing the distribution of each trait</li><li>Generates a heatmap of trait correlations for traits with non-zero variance</li></ol><p><strong>Notes</strong></p><ul><li>Skips traits with all missing, NaN, or infinite values</li><li>Only includes traits with variance &gt; 1e-10 in correlation analysis</li><li>Requires at least 3 data points to generate a histogram</li><li>Uses UnicodePlots for visualization in terminal</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = rand(10,3);

julia&gt; GenomicBreedingCore.plot(phenomes);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/phenomes.jl#L447-L474">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.plot-Tuple{TEBV}"><a class="docstring-binding" href="#GenomicBreedingCore.plot-Tuple{TEBV}"><code>GenomicBreedingCore.plot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot(tebv::TEBV)</code></pre><p>Create a visualization of True Estimated Breeding Values (TEBV) analysis results.</p><p>This function extracts phenomes from the TEBV object and generates a plot to visualize the breeding value estimates.</p><p><strong>Arguments</strong></p><ul><li><code>tebv::TEBV</code>: A TEBV object containing the analysis results</li></ul><p><strong>Returns</strong></p><ul><li>A plot object representing the visualization of the phenomes data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/tebv.jl#L345-L358">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.plot-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.plot-Tuple{Trials}"><code>GenomicBreedingCore.plot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plot(trials::Trials; nbins::Int64 = 10)::Nothing</code></pre><p>Generate a comprehensive visualization of trial data through histograms, correlation heatmaps, and bar plots.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A Trials struct containing the trial data to be visualized</li><li><code>nbins::Int64=10</code>: Number of bins for the histogram plots (optional)</li></ul><p><strong>Details</strong></p><p>The function creates three types of plots:</p><ol><li>Histograms for each trait within each population, showing the distribution of trait values</li><li>Correlation heatmaps between traits for each population</li><li>Bar plots showing mean trait values across different trial factors:<ul><li>Years</li><li>Seasons</li><li>Harvests</li><li>Sites</li><li>Replications</li><li>Rows</li><li>Columns</li><li>Populations</li></ul></li></ol><p>Missing, NaN, or infinite values are automatically filtered out before plotting.</p><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: The function displays plots but does not return any value</li></ul><p><strong>Notes</strong></p><ul><li>Requires valid trial data with non-zero variance for correlation plots</li><li>Uses UnicodePlots for visualization in terminal</li><li>Skips plotting for traits with insufficient data points</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; GenomicBreedingCore.plot(trials);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L596-L636">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.removemissnaninf-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.removemissnaninf-Tuple{Trials}"><code>GenomicBreedingCore.removemissnaninf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">removemissnaninf(trials::Trials)::Trials</code></pre><p>Removes missing (<code>missing</code>), <code>NaN</code>, and <code>Inf</code> values from the <code>Trials</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A <code>Trials</code> struct containing phenotypic and trial data.</li></ul><p><strong>Returns</strong></p><ul><li>A new <code>Trials</code> struct with:<ul><li>Trait columns that are completely missing, <code>NaN</code>, or <code>Inf</code> removed.</li><li>Rows with any missing, <code>NaN</code>, or <code>Inf</code> values in phenotypes removed.</li></ul></li></ul><p><strong>Throws</strong></p><ul><li>If the <code>Trials</code> struct is corrupted (fails dimension checks), an <code>ArgumentError</code> is thrown.</li><li>If no rows are removed (i.e., all rows are valid), the original <code>Trials</code> struct is returned.</li><li>If the resulting <code>Trials</code> struct fails dimension checks after filtering, a <code>DimensionMismatch</code> error is thrown.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(n=50, l=100, verbose=false), f_add_dom_epi=rand(13,3), sparsity=0.1, verbose=false);

julia&gt; filtered_trials = removemissnaninf(trials);

julia&gt; D1 = dimensions(trials); D2 = dimensions(filtered_trials);

julia&gt; (D1[&quot;n_missing&quot;] &gt; D2[&quot;n_missing&quot;]) &amp;&amp; (D2[&quot;n_missing&quot;] == D2[&quot;n_nan&quot;] == D2[&quot;n_inf&quot;] == 0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/filter.jl#L243-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulateallelefreqs!-Tuple{Matrix{Union{Missing, Float64}}, Vector{UInt64}, Union{Nothing, ProgressMeter.Progress}}"><a class="docstring-binding" href="#GenomicBreedingCore.simulateallelefreqs!-Tuple{Matrix{Union{Missing, Float64}}, Vector{UInt64}, Union{Nothing, ProgressMeter.Progress}}"><code>GenomicBreedingCore.simulateallelefreqs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulateallelefreqs!(
    allele_frequencies::Matrix{Union{Float64,Missing}}, 
    locus_counter::Vector{UInt},
    pb::Union{Nothing, ProgressMeter.Progress};
    μ::Vector{Float64}, 
    Σ::SparseMatrixCSC{Float64},
    n_alleles::Int64,
    idx_entries_per_population::Vector{Int64},
    rng::TaskLocalRNG = Random.GLOBAL_RNG,
)::Nothing</code></pre><p>Simulates allele frequencies for multiple loci and populations using a multivariate normal distribution.</p><p><strong>Arguments</strong></p><ul><li><code>allele_frequencies::Matrix{Union{Float64,Missing}}</code>: Matrix to store the simulated allele frequencies for all loci</li><li><code>locus_counter::Vector{UInt}</code>: Counter tracking the current locus position</li><li><code>pb::ProgressMeter.Progress</code>: Progress bar for tracking simulation progress</li><li><code>μ::Vector{Float64}</code>: Mean vector for the multivariate normal distribution</li><li><code>Σ::SparseMatrixCSC{Float64}</code>: Variance-covariance matrix for the multivariate normal distribution</li><li><code>n_alleles::Int64</code>: Number of alleles per locus</li><li><code>idx_entries_per_population::Vector{Int64}</code>: Indices for entries in each population</li><li><code>rng::TaskLocalRNG</code>: Random number generator (default: global RNG)</li></ul><p><strong>Description</strong></p><p>Simulates allele frequencies for multiple populations and loci using a multivariate normal distribution. For each allele (except the last one) at each locus, frequencies are sampled from the specified  distribution. For alleles after the first one, frequencies are adjusted to ensure they sum to 1.0 within each locus. All frequencies are bounded between 0.0 and 1.0.</p><p><strong>Returns</strong></p><p><code>Nothing</code></p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If length of allele_frequencies is less than or equal to length of μ</li><li><code>ArgumentError</code>: If length of μ does not match the dimensions of Σ</li><li><code>ArgumentError</code>: If maximum index in idx<em>entries</em>per_population exceeds number of entries</li></ul><p><strong>Note</strong></p><p>The last allele frequency for each locus is implicitly determined as 1 minus the sum of other allele  frequencies to ensure frequencies sum to 1.0.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chrom_lengths, chrom_loci_counts = simulatechromstruct(l=100, n_chroms=7, max_pos=135_000_000);

julia&gt; positions, loci_alleles = simulateposandalleles(chrom_lengths=chrom_lengths, chrom_loci_counts=chrom_loci_counts, n_alleles=2);

julia&gt; Σ_base = simulateldblocks(chrom_positions=positions[1], chrom_length=chrom_lengths[1], ld_corr_50perc_kb=1_000);

julia&gt; μ, Σ = simulateperpopμΣ(Σ_base=Σ_base, μ_β_params=(0.5, 0.5));

julia&gt; populations, idx_population_groupings = simulatepopgroups(n=123, n_populations=3);

julia&gt; allele_frequencies::Matrix{Union{Missing, Float64}} = fill(missing, 123, 100); locus_counter::Vector{UInt} = [1]; pb = nothing;

julia&gt; simulateallelefreqs!(allele_frequencies, locus_counter, pb, μ=μ, Σ=Σ, n_alleles=2, idx_entries_per_population=idx_population_groupings[1])

julia&gt; sum(.!ismissing.(allele_frequencies[idx_population_groupings[1], 1:length(μ)])) == (length(idx_population_groupings[1]) * length(μ))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_genomes.jl#L394-L455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatechromstruct-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulatechromstruct-Tuple{}"><code>GenomicBreedingCore.simulatechromstruct</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulatechromstruct(;l::Int64, n_chroms::Int64, max_pos::Int64)</code></pre><p>Generate chromosome structure parameters for genome simulation.</p><p><strong>Arguments</strong></p><ul><li><code>l::Int64</code>: Total number of loci to distribute across chromosomes (2 to 1e9)</li><li><code>n_chroms::Int64</code>: Number of chromosomes (1 to 1e6) </li><li><code>max_pos::Int64</code>: Maximum genome size in base pairs (10 to 160e9)</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>chrom_lengths::Vector{Int64}</code>: Vector of chromosome lengths in base pairs</li><li><code>chrom_loci_counts::Vector{Int64}</code>: Vector of loci counts per chromosome</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chrom_lengths, chrom_loci_counts = simulatechromstruct(l=10_000, n_chroms=7, max_pos=135_000_000)
([19285714, 19285714, 19285714, 19285714, 19285714, 19285714, 19285716], [1428, 1428, 1428, 1428, 1428, 1428, 1432])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_genomes.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatecovarianceautocorrelated"><a class="docstring-binding" href="#GenomicBreedingCore.simulatecovarianceautocorrelated"><code>GenomicBreedingCore.simulatecovarianceautocorrelated</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simulatecovarianceautocorrelated(p::Int64, ρ::Float64 = 0.75)::Matrix{Float64}</code></pre><p>Generate a p × p autocorrelated covariance matrix where the correlation between elements decays exponentially with their distance.</p><p><strong>Arguments</strong></p><ul><li><code>p::Int64</code>: Size of the square covariance matrix</li><li><code>ρ::Float64 = 0.75</code>: Autocorrelation parameter, must be between -1 and 1</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A p × p positive definite covariance matrix where Σᵢⱼ = ρ^(|i-j|)</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If ρ is not between -1 and 1</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Σ = simulatecovarianceautocorrelated(7, 0.72);

julia&gt; size(Σ)
(7, 7)

julia&gt; (var(Σ) &gt; 0.0) &amp;&amp; (abs(det(Σ)) &gt; 0.0)
true

julia&gt; (Σ[:, 1] == Σ[1, :]) &amp;&amp; (Σ[:, 2] == Σ[2, :])
true

julia&gt; sum(diff(reverse(Σ[1, :])) .&gt; 0.0) == 6
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L271-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatecovariancediagonal-Tuple{Int64, Vector{Float64}}"><a class="docstring-binding" href="#GenomicBreedingCore.simulatecovariancediagonal-Tuple{Int64, Vector{Float64}}"><code>GenomicBreedingCore.simulatecovariancediagonal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulatecovariancediagonal(p::Int64, σ²::Vector{Float64})::Matrix{Float64}</code></pre><p>Simulate a diagonal covariance matrix with specified variances σ² on the diagonal.</p><p><strong>Arguments</strong></p><ul><li><code>p::Int64</code>: Dimension of the covariance matrix </li><li><code>σ²::Vector{Float64}</code>: Vector of variance values for diagonal elements</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: p × p diagonal covariance matrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Σ = simulatecovariancediagonal(7, rand(7));

julia&gt; size(Σ)
(7, 7)

julia&gt; var(Σ[diagind(Σ)]) &gt; 0.0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L200-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatecovariancekinship-Tuple{Int64, Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.simulatecovariancekinship-Tuple{Int64, Genomes}"><code>GenomicBreedingCore.simulatecovariancekinship</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulatecovariancekinship(p::Int64, genomes::Genomes)::Matrix{Float64}</code></pre><p>Calculate a genomic relationship matrix (GRM) from simulated genomic data.</p><p><strong>Arguments</strong></p><ul><li><code>p::Int64</code>: Expected number of entries/individuals in the genomic data</li><li><code>genomes::Genomes</code>: Genomic data structure containing genetic information</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A p × p genomic relationship matrix</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the provided <code>p</code> doesn&#39;t match the number of entries in <code>genomes</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Σ = simulatecovariancekinship(7, simulategenomes(n=7, l=1_000, verbose=false));

julia&gt; size(Σ)
(7, 7)

julia&gt; (var(Σ) &gt; 0.0) &amp;&amp; (abs(det(Σ)) &gt; 0.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L319-L343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatecovariancerandom"><a class="docstring-binding" href="#GenomicBreedingCore.simulatecovariancerandom"><code>GenomicBreedingCore.simulatecovariancerandom</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">simulatecovariancerandom(p::Int64, seed::Int64 = 42)::Matrix{Float64}</code></pre><p>Generate a random positive semidefinite covariance matrix of size p × p.</p><p><strong>Arguments</strong></p><ul><li><code>p::Int64</code>: Dimension of the covariance matrix to generate</li><li><code>seed::Int64 = 42</code>: Random seed for reproducibility</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A p × p positive semidefinite covariance matrix</li></ul><p><strong>Details</strong></p><p>The function generates a random covariance matrix by:</p><ol><li>Creating a p × 1 random normal vector</li><li>Computing the outer product of this vector with itself</li><li>Inflating the diagonal elements to ensure positive definiteness</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Σ = simulatecovariancerandom(7, 123);

julia&gt; size(Σ)
(7, 7)

julia&gt; (var(Σ) &gt; 0.0) &amp;&amp; (abs(det(Σ)) &gt; 0.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L233-L261">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatecovariancespherical-Tuple{Int64, Float64}"><a class="docstring-binding" href="#GenomicBreedingCore.simulatecovariancespherical-Tuple{Int64, Float64}"><code>GenomicBreedingCore.simulatecovariancespherical</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulatecovariancespherical(p::Int64, σ²::Float64)::Matrix{Float64}</code></pre><p>Simulate a spherical covariance matrix with constant variance σ² on the diagonal.</p><p><strong>Arguments</strong></p><ul><li><code>p::Int64</code>: Dimension of the covariance matrix</li><li><code>σ²::Float64</code>: Constant variance value for diagonal elements</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: p × p spherical covariance matrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Σ = simulatecovariancespherical(7, 2.15);

julia&gt; size(Σ)
(7, 7)

julia&gt; Σ[diagind(Σ)] == fill(2.15, 7)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L170-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulateeffects-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulateeffects-Tuple{}"><code>GenomicBreedingCore.simulateeffects</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulateeffects(; p::Int64 = 2, q::Int64 = 1, λ::Float64 = 1.00, 
                covar_details::Tuple{Function,Union{Float64,Vector{Float64},Int64,Genomes}} = (simulatecovariancespherical, 1.00),
                seed::Int64 = 42)::Matrix{Float64}</code></pre><p>Simulate correlated effects by sampling from a multivariate normal distribution.</p><p>This function generates a matrix of correlated effects by:</p><ol><li>Sampling means (μ) from an exponential distribution with parameter λ</li><li>Creating a covariance matrix Σ using the specified covariance function and parameters</li><li>Drawing samples from MvNormal(μ, Σ)</li></ol><p><strong>Arguments</strong></p><ul><li><code>p::Int64</code>: Number of correlated effects to simulate (default = 2)</li><li><code>q::Int64</code>: Number of times to simulate the correlated effects from the same distribution (default = 1)</li><li><code>λ::Float64</code>: Rate parameter of the exponential distribution for sampling means (default = 1.00)</li><li><code>covar_details::Tuple{Function,Union{Float64,Vector{Float64},Int64,Genomes}}</code>: Tuple containing:<ul><li>First element: Covariance simulation function to use</li><li>Second element: Parameter(s) for the covariance function:<ul><li>Float64 for spherical or autocorrelated covariance</li><li>Vector{Float64} for diagonal covariance</li><li>Int64 for random covariance seed</li><li>Genomes object for kinship covariance</li></ul></li></ul></li><li><code>seed::Int64</code>: Random number generator seed for reproducibility (default = 42)</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A p × q matrix where each column represents a set of correlated effects</li></ul><p><strong>Supported Covariance Functions</strong></p><ul><li><code>simulatecovariancespherical</code>: Spherical covariance with constant variance parameter </li><li><code>simulatecovariancediagonal</code>: Diagonal covariance with vector of variances</li><li><code>simulatecovariancerandom</code>: Random covariance with seed parameter</li><li><code>simulatecovarianceautocorrelated</code>: Autocorrelated covariance with correlation parameter</li><li><code>simulatecovariancekinship</code>: Kinship-based covariance with Genomes object</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; θ₀ = simulateeffects();

julia&gt; sum(abs.(θ₀)) &gt; 0.0
true

julia&gt; p = 10; q = 5;

julia&gt; θ₁ = simulateeffects(p=p, q=q, λ=0.50, covar_details=(simulatecovariancediagonal, rand(p)));

julia&gt; (size(θ₁) == (p, q)) &amp;&amp; (θ₀ != θ₁)
true

julia&gt; θ₂ = simulateeffects(p=p, q=q, λ=0.50, covar_details=(simulatecovariancerandom, 123));

julia&gt; (size(θ₂) == (p, q)) &amp;&amp; (θ₁ != θ₂)
true

julia&gt; θ₃ = simulateeffects(p=p, q=q, λ=0.50, covar_details=(simulatecovarianceautocorrelated, 0.71));

julia&gt; (size(θ₃) == (p, q)) &amp;&amp; (θ₂ != θ₃)
true

julia&gt; genomes = simulategenomes(n=p, l=1_000, n_alleles=3, verbose=false);

julia&gt; θ₄ = simulateeffects(p=p, q=q, λ=0.50, covar_details=(simulatecovariancekinship, genomes));

julia&gt; (size(θ₄) == (p, q)) &amp;&amp; (θ₃ != θ₄)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L353-L419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulategenomes-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulategenomes-Tuple{}"><code>GenomicBreedingCore.simulategenomes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulategenomes(;
    n::Int64 = 100,
    n_populations::Int64 = 1, 
    l::Int64 = 10_000,
    n_chroms::Int64 = 7,
    n_alleles::Int64 = 2,
    max_pos::Int64 = 135_000_000,
    ld_corr_50perc_kb::Int64 = 1_000,
    rel_dist_multiplier::Float64 = 10.0,
    μ_β_params::Tuple{Float64,Float64} = (0.5, 0.5),
    sparsity::Float64 = 0.0,
    seed::Int64 = 42,
    verbose::Bool = true
)::Genomes</code></pre><p>Simulates genomic data with population structure and linkage disequilibrium.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: Number of entries/individuals to simulate (1 to 1e9)</li><li><code>n_populations::Int64</code>: Number of populations to simulate (1 to n)</li><li><code>l::Int64</code>: Number of loci to simulate (2 to 1e9)</li><li><code>n_chroms::Int64</code>: Number of chromosomes (1 to 1e6)</li><li><code>n_alleles::Int64</code>: Number of alleles per locus (2 to 5, representing A, T, C, G, D)</li><li><code>max_pos::Int64</code>: Maximum position in base pairs (10 to 160e9)</li><li><code>ld_corr_50perc_kb::Int64</code>: Distance in kb where correlation decay reaches 50%</li><li><code>rel_dist_multiplier::Float64</code>: Multiplier for maximum relative distance to consider in LD blocks</li><li><code>μ_β_params::Tuple{Float64,Float64}</code>: Shape parameters for Beta distribution of allele frequencies</li><li><code>sparsity::Float64</code>: Proportion of missing data to simulate (0.0 to 1.0)</li><li><code>seed::Int64</code>: Random seed for reproducibility</li><li><code>verbose::Bool</code>: Whether to show progress bar and final plot</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A struct containing:<ul><li>entries: Vector of entry IDs</li><li>populations: Vector of population assignments</li><li>loci_alleles: Vector of locus-allele combinations</li><li>allele_frequencies: Matrix of allele frequencies</li><li>mask: Boolean matrix indicating valid data points</li></ul></li></ul><p><strong>Details</strong></p><ul><li>Simulates genomic data by:<ul><li>Generating chromosome lengths and loci positions</li><li>Assigning alleles to loci</li><li>Grouping entries into populations</li><li>Simulating allele frequencies with linkage disequilibrium using multivariate normal distribution</li><li>Adding optional sparsity (missing data)</li></ul></li><li>Chromosome lengths are distributed evenly, with any remainder added to last chromosome</li><li>Loci positions are randomly sampled without replacement within each chromosome</li><li>LD decay follows an exponential function: corr = 1/exp(r*d), where d is normalized distance</li><li>Mean allele frequencies are sampled from Beta(α,β) distribution</li><li>Population structure is implemented by sampling the mean allele frequencies per population</li><li>For each entry and locus, allele frequencies with linkage disequilibrium are simulated by sampling a multivariate normal distribution per chromosome</li><li>Missing data is randomly assigned if sparsity &gt; 0</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input parameters are outside acceptable ranges</li><li><code>DimensionMismatch</code>: If there&#39;s an error in the simulation process</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=3, verbose=false);

julia&gt; length(genomes.entries)
100

julia&gt; length(genomes.populations)
100

julia&gt; length(genomes.loci_alleles)
2000

julia&gt; size(genomes.allele_frequencies)
(100, 2000)

julia&gt; mean(ismissing.(genomes.allele_frequencies))
0.0

julia&gt; rng::TaskLocalRNG = Random.seed!(123);

julia&gt; idx = StatsBase.sample(rng, range(1, 2_000, step=2), 250, replace = false, ordered = true);

julia&gt; correlations = StatsBase.cor(genomes.allele_frequencies[:, idx]);

julia&gt; correlations[10,10] == 1.00
true

julia&gt; correlations[10,10] &gt; correlations[10,250]
true

julia&gt; genomes = simulategenomes(n=100, l=10_000, n_alleles=3, sparsity=0.25, verbose=false);

julia&gt; mean(ismissing.(genomes.allele_frequencies))
0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_genomes.jl#L526-L621">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulategenomiceffects-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulategenomiceffects-Tuple{}"><code>GenomicBreedingCore.simulategenomiceffects</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulategenomiceffects(;
    genomes::Genomes,
    f_additive::Float64 = 0.01,
    f_dominance::Float64 = 0.10,
    f_epistasis::Float64 = 0.05,
    seed::Int64 = 42,
)::Tuple{Matrix{Float64},Matrix{Float64}}</code></pre><p>Simulate additive, dominance, and epistatic effects for multiple loci.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Genome struct containing <code>n</code> entries x <code>p</code> loci-alleles combinations</li><li><code>f_additive::Float64</code>: Proportion of loci with non-zero additive effects (default = 0.01)</li><li><code>f_dominance::Float64</code>: Proportion of additive loci with dominance effects (default = 0.10)</li><li><code>f_epistasis::Float64</code>: Proportion of additive loci with epistasis effects (default = 0.05)</li><li><code>seed::Int64</code>: Random seed for reproducibility (default = 42)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Matrix{Float64},Matrix{Float64}}</code>:<ul><li>First matrix (n x 3): Additive, dominance and epistasis effects per entry</li><li>Second matrix (p x 3): Effects per locus-allele combination</li></ul></li></ul><p><strong>Details</strong></p><p>The genetic effects are simulated using diagonal variance-covariance matrices:</p><ol><li><p>For additive effects: Uses a diagonal matrix with random variances for each of the <code>a</code> loci  with max<em>n</em>alleles-1 allele effects per locus.</p></li><li><p>For dominance effects: Uses a diagonal matrix with random variances for each of the <code>d</code> loci, simulating one dominance effect per locus.</p></li><li><p>For epistasis effects: Uses a diagonal matrix with random variances for each of the <code>e</code> loci  with max<em>n</em>alleles-1 allele effects per locus. The final epistatic effects are computed by  multiplying allele frequencies and effects for all possible pairs of epistatic loci.</p></li></ol><p>For all three types of effects, means are sampled from an exponential distribution (λ=1).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);

julia&gt; G, B = simulategenomiceffects(genomes=genomes, f_additive=0.05, f_dominance=0.75, f_epistasis=0.25);

julia&gt; size.([G, B])
2-element Vector{Tuple{Int64, Int64}}:
 (100, 3)
 (4000, 3)

julia&gt; sum(B .!= 0.0, dims=1)
1×3 Matrix{Int64}:
 200  75  50</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_effects.jl#L485-L538">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulateldblocks-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulateldblocks-Tuple{}"><code>GenomicBreedingCore.simulateldblocks</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulateldblocks(;
    chrom_positions::Vector{Int64}, 
    chrom_length::Int64, 
    ld_corr_50perc_kb::Int64,
    rel_dist_multiplier::Float64 = 10.0
)::SparseMatrixCSC{Float64}</code></pre><p>Simulate linkage disequilibrium (LD) blocks by generating a sparse variance-covariance matrix.</p><p><strong>Arguments</strong></p><ul><li><code>chrom_positions::Vector{Int64}</code>: Vector of positions on the chromosome for each locus</li><li><code>chrom_length::Int64</code>: Total length of the chromosome</li><li><code>ld_corr_50perc_kb::Int64</code>: Distance in kilobases at which the LD correlation decays to 50%</li><li><code>rel_dist_multiplier::Float64</code>: Multiplier for maximum relative distance to consider (default: 10.0)</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrixCSC{Float64}</code>: A sparse variance-covariance matrix representing LD blocks</li></ul><p><strong>Details</strong></p><p>The function creates a variance-covariance matrix where the correlation between loci decays  exponentially with distance. The decay rate is calculated to achieve 50% correlation at the  specified distance (<code>ld_corr_50perc_kb</code>). </p><p>For computational efficiency, correlations between loci are set to zero if:</p><ol><li>The normalized distance is greater than rel<em>dist</em>multiplier * q, where q is the normalized  LD decay distance (ld<em>corr</em>50perc<em>kb / chrom</em>length)</li><li>The normalized distance is greater than 0.9 (90% of chromosome length)</li></ol><p>The computation uses multi-threading with <code>Threads.@threads</code> to parallelize the calculation of correlation values across loci positions.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If number of loci exceeds chromosome length</li><li><code>ArgumentError</code>: If LD correlation distance exceeds chromosome length</li><li><code>ArgumentError</code>: If rel<em>dist</em>multiplier is less than 1.0</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chrom_lengths, chrom_loci_counts = simulatechromstruct(l=100, n_chroms=7, max_pos=135_000_000);

julia&gt; positions, loci_alleles = simulateposandalleles(chrom_lengths=chrom_lengths, chrom_loci_counts=chrom_loci_counts, n_alleles=2);

julia&gt; Σ = simulateldblocks(chrom_positions=positions[1], chrom_length=chrom_lengths[1], ld_corr_50perc_kb=1_000);

julia&gt; size(Σ)
(14, 14)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_genomes.jl#L221-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatemating-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulatemating-Tuple{}"><code>GenomicBreedingCore.simulatemating</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulatemating(;
    parent_genomes::Genomes,
    n_generations::Int = 1,
    pop_size_per_gen::Vector{Int64} = [100],
    seed::Int64 = 42,
    verbose::Bool = false
)::Vector{Genomes}</code></pre><p>Simulates mating processes across multiple generations using a multivariate normal distribution approach.</p><p><strong>Arguments</strong></p><ul><li><code>parent_genomes::Genomes</code>: Initial parent genomic information containing allele frequencies</li><li><code>n_generations::Int</code>: Number of generations to simulate (default: 1)</li><li><code>pop_size_per_gen::Vector{Int64}</code>: Vector of population sizes for each generation (default: [100])</li><li><code>seed::Int64</code>: Random seed for reproducibility (default: 42)</li><li><code>verbose::Bool</code>: Whether to print progress messages (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Genomes}</code>: Vector of genomes across generations</li></ul><p><strong>Description</strong></p><p>This function simulates genetic inheritance across generations by:</p><ol><li>Sampling progeny allele frequencies using multivariate normal distribution</li><li>Enforcing biological constraints (frequencies between 0 and 1)</li><li>Normalizing frequencies for multiallelic loci</li><li>Displaying frequency histograms for each generation</li></ol><p>The simulation maintains allele frequency correlations within chromosomes and handles multiallelic loci by ensuring their frequencies sum to 1.</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If parent genomes contain missing values or invalid dimensions</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parent_genomes = simulategenomes(n=5, l=10_000, n_alleles=3, verbose=false);

julia&gt; great_great_offspring_genomes = simulatemating(parent_genomes=parent_genomes, n_generations=3, pop_size_per_gen=[10, 20, 30]);

julia&gt; [length(x.entries) for x in great_great_offspring_genomes] == [5, 10, 20, 30]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_mating.jl#L31-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulateperpopμΣ-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulateperpopμΣ-Tuple{}"><code>GenomicBreedingCore.simulateperpopμΣ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulateperpopμΣ(; 
    Σ_base::SparseMatrixCSC{Float64}, 
    μ_β_params::Tuple{Float64,Float64} = (0.5, 0.5),
    rng::TaskLocalRNG = Random.GLOBAL_RNG
) -&gt; Tuple{Vector{Float64}, SparseMatrixCSC{Float64}}</code></pre><p>Simulate per-population mean allele frequencies and their variance-covariance matrix.</p><p><strong>Arguments</strong></p><ul><li><code>Σ_base::SparseMatrixCSC{Float64}</code>: Base variance-covariance matrix to be scaled</li><li><code>μ_β_params::Tuple{Float64,Float64}</code>: Parameters (α, β) for Beta distribution used to generate mean allele frequencies (default: (0.5, 0.5))</li><li><code>rng::TaskLocalRNG</code>: Random number generator for reproducibility (default: GLOBAL_RNG)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Float64}, SparseMatrixCSC{Float64}}</code>: A tuple containing:<ul><li>Vector of mean allele frequencies (μ)</li><li>Scaled variance-covariance matrix (Σ)</li></ul></li></ul><p><strong>Details</strong></p><p>The function:</p><ol><li>Samples mean allele frequencies from a Beta distribution</li><li>Scales the variance-covariance matrix based on allele frequencies</li><li>Ensures positive definiteness of the resulting matrix through iterative adjustment</li></ol><p>The variance scaling is performed such that loci closer to fixation (0.0 or 1.0)  have lower variance, following population genetics expectations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chrom_lengths, chrom_loci_counts = simulatechromstruct(l=100, n_chroms=7, max_pos=135_000_000);

julia&gt; positions, loci_alleles = simulateposandalleles(chrom_lengths=chrom_lengths, chrom_loci_counts=chrom_loci_counts, n_alleles=2);

julia&gt; Σ_base = simulateldblocks(chrom_positions=positions[1], chrom_length=chrom_lengths[1], ld_corr_50perc_kb=1_000);

julia&gt; μ, Σ = simulateperpopμΣ(Σ_base=Σ_base, μ_β_params=(0.5, 0.5));

julia&gt; length(μ) == length(positions[1])
true

julia&gt; size(Σ) == size(Σ_base)
true

julia&gt; abs(sum(Σ .- Σ_base)) &gt; 0.0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_genomes.jl#L317-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatepopgroups-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulatepopgroups-Tuple{}"><code>GenomicBreedingCore.simulatepopgroups</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulatepopgroups(; n::Int64, n_populations::Int64)::Tuple{Vector{String}, Vector{Vector{Int64}}}</code></pre><p>Simulate population groups by dividing a total number of samples into populations.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: Total number of samples (between 1 and 1 billion)</li><li><code>n_populations::Int64</code>: Number of populations to create (between 1 and n)</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>Vector{String}</code>: Vector of population labels for each sample</li><li><code>Vector{Vector{Int64}}</code>: Vector of vectors containing indices for each population group</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; populations, idx_population_groupings = simulatepopgroups(n=100, n_populations=3);

julia&gt; length(populations) == 100
true

julia&gt; length(idx_population_groupings) == 3
true

julia&gt; pops = fill(&quot;&quot;, 100); [pops[x] .= unique(populations)[i] for (i, x) in enumerate([x for x in (idx_population_groupings)])];

julia&gt; pops == populations
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_genomes.jl#L162-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulateposandalleles-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulateposandalleles-Tuple{}"><code>GenomicBreedingCore.simulateposandalleles</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulateposandalleles(;
    chrom_lengths::Vector{Int64}, 
    chrom_loci_counts::Vector{Int64},
    n_alleles::Int64, 
    allele_choices::Vector{String} = [&quot;A&quot;, &quot;T&quot;, &quot;C&quot;, &quot;G&quot;, &quot;D&quot;],
    allele_weights::Weights{Float64,Float64,Vector{Float64}} = StatsBase.Weights([1.0, 1.0, 1.0, 1.0, 0.1] / sum([1.0, 1.0, 1.0, 1.0, 0.1])),
    rng::TaskLocalRNG = Random.GLOBAL_RNG,
    verbose::Bool = false
) -&gt; Tuple{Vector{Vector{Int64}}, Vector{String}}</code></pre><p>Simulates genomic positions and alleles for multiple chromosomes.</p><p><strong>Arguments</strong></p><ul><li><code>chrom_lengths::Vector{Int64}</code>: Vector containing the length of each chromosome</li><li><code>chrom_loci_counts::Vector{Int64}</code>: Vector containing the number of loci to generate for each chromosome</li><li><code>n_alleles::Int64</code>: Number of alleles to generate per locus</li><li><code>allele_choices::Vector{String}</code>: Vector of possible alleles to choose from (default: [&quot;A&quot;, &quot;T&quot;, &quot;C&quot;, &quot;G&quot;, &quot;D&quot;])</li><li><code>allele_weights::Weights</code>: Weights for sampling alleles (default: normalized weights favoring A,T,C,G over D)</li><li><code>rng::TaskLocalRNG</code>: Random number generator for reproducibility (default: global RNG)</li><li><code>verbose::Bool</code>: Whether to show progress bar (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Vector{Int64}}, Vector{String}}</code>: A tuple containing:<ol><li>A vector of vectors, where each inner vector contains the positions for a chromosome</li><li>A vector of strings, where each string contains tab-separated locus information in the format: &quot;chrom<em>N\tposition\tall</em>alleles\tchosen_allele&quot;</li></ol></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input argument lengths don&#39;t match or if invalid number of alleles is requested</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chrom_lengths, chrom_loci_counts = simulatechromstruct(l=100, n_chroms=7, max_pos=135_000_000);

julia&gt; positions, loci_alleles = simulateposandalleles(chrom_lengths=chrom_lengths, chrom_loci_counts=chrom_loci_counts, n_alleles=2);

julia&gt; length(positions) == length(chrom_lengths)
true

julia&gt; length(loci_alleles) == sum(chrom_loci_counts)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_genomes.jl#L58-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.simulatetrials-Tuple{}"><a class="docstring-binding" href="#GenomicBreedingCore.simulatetrials-Tuple{}"><code>GenomicBreedingCore.simulatetrials</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulatetrials(;
    genomes::Genomes,
    f_add_dom_epi::Matrix{Float64} = [
        0.01 0.25 0.10
        0.05 0.50 0.25
        0.10 0.25 0.00
    ],
    n_years::Int64 = 2,
    n_seasons::Int64 = 4,
    n_harvests::Int64 = 2,
    n_sites::Int64 = 4,
    n_replications::Int64 = 2,
    n_blocks::Union{Missing,Int64} = missing,
    n_rows::Union{Missing,Int64} = missing,
    n_cols::Union{Missing,Int64} = missing,
    proportion_of_variance::Union{Missing,Matrix{Float64}} = missing,
    sparsity::Float64 = 0.0,
    seed::Int64 = 42,
    verbose::Bool = true,
)::Tuple{Trials,Vector{SimulatedEffects}}</code></pre><p><strong>Arguments</strong></p><ul><li><code>genomes</code>: Genome struct includes the <code>n</code> entries x <code>p</code> loci-alleles combinations (<code>p</code> = <code>l</code> loci x <code>a-1</code> alleles)</li><li><code>f_add_dom_epi</code>: <code>n_traits</code> x 3 numeric matrix of loci proportion with additive, dominance and epistasis effects, i.e. each column refers to:<ul><li><code>f_additive</code>: proportion of the <code>l</code> loci with non-zero additive effects on the phenotype</li><li><code>f_dominance</code>: proportion of the <code>l*f_additive</code> additive effects loci with additional dominance effects</li><li><code>f_epistasis</code>: proportion of the <code>l*f_additive</code> additive effects loci with additional epistasis effects</li><li>(default = [0.01 0.25 0.10; 0.05 0.50 0.25; 0.10 0.25 0.00])</li></ul></li><li><code>n_years</code>: Number of years (default = 2)</li><li><code>n_seasons</code>: Number of seasons (default = 4)</li><li><code>n_harvests</code>: Number of harvests (default = 2)</li><li><code>n_sites</code>: Number of sites (default = 4)</li><li><code>n_replications</code>: Number of replications (default = 2)</li><li><code>n_blocks</code>: Number of blocks across the entire field layout (default = missing)</li><li><code>n_rows</code>: Number of rows across the entire field layout (default = missing)</li><li><code>n_cols</code>: Number of columns across the entire field layout (default = missing)</li><li><code>proportion_of_variance</code>: <code>9</code> x <code>n_traits</code> numeric matrix of scaled/non-scaled proportion of variances allocated to   genetic and environmental effects (default = missing; values will be sampled from a uniform distribution  followed by a biased sample on the first row, i.e. additive effects row).  The rows correspond to the variance allocated to:<ol><li>additive genetic effects</li><li>dominance genetic effects</li><li>epistasis genetic effects</li><li>years effects</li><li>seasons effects</li><li>sites effects</li><li>environmental interactions</li><li>spatial interactions</li><li>GxE interactiions</li></ol></li><li><code>seed</code>: Randomisation seed (default = 42)</li><li><code>sparsity</code>: Proportion of missing data (default = 0.0)</li><li><code>verbose</code>: Show trials simulation progress bar? (default = true)</li></ul><p><strong>Outputs</strong></p><ul><li><code>Trials</code> struct of simulated phenotype data</li><li>Vector of <code>SimulatedEffects</code> each corresponding to each trait-year-season-harvest-site-replication combination</li></ul><p><strong>Details</strong></p><p>The function simulates trial data by:</p><ol><li>Generating genetic effects (additive, dominance, epistasis)</li><li>Simulating environmental effects for:<ul><li>Years, seasons, sites</li><li>Environmental interactions</li><li>Spatial field effects (blocks, rows, columns)</li><li>Genotype-by-environment interactions</li></ul></li><li>Combining effects according to specified variance proportions</li><li>Applying optional sparsity to create missing data</li></ol><p>The field layout is optimized to have:</p><ul><li>Number of rows ≤ number of columns</li><li>Blocks divided along columns</li><li>Even distribution of entries and replications</li></ul><p>The function uses various covariance structures to simulate environmental and spatial effects:</p><ol><li><strong>Autocorrelated Covariance</strong>: Used for effects such as years, seasons, and blocks. This structure assumes that neighboring elements are more correlated than distant ones.</li><li><strong>Random Covariance</strong>: Used for site effects, where the covariance matrix is generated randomly.</li><li><strong>Spherical Covariance</strong>: Used for replication effects, assuming uniform correlation across all elements.</li><li><strong>Diagonal Covariance</strong>: Used for allele-by-environment interaction effects, where only diagonal elements are non-zero, representing independent effects.</li><li><strong>Custom Covariance</strong>: Specific covariance structures can be passed as arguments to simulate effects with tailored correlation patterns.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);

julia&gt; trials::Trials, vector_of_effects::Array{SimulatedEffects,1} = simulatetrials(genomes=genomes, sparsity=0.25, verbose=false);

julia&gt; size(trials.phenotypes)
(12800, 3)

julia&gt; size(trials.traits)
(3,)

julia&gt; unique(trials.entries) == genomes.entries
true

julia&gt; unique(trials.populations) == unique(genomes.populations)
true

julia&gt; abs(mean(ismissing.(trials.phenotypes)) - 0.25) &lt; 0.00001
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/simulations/simulate_trials.jl#L1-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.slice-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.slice-Tuple{Genomes}"><code>GenomicBreedingCore.slice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">slice(
    genomes::Genomes; 
    idx_entries::Union{Nothing, Vector{Int64}} = nothing,
    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,
    verbose::Bool = false
)::Genomes</code></pre><p>Create a subset of a <code>Genomes</code> struct by selecting specific entries and loci-allele combinations.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: The source genomic data structure to be sliced</li><li><code>idx_entries::Union{Nothing, Vector{Int64}}</code>: Indices of entries to keep. If <code>nothing</code>, all entries are kept</li><li><code>idx_loci_alleles::Union{Nothing, Vector{Int64}}</code>: Indices of loci-allele combinations to keep. If <code>nothing</code>, all loci-alleles are kept</li><li><code>verbose::Bool</code>: If true, displays a progress bar during slicing. Defaults to false</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A new <code>Genomes</code> struct containing only the selected entries and loci-allele combinations</li></ul><p><strong>Performance Notes</strong></p><ul><li>The function uses multi-threaded implementation for optimal performance</li><li>Progress bar is available when <code>verbose=true</code> to monitor the slicing operation</li><li>Memory efficient implementation that creates a new pre-allocated structure</li></ul><p><strong>Behaviour</strong></p><ul><li>Both index vectors are automatically sorted and deduplicated</li><li>If both <code>idx_entries</code> and <code>idx_loci_alleles</code> are <code>nothing</code>, returns a clone of the input</li><li>Maintains all relationships and structure of the original genomic data</li><li>Preserves population assignments and allele frequencies for selected entries</li></ul><p><strong>Validation</strong></p><ul><li>Performs dimension checks on both input and output genomic structures</li><li>Validates that all indices are within proper bounds</li><li>Ensures data consistency throughout the slicing operation</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input <code>Genomes</code> struct is corrupted or indices are out of bounds</li><li><code>DimensionMismatch</code>: If the resulting sliced genome has inconsistent dimensions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);

julia&gt; sliced_genomes = slice(genomes, idx_entries=collect(1:10), idx_loci_alleles=collect(1:300));

julia&gt; dimensions(sliced_genomes)
Dict{String, Int64} with 7 entries:
  &quot;n_entries&quot;      =&gt; 10
  &quot;n_chr&quot;          =&gt; 1
  &quot;n_loci&quot;         =&gt; 100
  &quot;n_loci_alleles&quot; =&gt; 300
  &quot;n_populations&quot;  =&gt; 1
  &quot;n_missing&quot;      =&gt; 0
  &quot;max_n_alleles&quot;  =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L1-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.slice-Tuple{Phenomes}"><a class="docstring-binding" href="#GenomicBreedingCore.slice-Tuple{Phenomes}"><code>GenomicBreedingCore.slice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">slice(phenomes::Phenomes; idx_entries::Union{Nothing, Vector{Int64}}=nothing, idx_traits::Union{Nothing, Vector{Int64}}=nothing)::Phenomes</code></pre><p>Create a new <code>Phenomes</code> object containing a subset of the original data by selecting specific entries and traits.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: The original Phenomes object to slice</li><li><code>idx_entries::Union{Nothing, Vector{Int64}}=nothing</code>: Indices of entries to keep. If <code>nothing</code>, all entries are kept</li><li><code>idx_traits::Union{Nothing, Vector{Int64}}=nothing</code>: Indices of traits to keep. If <code>nothing</code>, all traits are kept</li></ul><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A new Phenomes object containing only the selected entries and traits</li></ul><p><strong>Notes</strong></p><ul><li>The function preserves the original structure while reducing dimensions</li><li>Indices must be within valid ranges (1 to n<em>entries/n</em>traits)</li><li>Duplicate indices are automatically removed</li><li>The resulting object maintains all relationships between entries, populations, traits, and phenotypes</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the input Phenomes struct is corrupted or if indices are out of bounds</li><li><code>DimensionMismatch</code>: If the slicing operation results in invalid dimensions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = fill(0.0, 10,3);

julia&gt; sliced_phenomes = slice(phenomes, idx_entries=collect(1:5); idx_traits=collect(2:3));

julia&gt; dimensions(sliced_phenomes)
Dict{String, Int64} with 8 entries:
  &quot;n_total&quot;       =&gt; 10
  &quot;n_zeroes&quot;      =&gt; 10
  &quot;n_nan&quot;         =&gt; 0
  &quot;n_entries&quot;     =&gt; 5
  &quot;n_traits&quot;      =&gt; 2
  &quot;n_inf&quot;         =&gt; 0
  &quot;n_populations&quot; =&gt; 1
  &quot;n_missing&quot;     =&gt; 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/filter.jl#L1-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.slice-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.slice-Tuple{Trials}"><code>GenomicBreedingCore.slice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">slice(
    trials::Trials; 
    traits::Union{Nothing, Vector{String}} = nothing,
    populations::Union{Nothing, Vector{String}} = nothing,
    entries::Union{Nothing, Vector{String}} = nothing,
    years::Union{Nothing, Vector{String}} = nothing,
    harvests::Union{Nothing, Vector{String}} = nothing,
    seasons::Union{Nothing, Vector{String}} = nothing,
    sites::Union{Nothing, Vector{String}} = nothing,
    replications::Union{Nothing, Vector{String}} = nothing,
    blocks::Union{Nothing, Vector{String}} = nothing,
    rows::Union{Nothing, Vector{String}} = nothing,
    cols::Union{Nothing, Vector{String}} = nothing,
)::Trials</code></pre><p>Create a subset of a <code>Trials</code> struct by filtering its components based on specified criteria.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: The source trials data structure to be sliced</li><li><code>traits::Vector{String}</code>: Selected trait names to include</li><li><code>populations::Vector{String}</code>: Selected population names to include</li><li><code>entries::Vector{String}</code>: Selected entry names to include</li><li><code>years::Vector{String}</code>: Selected years to include</li><li><code>harvests::Vector{String}</code>: Selected harvest identifiers to include</li><li><code>seasons::Vector{String}</code>: Selected seasons to include</li><li><code>sites::Vector{String}</code>: Selected site names to include</li><li><code>replications::Vector{String}</code>: Selected replication identifiers to include</li><li><code>blocks::Vector{String}</code>: Selected block identifiers to include</li><li><code>rows::Vector{String}</code>: Selected row identifiers to include</li><li><code>cols::Vector{String}</code>: Selected column identifiers to include</li></ul><p>All arguments except <code>trials</code> are optional. When an argument is not provided (i.e., <code>nothing</code>),  all values for that category are included in the slice.</p><p><strong>Returns</strong></p><ul><li>A new <code>Trials</code> struct containing only the selected data</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If invalid names are provided for any category or if no data remains after filtering</li><li><code>DimensionMismatch</code>: If the resulting sliced trials structure has inconsistent dimensions</li><li><code>ArgumentError</code>: If the input trials structure is corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; sliced_trials = slice(trials, traits=trials.traits[2:3], years=[unique(trials.years)[1]], seasons=unique(trials.seasons)[2:3]);

julia&gt; dimensions(sliced_trials)
Dict{String, Int64} with 16 entries:
  &quot;n_zeroes&quot;       =&gt; 0
  &quot;n_harvests&quot;     =&gt; 2
  &quot;n_nan&quot;          =&gt; 0
  &quot;n_entries&quot;      =&gt; 100
  &quot;n_traits&quot;       =&gt; 2
  &quot;n_seasons&quot;      =&gt; 2
  &quot;n_blocks&quot;       =&gt; 10
  &quot;n_rows&quot;         =&gt; 10
  &quot;n_missing&quot;      =&gt; 0
  &quot;n_inf&quot;          =&gt; 0
  &quot;n_total&quot;        =&gt; 6400
  &quot;n_replications&quot; =&gt; 2
  &quot;n_years&quot;        =&gt; 1
  &quot;n_sites&quot;        =&gt; 4
  &quot;n_cols&quot;         =&gt; 20
  &quot;n_populations&quot;  =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/filter.jl#L1-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.sparsities-Tuple{Genomes}"><a class="docstring-binding" href="#GenomicBreedingCore.sparsities-Tuple{Genomes}"><code>GenomicBreedingCore.sparsities</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sparsities(genomes::Genomes) -&gt; Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Calculate the sparsity (proportion of missing data) for each entry and locus in a <code>Genomes</code> object.</p><p>Returns a tuple of two vectors:</p><ul><li>First vector contains sparsity values for each entry (row-wise mean of missing values)</li><li>Second vector contains sparsity values for each locus (column-wise mean of missing values)</li></ul><p>The function processes the data in parallel using multiple threads for performance optimization.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes object containing allele frequency data with potentially missing values</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Float64}, Vector{Float64}}</code>: A tuple containing:<ul><li>Vector of entry sparsities (values between 0.0 and 1.0)</li><li>Vector of locus sparsities (values between 0.0 and 1.0)</li></ul></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = simulategenomes(n=100, l=1_000, sparsity=0.25, verbose=false);

julia&gt; entry_sparsities, locus_sparsities = sparsities(genomes);

julia&gt; abs(0.25 - mean(entry_sparsities)) &lt; 0.0001
true

julia&gt; abs(0.25 - mean(locus_sparsities)) &lt; 0.0001
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/genomes/filter.jl#L163-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.summarise-Tuple{Vector{CV}}"><a class="docstring-binding" href="#GenomicBreedingCore.summarise-Tuple{Vector{CV}}"><code>GenomicBreedingCore.summarise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">summarise(cvs::Vector{CV}; verbose::Bool=false)::Tuple{DataFrame,DataFrame}</code></pre><p>Summarize cross-validation results from a vector of CV structs into two DataFrames.</p><p><strong>Returns</strong></p><ul><li>A tuple containing two DataFrames:<ol><li>Summary DataFrame with mean metrics across entries, replications, and folds<ul><li>Contains means and standard deviations of correlation coefficients</li><li>Includes average training and validation set sizes</li><li>Also includes the total number of replications-by-folds (<code>n</code>), number of replications, and number of folds</li><li>Grouped by training population, validation population, trait, and model</li></ul></li><li>Entry-level DataFrame with phenotype prediction statistics<ul><li>Contains true phenotype values, predicted means (μ), and standard deviations (σ)</li><li>Grouped by training population, validation population, trait, model, and entry</li></ul></li></ol></li></ul><p><strong>Arguments</strong></p><ul><li><code>cvs::Vector{CV}</code>: Vector of CV structs containing cross-validation results</li></ul><p><strong>Notes</strong></p><ul><li>Validates dimensions of input CV structs before processing</li><li>Handles missing values in phenotype predictions</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any CV struct in the input vector has inconsistent dimensions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(&quot;cor&quot; =&gt; 0.0, &quot;rmse&quot; =&gt; 1.0); fit_1.trait = &quot;trait_1&quot;;

julia&gt; cv_1 = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit_1, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit_1.metrics);

julia&gt; fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(&quot;cor&quot; =&gt; 1.0, &quot;rmse&quot; =&gt; 0.0); fit_2.trait = &quot;trait_1&quot;;

julia&gt; cv_2 = CV(&quot;replication_2&quot;, &quot;fold_2&quot;, fit_2, [&quot;population_2&quot;], [&quot;entry_2&quot;], [0.0], [0.0], fit_2.metrics);

julia&gt; cvs = [cv_1, cv_2];

julia&gt; df_summary, df_summary_per_entry = summarise(cvs);

julia&gt; size(df_summary)
(2, 11)

julia&gt; size(df_summary_per_entry)
(2, 9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/cv/cv.jl#L377-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.tabularise"><a class="docstring-binding" href="#GenomicBreedingCore.tabularise"><code>GenomicBreedingCore.tabularise</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tabularise(fit::Fit, metric::String = &quot;cor&quot;)::DataFrame</code></pre><p>Convert a Fit struct into a DataFrame for easier data manipulation and analysis.</p><p><strong>Arguments</strong></p><ul><li><code>fit::Fit</code>: A Fit struct containing model results and parameters</li><li><code>metric::String = &quot;cor&quot;</code>: The metric to extract from fit.metrics dictionary (default: &quot;cor&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame with the following columns:<ul><li><code>model</code>: The model name</li><li><code>trait</code>: The trait name</li><li><code>population</code>: Semicolon-separated string of unique population names</li><li><code>metric</code>: The specified metric value from fit.metrics</li><li><code>b_hat_labels</code>: Labels for the effect sizes</li><li><code>b_hat</code>: Estimated effect sizes</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit = Fit(n=100, l=10_000); fit.b_hat = rand(10_000); fit.model=&quot;some_model&quot;; fit.trait=&quot;some_trait&quot;; 

julia&gt; fit.metrics = Dict(&quot;cor&quot; =&gt; rand(), &quot;rmse&quot; =&gt; rand()); fit.populations .= &quot;pop_1&quot;;

julia&gt; df = tabularise(fit);

julia&gt; size(df)
(10000, 6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/fit/fit.jl#L217-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.tabularise-Tuple{Phenomes}"><a class="docstring-binding" href="#GenomicBreedingCore.tabularise-Tuple{Phenomes}"><code>GenomicBreedingCore.tabularise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tabularise(phenomes::Phenomes)::DataFrame</code></pre><p>Convert a <code>Phenomes</code> struct into a tabular format as a <code>DataFrame</code>.</p><p>The resulting DataFrame contains the following columns:</p><ul><li><code>id</code>: Integer index for each entry</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population assignments</li><li>Additional columns for each trait in <code>phenomes.traits</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A valid Phenomes struct containing phenotypic data</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame with entries as rows and traits as columns</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Phenomes struct dimensions are inconsistent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop_1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = fill(0.0, 10,3);

julia&gt; tabularise(phenomes)
10×6 DataFrame
 Row │ id     entries   populations  A         B         C        
     │ Int64  String    String       Float64?  Float64?  Float64? 
─────┼────────────────────────────────────────────────────────────
   1 │     1  entry_1   pop_1             0.0       0.0       0.0
   2 │     2  entry_2   pop_1             0.0       0.0       0.0
   3 │     3  entry_3   pop_1             0.0       0.0       0.0
   4 │     4  entry_4   pop_1             0.0       0.0       0.0
   5 │     5  entry_5   pop_1             0.0       0.0       0.0
   6 │     6  entry_6   pop_1             0.0       0.0       0.0
   7 │     7  entry_7   pop_1             0.0       0.0       0.0
   8 │     8  entry_8   pop_1             0.0       0.0       0.0
   9 │     9  entry_9   pop_1             0.0       0.0       0.0
  10 │    10  entry_10  pop_1             0.0       0.0       0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/merge.jl#L173-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.tabularise-Tuple{Trials}"><a class="docstring-binding" href="#GenomicBreedingCore.tabularise-Tuple{Trials}"><code>GenomicBreedingCore.tabularise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tabularise(trials::Trials)::DataFrame</code></pre><p>Convert a Trials struct into a DataFrame representation for easier data manipulation and analysis.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: A valid Trials struct containing experimental field trial data.</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: A DataFrame with the following columns:<ul><li><code>id</code>: Unique identifier for each trial observation</li><li><code>years</code>: Year of the trial</li><li><code>seasons</code>: Season identifier</li><li><code>harvests</code>: Harvest identifier</li><li><code>sites</code>: Location/site identifier</li><li><code>replications</code>: Replication number</li><li><code>blocks</code>: Block identifier</li><li><code>rows</code>: Row position</li><li><code>cols</code>: Column position</li><li><code>entries</code>: Entry identifier</li><li><code>populations</code>: Population identifier</li><li>Additional columns for each trait in <code>trials.traits</code></li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the Trials struct dimensions are inconsistent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; df = tabularise(trials);

julia&gt; size(df)
(12800, 14)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/trials/trials.jl#L259-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.tabularise-Tuple{Vector{CV}}"><a class="docstring-binding" href="#GenomicBreedingCore.tabularise-Tuple{Vector{CV}}"><code>GenomicBreedingCore.tabularise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tabularise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}</code></pre><p>Convert a vector of CV (Cross-Validation) structs into two DataFrames containing metrics and predictions.</p><p><strong>Arguments</strong></p><ul><li><code>cvs::Vector{CV}</code>: Vector of CV structs containing cross-validation results</li><li><code>verbose::Bool=false</code>: Whether to show a progress bar (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><p><code>Tuple{DataFrame,DataFrame}</code>: A tuple of two DataFrames:</p><ol><li><p><code>df_across_entries</code>: Contains aggregated metrics across entries with columns:</p><ul><li><code>training_population</code>: Semicolon-separated list of training populations</li><li><code>validation_population</code>: Semicolon-separated list of validation populations</li><li><code>trait</code>: Name of the trait</li><li><code>model</code>: Name of the model used</li><li><code>replication</code>: Replication identifier</li><li><code>fold</code>: Fold identifier</li><li><code>training_size</code>: Number of entries in training set</li><li><code>validation_size</code>: Number of entries in validation set</li><li>Additional columns for each metric (e.g., <code>cor</code>, <code>rmse</code>)</li></ul></li><li><p><code>df_per_entry</code>: Contains per-entry predictions with columns:</p><ul><li><code>training_population</code>: Training population identifier</li><li><code>validation_population</code>: Validation population identifier</li><li><code>entry</code>: Entry identifier</li><li><code>trait</code>: Name of the trait</li><li><code>model</code>: Name of the model used</li><li><code>replication</code>: Replication identifier</li><li><code>fold</code>: Fold identifier</li><li><code>y_true</code>: True values</li><li><code>y_pred</code>: Predicted values</li></ul></li></ol></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If input vector is empty or if any CV struct is corrupted</li></ul><p><strong>Notes</strong></p><ul><li>Warns if there are empty CV structs resulting from insufficient training sizes or fixed traits</li><li>Metrics are extracted from the <code>metrics</code> dictionary in each CV struct</li><li>Population identifiers are sorted and joined with semicolons when multiple populations exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(&quot;cor&quot; =&gt; 0.0, &quot;rmse&quot; =&gt; 1.0); fit_1.trait = &quot;trait_1&quot;;

julia&gt; cv_1 = CV(&quot;replication_1&quot;, &quot;fold_1&quot;, fit_1, [&quot;population_1&quot;], [&quot;entry_1&quot;], [0.0], [0.0], fit_1.metrics);

julia&gt; fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(&quot;cor&quot; =&gt; 1.0, &quot;rmse&quot; =&gt; 0.0); fit_2.trait = &quot;trait_1&quot;;

julia&gt; cv_2 = CV(&quot;replication_2&quot;, &quot;fold_2&quot;, fit_2, [&quot;population_2&quot;], [&quot;entry_2&quot;], [0.0], [0.0], fit_2.metrics);

julia&gt; cvs = [cv_1, cv_2];

julia&gt; df_across_entries, df_per_entry = tabularise(cvs);

julia&gt; names(df_across_entries)
10-element Vector{String}:
 &quot;training_population&quot;
 &quot;validation_population&quot;
 &quot;trait&quot;
 &quot;model&quot;
 &quot;replication&quot;
 &quot;fold&quot;
 &quot;training_size&quot;
 &quot;validation_size&quot;
 &quot;cor&quot;
 &quot;rmse&quot;

julia&gt; df_across_entries[!, [:cor, :rmse]]
2×2 DataFrame
 Row │ cor      rmse    
     │ Float64  Float64 
─────┼──────────────────
   1 │     0.0      1.0
   2 │     1.0      0.0

julia&gt; names(df_per_entry)
9-element Vector{String}:
 &quot;training_population&quot;
 &quot;validation_population&quot;
 &quot;entry&quot;
 &quot;trait&quot;
 &quot;model&quot;
 &quot;replication&quot;
 &quot;fold&quot;
 &quot;y_true&quot;
 &quot;y_pred&quot;

julia&gt; df_per_entry[!, [:entry, :y_true, :y_pred]]
2×3 DataFrame
 Row │ entry    y_true   y_pred  
     │ String   Float64  Float64 
─────┼───────────────────────────
   1 │ entry_1      0.0      0.0
   2 │ entry_2      0.0      0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/cv/cv.jl#L180-L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}"><a class="docstring-binding" href="#GenomicBreedingCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}"><code>GenomicBreedingCore.trialsmodelsfomulae!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">trialsmodelsfomulae!(df::DataFrame; trait::String, max_levels::Int64 = 100)::Tuple{Vector{String},Vector{Int64}}</code></pre><p>Generate mixed model formulae for analyzing multi-environment trial data.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: Input DataFrame containing trial data, will be modified in-place</li><li><code>trait::String</code>: Name of the response variable column</li><li><code>max_levels::Int64=100</code>: Maximum number of factor levels allowed in interaction terms</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>Vector{String}</code>: Collection of mixed model formulae with increasing complexity</li><li><code>Vector{Int64}</code>: Corresponding number of factor levels for each formula</li></ul><p><strong>Details</strong></p><p>The function:</p><ol><li>Identifies available trial design variables (nesters, spatial components, targets)</li><li>Creates interaction terms between variables and adds them to the DataFrame</li><li>Generates model formulae considering:<ul><li>Single and multi-environment models</li><li>Fixed and random entry effects</li><li>Spatial error components</li><li>Nested random effects</li></ul></li><li>Filters redundant models and sorts by complexity</li></ol><p><strong>Notes</strong></p><ul><li>Warns if trials are unreplicated</li><li>Throws error if only one entry is present</li><li>Automatically removes block effects when both row and column effects are present</li><li>Removes redundant nesting structures</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials, _simulated_effects = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);

julia&gt; df = tabularise(trials);

julia&gt; size(df)
(12800, 14)

julia&gt; formulae, n_levels = trialsmodelsfomulae!(df, trait=&quot;trait_1&quot;);

julia&gt; size(df)
(12800, 134)

julia&gt; length(formulae)
76

julia&gt; sum(n_levels .== sort(n_levels))
76</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/lmm.jl#L48-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.@string2formula-Tuple{Any}"><a class="docstring-binding" href="#GenomicBreedingCore.@string2formula-Tuple{Any}"><code>GenomicBreedingCore.@string2formula</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@string2formula(x::String)</code></pre><p>Convert a string representation of a formula into a <code>Formula</code> object.</p><p>This macro parses a string containing a formula expression and evaluates it into a proper <code>Formula</code> object that can be used in statistical modelling.</p><p><strong>Arguments</strong></p><ul><li><code>x::String</code>: A string containing the formula expression (e.g., &quot;y ~ x + z&quot;)</li></ul><p><strong>Returns</strong></p><ul><li><code>Formula</code>: A Formula object representing the parsed expression</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/tebv/lmm.jl#L29-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="GenomicBreedingCore.@stringevaluation-Tuple{Any}"><a class="docstring-binding" href="#GenomicBreedingCore.@stringevaluation-Tuple{Any}"><code>GenomicBreedingCore.@stringevaluation</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@stringevaluation(x)</code></pre><p>Parse and evaluate a string expression at compile time.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A string containing a Julia expression to be parsed.</li></ul><p><strong>Returns</strong></p><ul><li>The parsed expression as an <code>Expr</code> object ready for evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingCore.jl/blob/0e3da4e76c80dd6720bfc71815b108e8c147fe32/src/phenomes/merge.jl#L228-L238">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 6 January 2026 23:03">Tuesday 6 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
