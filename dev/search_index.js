var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GBCore","category":"page"},{"location":"#GBCore","page":"Home","title":"GBCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GBCore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GBCore]","category":"page"},{"location":"#GBCore.AbstractGB","page":"Home","title":"GBCore.AbstractGB","text":"AbstractGB\n\nThe root abstract type for all core types in GenomicBreeding.jl package.\n\nThis type serves as the common ancestor for the type hierarchy in the package, enabling shared functionality and type-based dispatch across all derived types.\n\nExtended help\n\nAll custom core types in GenomicBreeding.jl should subtype from AbstractGB to ensure consistency in the type system and to enable generic implementations of common operations.\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.CV","page":"Home","title":"GBCore.CV","text":"Cross-validation struct\n\nContains genomic prediction cross-validation details.\n\nFields\n\nreplication: replication name\nfold: fold name\nfit: genomic prediction model fit on the training set\nvalidation_populations: vector of validation populations corresponding to each validation entry\nvalidation_entries: corresponding vector of entries in the validation population/s\nvalidation_y_true: corresponding vector of observed phenotypes in the validation population/s\nvalidation_y_pred: corresponding vector of predicted phenotypes in the validation population/s\nmetrics: dictionary of genomic prediction accuracy metrics on the validation population/s\n\nConstructor\n\nUses the default contructor.\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.Fit","page":"Home","title":"GBCore.Fit","text":"Genomic prediction model fit\n\nContains genomic prediction model fit details.\n\nFields\n\nmodel: name of the genomic prediction model used\nb_hat_labels: names of the loci-alleles used\nb_hat: effects of the loci-alleles\ntrait: name of the trait\nentries: names of the entries used in the current cross-validation replication and fold\npopulations: names of the populations used in the current cross-validation replication and fold\ny_true: corresponding observed phenotype values\ny_pred: corresponding predicted phenotype values\nmetrics: dictionary of genomic prediction accuracy metrics, inluding Pearson's correlation, mean absolute error and root mean-squared error\n\nConstructor\n\nFit(; n=1, l=10)\nwhere:\n- n::Int64: Number of entries\n- l::Int64: Number of loci-alleles\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.Genomes","page":"Home","title":"GBCore.Genomes","text":"Genomes struct\n\nContaines unique entries and loci_alleles where allele frequencies can have missing values\n\nFields\n\nentries: names of the n entries or samples\npopulations: name/s of the population/s each entries or samples belong to\nloci_alleles: names of the p loci-alleles combinations (p = l loci x a-1 alleles) including the chromsome or scaffold name, position, all alleles and current allele separated by tabs (\"\\t\")\nallele_frequencies: n x p matrix of allele frequencies between 0 and 1 which can have missing values\nmask: n x p matrix of boolean mask for selective analyses and slicing\n\nConstructor\n\nGenomes(; n::Int64 = 1, p::Int64 = 2)\n\nwhere:\n\nn::Int64=1: Number of entries in the genomic dataset\np::Int64=2: Number of locus-allele combinations in the genomic dataset\n\nExamples\n\njulia> genomes = Genomes(n=2, p=2)\nGenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\njulia> fieldnames(Genomes)\n(:entries, :populations, :loci_alleles, :allele_frequencies, :mask)\n\njulia> genomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> genomes.populations = [\"pop_1\", \"pop_1\"];\n\njulia> genomes.loci_alleles = [\"chr1\\t12345\\tA|T\\tA\", \"chr2\\t678910\\tC|D\\tD\"];\n\njulia> genomes.allele_frequencies = [0.5 0.25; 0.9 missing];\n\njulia> genomes.mask = [true true; true false];\n\njulia> genomes\nGenomes([\"entry_1\", \"entry_2\"], [\"pop_1\", \"pop_1\"], [\"chr1\\t12345\\tA|T\\tA\", \"chr2\\t678910\\tC|D\\tD\"], Union{Missing, Float64}[0.5 0.25; 0.9 missing], Bool[1 1; 1 0])\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.Phenomes","page":"Home","title":"GBCore.Phenomes","text":"Phenomes struct\n\nConstains unique entries and traits where phenotype data can have missing values\n\nFields\n\nentries: names of the n entries or samples\npopulations: name/s of the population/s each entries or samples belong to\ntraits: names of the t traits\nphenotypes: n x t matrix of numeric (R) phenotype data which can have missing values\nmask: n x t matrix of boolean mask for selective analyses and slicing\n\nConstructor\n\nPhenomes(; n::Int64 = 1, t::Int64 = 2)\n\nwhere:\n\nn::Int64=1: Number of entries in the phenomic dataset\nt::Int64=2: Number of traits in the phenomic dataset\n\nExamples\n\njulia> phenomes = Phenomes(n=2, t=2)\nPhenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\njulia> fieldnames(Phenomes)\n(:entries, :populations, :traits, :phenotypes, :mask)\n\njulia> phenomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> phenomes.populations = [\"pop_A\", \"pop_B\"];\n\njulia> phenomes.traits = [\"height\", \"yield\"];\n\njulia> phenomes.phenotypes = [200.0 2.5; 150.0 missing];\n\njulia> phenomes.mask = [true true; true false];\n\njulia> phenomes\nPhenomes([\"entry_1\", \"entry_2\"], [\"pop_A\", \"pop_B\"], [\"height\", \"yield\"], Union{Missing, Float64}[200.0 2.5; 150.0 missing], Bool[1 1; 1 0])\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.SimulatedEffects","page":"Home","title":"GBCore.SimulatedEffects","text":"SimulatedEffects struct\n\nContains the various simulated genetic, environmental and GxE effects.\n\nFields\n\nid::Vector{String}: Vector of identifiers\nyear::Float64: Year effect\nseason::Float64: Season effect\nsite::Float64: Site effect\nseasons_x_year::Float64: Interaction effect between seasons and years\nharvests_x_season_x_year::Float64: Interaction effect between harvests, seasons and years\nsites_x_harvest_x_season_x_year::Float64: Interaction effect between sites, harvests, seasons and years\nfield_layout::Matrix{Int64}: 2D matrix representing field layout\nreplications_x_site_x_harvest_x_season_x_year::Vector{Float64}: Replication interaction effects\nblocks_x_site_x_harvest_x_season_x_year::Vector{Float64}: Block interaction effects\nrows_x_site_x_harvest_x_season_x_year::Vector{Float64}: Row interaction effects\ncols_x_site_x_harvest_x_season_x_year::Vector{Float64}: Column interaction effects\nadditive_genetic::Vector{Float64}: Additive genetic effects\ndominance_genetic::Vector{Float64}: Dominance genetic effects\nepistasis_genetic::Vector{Float64}: Epistasis genetic effects\nadditive_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}: Additive allele interaction effects\ndominance_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}: Dominance allele interaction effects\nepistasis_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}: Epistasis allele interaction effects\n\nConstructor\n\nSimulatedEffects()\n\nCreates a new SimulatedEffects instance with default values:\n\nEmpty strings for IDs (vector of size 6)\n0.0 for all float values\n4x4 zero matrix for field_layout\nSingle-element zero vectors for all vector fields\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.TEBV","page":"Home","title":"GBCore.TEBV","text":"Trial-estimated breeding values (TEBV) struct\n\nContains trial-estimated breeding values as generated by analyse(trials::Trials, ...).\n\nFields\n\ntraits: names of the traits t traits\nformulae: best-fitting formula for each trait\nmodels: best-fitting linear mixed model for each trait\ndf_BLUEs: vector of data frames of best linear unbiased estimators or fixed effects table of each best fitting model\ndf_BLUPs: vector of data frames of best linear unbiased predictors or random effects table of each best fitting model\nphenomes: vector of Phenomes structs each containing the breeding values\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1, t=1)]);\n\njulia> tebv.traits\n1-element Vector{String}:\n \"\"\n\n\n\n\n\n","category":"type"},{"location":"#GBCore.Trials","page":"Home","title":"GBCore.Trials","text":"Trials struct\n\nContains phenotype data across years, seasons, harvest, sites, populations, replications, blocks, rows, and columns\n\nFields\n\nphenotypes: n x t matrix of numeric phenotype data which can have missing values\ntraits: names of the traits t traits\nyears: names of the years corresponding to each row in the phenotype matrix\nseasons: names of the seasons corresponding to each row in the phenotype matrix\nharvests: names of the harvests corresponding to each row in the phenotype matrix\nsites: names of the sites corresponding to each row in the phenotype matrix\nreplications: names of the replications corresponding to each row in the phenotype matrix\nblocks: names of the blocks corresponding to each row in the phenotype matrix\nrows: names of the rows corresponding to each row in the phenotype matrix\ncols: names of the cols corresponding to each row in the phenotype matrix\nentries: names of the entries corresponding to each row in the phenotype matrix\npopulations: names of the populations corresponding to each row in the phenotype matrix\n\nConstructor\n\nTrials(; n::Int64 = 2, p::Int64 = 2)\n\nwhere:\n\nn::Int64=1: Number of entries in the trials\nt::Int64=2: Number of traits in the trials\n\nExamples\n\njulia> trials = Trials(n=1, t=2)\nTrials(Union{Missing, Float64}[missing missing], [\"\", \"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"])\n\njulia> fieldnames(Trials)\n(:phenotypes, :traits, :years, :seasons, :harvests, :sites, :replications, :blocks, :rows, :cols, :entries, :populations)\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Tuple{CV, CV}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::CV, y::CV)::Bool\n\nCompare two CV (Cross-Validation) structs for equality.\n\nThis method overloads the equality operator (==) for CV structs by comparing their hash values. Two CV structs are considered equal if they have identical values for all fields.\n\nArguments\n\nx::CV: First CV struct to compare\ny::CV: Second CV struct to compare\n\nReturns\n\nBool: true if the CV structs are equal, false otherwise\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> cv_2 = clone(cv_1);\n\njulia> cv_3 = clone(cv_1); cv_3.replication = \"other_replication\";\n\njulia> cv_1 == cv_2\ntrue\n\njulia> cv_1 == cv_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Fit, Fit}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::Fit, y::Fit)::Bool\n\nCompare two Fit structs for equality based on their hash values.\n\nThis method defines equality comparison for Fit structs by comparing their hash values. Two Fit structs are considered equal if they have identical hash values, which means they have the same values for all their fields.\n\nArguments\n\nx::Fit: First Fit struct to compare\ny::Fit: Second Fit struct to compare\n\nReturns\n\nBool: true if the Fit structs are equal, false otherwise\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=4);\n\njulia> fit_2 = Fit(n=1, l=4);\n\njulia> fit_3 = Fit(n=1, l=2);\n\njulia> fit_1 == fit_2\ntrue\n\njulia> fit_1 == fit_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Genomes, Genomes}","page":"Home","title":"Base.:==","text":"==(x::Genomes, y::Genomes)::Bool\n\nCompare two Genomes structs for equality by comparing their hash values.\n\nThis method implements equality comparison for Genomes structs by utilizing their hash values, ensuring that two genomes are considered equal if and only if they have identical structural properties and content.\n\nArguments\n\nx::Genomes: First Genomes struct to compare\ny::Genomes: Second Genomes struct to compare\n\nReturns\n\nBool: true if the genomes are equal, false otherwise\n\nExamples\n\njulia> genomes_1 = genomes = Genomes(n=2,p=4);\n\njulia> genomes_2 = genomes = Genomes(n=2,p=4);\n\njulia> genomes_3 = genomes = Genomes(n=1,p=2);\n\njulia> genomes_1 == genomes_2\ntrue\n\njulia> genomes_1 == genomes_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Phenomes, Phenomes}","page":"Home","title":"Base.:==","text":"==(x::Phenomes, y::Phenomes)::Bool\n\nCompare two Phenomes structs for equality using their hash values.\n\nThis method implements equality comparison for Phenomes objects by comparing their hash values, ensuring that two phenomes with identical structure and content are considered equal.\n\nArguments\n\nx::Phenomes: First phenomes object to compare\ny::Phenomes: Second phenomes object to compare\n\nReturns\n\nBool: true if the phenomes are equal, false otherwise\n\nExamples\n\njulia> phenomes_1 = phenomes = Phenomes(n=2, t=4);\n\njulia> phenomes_2 = phenomes = Phenomes(n=2, t=4);\n\njulia> phenomes_3 = phenomes = Phenomes(n=1, t=2);\n\njulia> phenomes_1 == phenomes_2\ntrue\n\njulia> phenomes_1 == phenomes_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{SimulatedEffects, SimulatedEffects}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::SimulatedEffects, y::SimulatedEffects)::Bool\n\nDefines equality comparison for SimulatedEffects structs by comparing their hash values.\n\nThis method overloads the == operator for SimulatedEffects type and determines if two SimulatedEffects instances are equal by comparing their hash values rather than doing a field-by-field comparison.\n\nArguments\n\nx::SimulatedEffects: First SimulatedEffects instance to compare\ny::SimulatedEffects: Second SimulatedEffects instance to compare\n\nReturns\n\nBool: true if the hash values of both instances are equal, false otherwise\n\nExamples\n\njulia> effects_1 = SimulatedEffects();\n\njulia> effects_2 = SimulatedEffects();\n\njulia> effects_3 = SimulatedEffects(); effects_3.id[1] = \"SOMETHING_ELSE\";\n\njulia> effects_1 == effects_2\ntrue\n\njulia> effects_1 == effects_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{TEBV, TEBV}","page":"Home","title":"Base.:==","text":"==(x::TEBV, y::TEBV)::Bool\n\nCompare two TEBV (Trial-Estimated Breeding Values) objects for equality.\n\nThis method implements equality comparison for TEBV structs by comparing their hash values. Two TEBV objects are considered equal if they have identical values for all their fields: traits, formulae, models, dfBLUEs, dfBLUPs, and phenomes.\n\nArguments\n\nx::TEBV: First TEBV object to compare\ny::TEBV: Second TEBV object to compare\n\nReturns\n\nBool: true if the TEBV objects are equal, false otherwise\n\nExamples\n\njulia> tebv_1 = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> tebv_2 = clone(tebv_1);\n\njulia> tebv_3 = TEBV(traits=[\"SOMETHING_ELSE\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> tebv_1 == tebv_2\ntrue\n\njulia> tebv_1 == tebv_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Trials, Trials}","page":"Home","title":"Base.:==","text":"==(x::Trials, y::Trials)::Bool\n\nCompare two Trials structs for equality by comparing their hash values.\n\nTwo Trials structs are considered equal if they have identical hash values, which implies they have the same configuration parameters (number of trials n and time steps t).\n\nArguments\n\nx::Trials: First Trials struct to compare\ny::Trials: Second Trials struct to compare\n\nReturns\n\nBool: true if the Trials structs are equal, false otherwise\n\nExamples\n\njulia> trials_1 = trials = Trials(n=2, t=4);\n\njulia> trials_2 = trials = Trials(n=2, t=4);\n\njulia> trials_3 = trials = Trials(n=1, t=2);\n\njulia> trials_1 == trials_2\ntrue\n\njulia> trials_1 == trials_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Genomes, Float64}","page":"Home","title":"Base.filter","text":"filter(\n    genomes::Genomes,\n    maf::Float64;\n    max_entry_sparsity::Float64 = 0.0,\n    max_locus_sparsity::Float64 = 0.0,\n    max_prop_pc_varexp::Float64 = 1.00,\n    max_entry_sparsity_percentile::Float64 = 0.90,\n    max_locus_sparsity_percentile::Float64 = 0.50,\n    chr_pos_allele_ids::Union{Nothing,Vector{String}} = nothing,\n    verbose::Bool = false\n)::Genomes\n\nFilter a Genomes struct based on multiple criteria.\n\nArguments\n\ngenomes::Genomes: Input genomic data structure\nmaf::Float64: Minimum allele frequency threshold (required)\nmax_entry_sparsity::Float64: Maximum allowed proportion of missing values per entry (default: 0.0)\nmax_locus_sparsity::Float64: Maximum allowed proportion of missing values per locus (default: 0.0)\nmax_prop_pc_varexp::Float64: Maximum proportion of variance explained by PC1 and PC2 for outlier detection. Set to Inf for no filtering by PCA. (default: 1.0)\nmax_entry_sparsity_percentile::Float64: Percentile threshold for entry sparsity filtering (default: 0.90)\nmax_locus_sparsity_percentile::Float64: Percentile threshold for locus sparsity filtering (default: 0.50)\nchr_pos_allele_ids::Union{Nothing,Vector{String}}: Optional vector of specific locus-allele combinations to retain,    formatted as tab-separated strings \"chromosome\\tposition\\tallele\"\nverbose::Bool: Whether to display progress bars during filtering (default: false)\n\nReturns\n\nGenomes: Filtered genomic data structure\n\nDetails\n\nFilters genomic data based on six criteria:\n\nMinimum allele frequency (MAF)\nMaximum entry sparsity (proportion of missing values per entry)\nMaximum locus sparsity (proportion of missing values per locus)\nEntry sparsity percentile threshold\nLocus sparsity percentile threshold\nPCA-based outlier detection using variance explained threshold\nSpecific locus-allele combinations (optional)\n\nThe percentile thresholds control how aggressively the sparsity filtering is applied:\n\nmax_entry_sparsity_percentile (default 0.90):\nControls what proportion of entries to keep in each iteration\nHigher values (e.g. 0.95) retain more entries but may require more iterations\nLower values (e.g. 0.75) remove more entries per iteration but may be too aggressive\nAdjust lower if dataset has many very sparse entries\nAdjust higher if trying to preserve more entries\nmax_locus_sparsity_percentile (default 0.50): \nControls what proportion of loci to keep in each iteration\nHigher values (e.g. 0.75) retain more loci but may require more iterations\nLower values (e.g. 0.25) remove more loci per iteration\nTypically set lower than entry percentile since loci are often more expendable\nAdjust based on tolerance for missing data vs. desire to retain markers\n\nThe iterative filtering will stop when either:\n\nAll sparsity thresholds are satisfied\nNo further filtering is possible without violating minimum thresholds\nDataset becomes too small for analysis\n\nNote that each filtering iteration includes multithreaded sparsity calculation and multithreaded genomes struct slicing.\n\nThrows\n\nArgumentError: If Genomes struct is corrupted, if MAF is outside [0,1], if sparsity thresholds are outside [0,1],    if percentile thresholds are outside [0,1], if maxproppcvarexp < 0, or if chrposalleleids format is invalid\nErrorException: If filtering results in empty dataset or if PCA cannot be performed due to insufficient data\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, sparsity=0.01, verbose=false);\n\njulia> filtered_genomes_1 = filter(genomes, 0.1);\n\njulia> filtered_genomes_2 = filter(genomes, 0.1, chr_pos_allele_ids=genomes.loci_alleles[1:1000]);\n\njulia> size(genomes.allele_frequencies)\n(100, 3000)\n\njulia> size(filtered_genomes_1.allele_frequencies)\n(92, 500)\n\njulia> size(filtered_genomes_2.allele_frequencies)\n(92, 145)\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Genomes}","page":"Home","title":"Base.filter","text":"filter(genomes::Genomes; verbose::Bool = false)::Genomes\n\nFilter a Genomes struct by removing entries and loci with missing data based on the mask matrix.\n\nDescription\n\nThis function filters a Genomes struct by:\n\nRemoving rows (entries) where any column has a false value in the mask matrix\nRemoving columns (loci) where any row has a false value in the mask matrix\n\nArguments\n\ngenomes::Genomes: Input Genomes struct containing genetic data and a mask matrix\nverbose::Bool: Optional flag to control verbose output (default: false)\n\nReturns\n\nGenomes: A new filtered Genomes struct with complete data (no missing values)\n\nExamples\n\njulia> genomes = simulategenomes(verbose=false); genomes.mask[1:10, 42:100] .= false;\n    \njulia> filtered_genomes = filter(genomes);\n\njulia> size(filtered_genomes.allele_frequencies)\n(90, 9941)\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Phenomes}","page":"Home","title":"Base.filter","text":"filter(phenomes::Phenomes)::Phenomes\n\nFilter a Phenomes struct by removing rows (entries) and columns (traits) as indicated by the mask matrix.  An entry or trait is removed if it contains at least one false value in the mask.\n\nArguments\n\nphenomes::Phenomes: The Phenomes struct to be filtered, containing entries, populations, traits, phenotypes, and a boolean mask matrix.\n\nReturns\n\nPhenomes: A new Phenomes struct with filtered entries and traits, where the mask matrix is all true.\n\nDetails\n\nThe function uses the mean of rows and columns in the mask matrix to identify which entries and traits should be kept. Only entries and traits with a mean of 1.0 (all true values) are retained in the filtered result.\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> phenomes.mask .= true; phenomes.mask[6:10, 1] .= false;\n    \njulia> filtered_phenomes = filter(phenomes);\n\njulia> size(filtered_phenomes.phenotypes)\n(5, 2)\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{CV, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::CV, h::UInt)::UInt\n\nCompute a hash value for a CV (Cross-Validation) struct.\n\nThis method defines how CV structs should be hashed, which is useful for using CV objects in hash-based collections like Sets or as Dict keys.\n\nArguments\n\nx::CV: The CV struct to be hashed\nh::UInt: The hash value to be mixed with the new hash\n\nReturns\n\nUInt: A hash value for the CV struct\n\nImplementation Details\n\nThe hash is computed by combining the following fields:\n\nreplication\nfold\nfit\nvalidation_populations\nvalidation_entries\nvalidationytrue\nvalidationypred\nmetrics\n\nExample\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> typeof(hash(cv))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Fit, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Fit, h::UInt)::UInt\n\nCalculate a hash value for a Fit struct.\n\nThis method implements hashing for the Fit type by combining the hashes of its core components in a specific order. The hash is computed using the following fields:\n\nmodel\nb_hat (estimated effects)\ntrait\nentries\npopulations\nmetrics\ny_true (observed values)\ny_pred (predicted values)\n\nArguments\n\nx::Fit: The Fit struct to be hashed\nh::UInt: The hash value to be mixed with\n\nReturns\n\nUInt: The computed hash value\n\nExample\n\njulia> fit = Fit(n=1, l=2);\n\njulia> typeof(hash(fit))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Genomes, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Genomes, h::UInt)::UInt\n\nCompute a hash value for a Genomes struct.\n\nThis hash function considers three key components of the Genomes struct:\n\nentries\npopulations\nloci_alleles\n\nFor performance reasons, allele_frequencies and mask fields are deliberately excluded  from the hash computation.\n\nArguments\n\nx::Genomes: The Genomes struct to hash\nh::UInt: The hash seed value\n\nReturns\n\nUInt: A hash value for the Genomes struct\n\nExamples\n\njulia> genomes = Genomes(n=2, p=2);\n\njulia> typeof(hash(genomes))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Phenomes, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Phenomes, h::UInt)::UInt\n\nCompute a hash value for a Phenomes struct by recursively hashing its internal fields.\n\nArguments\n\nx::Phenomes: The Phenomes struct to be hashed\nh::UInt: The hash value to be mixed with\n\nReturns\n\nUInt: A hash value for the entire Phenomes struct\n\nNote\n\nThis function is used for dictionary operations and computing hash-based data structures. The hash is computed by combining hashes of all internal fields: entries, populations, traits, phenotypes, and mask.\n\nExamples\n\njulia> phenomes = Phenomes(n=2, t=2);\n\njulia> typeof(hash(phenomes))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{SimulatedEffects, UInt64}","page":"Home","title":"Base.hash","text":"hash(x::SimulatedEffects, h::UInt)::UInt\n\nCompute a hash value for a SimulatedEffects object.\n\nThis method implements custom hashing for SimulatedEffects by iterating through all fields of the object and combining their hash values with the provided seed hash h.\n\nArguments\n\nx::SimulatedEffects: The object to be hashed\nh::UInt: The hash seed value\n\nReturns\n\nUInt: The computed hash value\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> typeof(hash(effects))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{TEBV, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::TEBV, h::UInt)::UInt\n\nCalculate a hash value for a TEBV (Trial-Estimated Breeding Value) struct.\n\nThis method implements hashing for TEBV objects by combining the hash values of selected fields:\n\ntraits: Vector of trait names\nformulae: Vector of formula strings\nphenomes: Vector of Phenomes objects\n\nNote: For performance reasons, the following fields are deliberately excluded from the hash calculation:\n\nmodels\ndf_BLUEs\ndf_BLUPs\n\nArguments\n\nx::TEBV: The TEBV struct to be hashed\nh::UInt: The hash value to be mixed with the object's hash\n\nReturns\n\nUInt: A unique hash value for the TEBV object\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> typeof(hash(tebv))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Trials, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Trials, h::UInt)::UInt\n\nCompute a hash value for a Trials struct by recursively hashing all of its fields.\n\nThis method implements hash functionality for the Trials type, allowing Trials  objects to be used as dictionary keys or in hash-based collections.\n\nArguments\n\nx::Trials: The Trials struct to be hashed\nh::UInt: The hash value to be mixed with the object's hash\n\nReturns\n\nUInt: A hash value for the entire Trials struct\n\nExamples\n\njulia> trials = Trials(n=2, t=2);\n\njulia> typeof(hash(trials))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Genomes, Genomes}","page":"Home","title":"Base.merge","text":"merge(\n    genomes::Genomes,\n    other::Genomes;\n    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),\n    verbose::Bool = true\n)::Genomes\n\nMerge two Genomes structs by combining their entries and loci_alleles while resolving conflicts in allele frequencies.\n\nArguments\n\ngenomes::Genomes: First Genomes struct to merge\nother::Genomes: Second Genomes struct to merge\nconflict_resolution::Tuple{Float64,Float64}: Weights for resolving conflicts between allele frequencies (must sum to 1.0)\nverbose::Bool: If true, displays a progress bar during merging\n\nReturns\n\nGenomes: A new Genomes struct containing the merged data\n\nDetails\n\nThe function performs the following operations:\n\nCombines unique entries and loci_alleles from both input structs\nResolves population conflicts by concatenating conflicting values\nFor overlapping entries and loci:\nIf allele frequencies match, uses the existing value\nIf frequencies differ, applies weighted average using conflict_resolution\nFor missing values, uses available non-missing value\nResolves mask conflicts using weighted average\n\nExamples\n\njulia> n = 100; l = 5_000; n_alleles = 2;\n\njulia> all = simulategenomes(n=n, l=l, n_alleles=n_alleles, verbose=false);\n\njulia> genomes = slice(all, idx_entries=collect(1:Int(floor(n*0.75))), idx_loci_alleles=collect(1:Int(floor(l*(n_alleles-1)*0.75))));\n\njulia> other = slice(all, idx_entries=collect(Int(floor(n*0.50)):n), idx_loci_alleles=collect(Int(floor(l*(n_alleles-1)*0.50)):l*(n_alleles-1)));\n\njulia> merged_genomes = merge(genomes, other, conflict_resolution=(0.75, 0.25), verbose=false);\n\njulia> size(merged_genomes.allele_frequencies)\n(100, 5000)\n\njulia> sum(ismissing.(merged_genomes.allele_frequencies))\n123725\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Genomes, Phenomes}","page":"Home","title":"Base.merge","text":"merge(genomes::Genomes, phenomes::Phenomes; keep_all::Bool=true)::Tuple{Genomes,Phenomes}\n\nMerge Genomes and Phenomes structs based on their entries, combining genomic and phenotypic data.\n\nArguments\n\ngenomes::Genomes: A struct containing genomic data including entries, populations, and allele frequencies\nphenomes::Phenomes: A struct containing phenotypic data including entries, populations, and phenotypes\nkeep_all::Bool=true: If true, performs a union of entries; if false, performs an intersection\n\nReturns\n\nTuple{Genomes,Phenomes}: A tuple containing:\nA new Genomes struct with merged entries and corresponding genomic data\nA new Phenomes struct with merged entries and corresponding phenotypic data\n\nDetails\n\nMaintains dimensional consistency between input and output structs\nHandles population conflicts by creating a combined population name\nPreserves allele frequencies and phenotypic data for matched entries\nWhen keep_all=true, includes all entries from both structs\nWhen keep_all=false, includes only entries present in both structs\n\nExamples\n\njulia> genomes = simulategenomes(n=10, verbose=false);\n\njulia> trials, effects = simulatetrials(genomes=slice(genomes, idx_entries=collect(1:5), idx_loci_alleles=collect(1:length(genomes.loci_alleles))), f_add_dom_epi=[0.90 0.05 0.05;], n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=2, verbose=false);\n\njulia> phenomes = Phenomes(n=5, t=1);\n\njulia> phenomes.entries = trials.entries[1:5];\n\njulia> phenomes.populations = trials.populations[1:5];\n\njulia> phenomes.traits = trials.traits;\n\njulia> phenomes.phenotypes = trials.phenotypes[1:5, :];\n\njulia> phenomes.mask .= true;\n\njulia> genomes_merged_1, phenomes_merged_1 = merge(genomes, phenomes, keep_all=true);\n\njulia> size(genomes_merged_1.allele_frequencies), size(phenomes_merged_1.phenotypes)\n((10, 10000), (10, 1))\n\njulia> genomes_merged_2, phenomes_merged_2 = merge(genomes, phenomes, keep_all=false);\n\njulia> size(genomes_merged_2.allele_frequencies), size(phenomes_merged_2.phenotypes)\n((5, 10000), (5, 1))\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Phenomes, Phenomes}","page":"Home","title":"Base.merge","text":"merge(\n    phenomes::Phenomes,\n    other::Phenomes;\n    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),\n    verbose::Bool = true\n)::Phenomes\n\nMerge two Phenomes structs into a single combined struct, handling overlapping entries and traits.\n\nArguments\n\nphenomes::Phenomes: The first Phenomes struct to merge\nother::Phenomes: The second Phenomes struct to merge\nconflict_resolution::Tuple{Float64,Float64}: Weights for resolving conflicts between overlapping values (must sum to 1.0)\nverbose::Bool: Whether to display a progress bar during merging\n\nReturns\n\nPhenomes: A new merged Phenomes struct containing all entries and traits from both input structs\n\nDetails\n\nThe merge operation combines:\n\nAll unique entries from both structs\nAll unique traits from both structs\nPhenotype values and masks, using weighted averaging for conflicts\nPopulation information, marking conflicts with a \"CONFLICT\" prefix\n\nFor overlapping entries and traits:\n\nIdentical values are preserved as-is\nDifferent values are combined using the weights specified in conflict_resolution\nMissing values are handled by using the available non-missing value\nPopulation conflicts are marked in the format \"CONFLICT (pop1, pop2)\"\n\nThrows\n\nArgumentError: If either Phenomes struct is corrupted (invalid dimensions)\nArgumentError: If conflict_resolution weights don't sum to 1.0 or aren't a 2-tuple\nErrorException: If the merging operation produces an invalid result\n\nExamples\n\njulia> all = Phenomes(n=10, t=3); all.entries = string.(\"entry_\", 1:10); all.traits = [\"A\", \"B\", \"C\"]; all.phenotypes = rand(10,3);\n\njulia> phenomes = slice(all, idx_entries=collect(1:7), idx_traits=[1,2]);\n\njulia> other = slice(all, idx_entries=collect(5:10), idx_traits=[2,3]);\n\njulia> merged_phenomes = merge(phenomes, other, conflict_resolution=(0.75, 0.25), verbose=false);\n\njulia> size(merged_phenomes.phenotypes)\n(10, 3)\n\njulia> sum(ismissing.(merged_phenomes.phenotypes))\n7\n\n\n\n\n\n","category":"method"},{"location":"#Base.sum-Tuple{SimulatedEffects}","page":"Home","title":"Base.sum","text":"sum(effects::SimulatedEffects)::Vector{Float64}\n\nSum up all simulated effects to generate the simulated phenotype values. The function iterates through all fields of the SimulatedEffects struct (except :id and :field_layout) and adds their values element-wise to produce a vector of phenotypic values.\n\nArguments\n\neffects::SimulatedEffects: A struct containing various genetic and environmental effects\n\nReturns\n\nVector{Float64}: A vector containing the summed effects (phenotypic values)\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> sum(effects)\n1-element Vector{Float64}:\n 0.0\n\njulia> effects.additive_genetic[1] = pi;\n\njulia> sum(effects)\n1-element Vector{Float64}:\n 3.141592653589793\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.addcompositetrait-Tuple{Phenomes}","page":"Home","title":"GBCore.addcompositetrait","text":"addcompositetrait(phenomes::Phenomes; composite_trait_name::String, formula_string::String)::Phenomes\n\nCreate a new composite trait by combining existing traits using mathematical operations.\n\nArguments\n\nphenomes::Phenomes: A Phenomes struct containing the original trait data\ncomposite_trait_name::String: Name for the new composite trait\nformula_string::String: Mathematical formula describing how to combine existing traits.  Supports traits as variables and the following operations:\nBasic arithmetic: +, -, *, /, ^, %\nFunctions: abs(), sqrt(), log(), log2(), log10()\nParentheses for operation precedence\n\nReturns\n\nPhenomes: A new Phenomes struct with the composite trait added as the last column\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3);\n\njulia> phenomes_new = addcompositetrait(phenomes, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"A\");\n\njulia> phenomes_new.phenotypes[:, end] == phenomes.phenotypes[:, 1]\ntrue\n\njulia> phenomes_new = addcompositetrait(phenomes, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"(A^B) + (C/A) - sqrt(abs(B-A)) + log(1.00 + C)\");\n\njulia> phenomes_new.phenotypes[:, end] == (phenomes.phenotypes[:,1].^phenomes.phenotypes[:,2]) .+ (phenomes.phenotypes[:,3]./phenomes.phenotypes[:,1]) .- sqrt.(abs.(phenomes.phenotypes[:,2].-phenomes.phenotypes[:,1])) .+ log.(1.00 .+ phenomes.phenotypes[:,3])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.addcompositetrait-Tuple{Trials}","page":"Home","title":"GBCore.addcompositetrait","text":"addcompositetrait(trials::Trials; composite_trait_name::String, formula_string::String)::Trials\n\nCreate a new composite trait by combining existing traits using a mathematical formula.\n\nArguments\n\ntrials::Trials: A Trials struct containing phenotypic data\ncomposite_trait_name::String: Name for the new composite trait\nformula_string::String: Mathematical formula defining how to combine existing traits\n\nFormula Syntax\n\nThe formula can include:\n\nTrait names (e.g., \"trait1\", \"trait2\")\nMathematical operators: +, -, *, /, ^, %\nFunctions: abs(), sqrt(), log(), log2(), log10()\nParentheses for grouping operations\n\nReturns\n\nTrials: A new Trials struct with the added composite trait\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> trials_new = addcompositetrait(trials, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"trait_1\");\n\njulia> trials_new.phenotypes[:, end] == trials.phenotypes[:, 1]\ntrue\n\njulia> trials_new = addcompositetrait(trials, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"(trait_1^(trait_2/100)) + (trait_3/trait_1) - sqrt(abs(trait_2-trait_1)) + log(1.00 + trait_3)\");\n\njulia> trials_new.phenotypes[:, end] == (trials.phenotypes[:,1].^(trials.phenotypes[:,2]/100)) .+ (trials.phenotypes[:,3]./trials.phenotypes[:,1]) .- sqrt.(abs.(trials.phenotypes[:,2].-trials.phenotypes[:,1])) .+ log.(1.00 .+ trials.phenotypes[:,3])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.analyse","page":"Home","title":"GBCore.analyse","text":"analyse(\n    trials::Trials,\n    formula_string::String = \"\";\n    traits::Union{Nothing,Vector{String}} = nothing,\n    max_levels::Int64 = 100,\n    max_time_per_model::Int64 = 60,\n    covariates_continuous::Union{Nothing,Vector{String}} = nothing,\n    verbose::Bool = true\n)::TEBV\n\nAnalyze trial data using linear mixed models to estimate Best Linear Unbiased Estimates (BLUEs)  and Best Linear Unbiased Predictions (BLUPs).\n\nArguments\n\ntrials: A Trials struct containing the experimental data\nformula_string: Optional model formula string. If empty, automatic model selection is performed\ntraits: Optional vector of trait names to analyze. If nothing, all traits are analyzed\nmax_levels: Maximum number of levels for non-entry random effects (default: 100)\nmax_time_per_model: Maximum fitting time in seconds per model (default: 60)\ncovariates_continuous: Optional vector of continuous covariates to include in models\nverbose: Whether to display analysis progress (default: true)\n\nReturns\n\nA TEBV struct containing:\n\ntraits: Vector of analyzed trait names\nformulae: Vector of best-fitting model formulae\nmodels: Vector of fitted LinearMixedModel objects\ndf_BLUEs: Vector of DataFrames containing BLUEs\ndf_BLUPs: Vector of DataFrames containing BLUPs\nphenomes: Vector of Phenomes objects with predicted values\n\nDetails\n\nThe function implements a mixed model fitting strategy with the following principles:\n\nAvoids over-parameterization\nUses unstructured variance-covariance matrix for random effects\nPrefers REML over ML estimation\nCompares BLUEs vs BLUPs of entries\nHandles both parallel and iterative model fitting based on model complexity\n\nNotes\n\nModels are fitted using REML\nSimple models are fitted in parallel while complex models are fitted iteratively to avoid memory issues\nReturns empty results if no models can be successfully fitted\n\nExamples\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);\n\njulia> tebv_1 = analyse(trials, \"trait_1 ~ 1 + (1|entries)\", max_levels=50, verbose=false);\n\njulia> tebv_1.traits\n3-element Vector{String}:\n \"trait_1\"\n \"trait_2\"\n \"trait_3\"\n\njulia> tebv_2 = analyse(trials, max_levels=50, verbose=false);\n\njulia> mean(tebv_2.phenomes[1].phenotypes) < mean(tebv_2.phenomes[2].phenotypes)\ntrue\n\njulia> trials = addcompositetrait(trials, composite_trait_name = \"covariate\", formula_string = \"(trait_1 + trait_2) / (trait_3 + 0.0001)\");\n\njulia> tebv_3 = Suppressor.@suppress analyse(trials, \"y ~ 1 + covariate + entries + (1|blocks)\", max_levels=50, verbose=false);\n\njulia> mean(tebv_3.phenomes[1].phenotypes) < mean(tebv_3.phenomes[2].phenotypes)\ntrue\n\njulia> tebv_4 = Suppressor.@suppress analyse(trials, max_levels=50, covariates_continuous=[\"covariate\"], verbose=false);\n\njulia> mean(tebv_4.phenomes[1].phenotypes) < mean(tebv_4.phenomes[2].phenotypes)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#GBCore.analyse-Tuple{DataFrames.DataFrame}","page":"Home","title":"GBCore.analyse","text":"analyse(\n    df::DataFrame; \n    formulae::Vector{String},\n    idx_parallel_models::Vector{Int64},\n    idx_iterative_models::Vector{Int64},\n    max_time_per_model::Int64 = 60,\n    verbose::Bool=false\n)::Tuple{String, Any, DataFrame, DataFrame, Phenomes}\n\nFit univariate linear mixed models to extract entry effects from the best-fitting model.\n\nArguments\n\ndf::DataFrame: Input data frame containing trial data with columns for entries, traits, and other experimental factors\nformulae::Vector{String}: Vector of model formulae strings to be tested\nidx_parallel_models::Vector{Int64}: Indices of simpler models to be fitted in parallel\nidx_iterative_models::Vector{Int64}: Indices of complex models to be fitted iteratively\nmax_time_per_model::Int64: Maximum time in seconds allowed for fitting each model (default: 60)\nverbose::Bool: Whether to display progress information (default: false)\n\nReturns\n\nA tuple containing:\n\nString: Formula of the best-fitting model\nAny: The fitted model object\nDataFrame: BLUEs (Best Linear Unbiased Estimates) results\nDataFrame: BLUPs (Best Linear Unbiased Predictions) results\nPhenomes: Struct containing consolidated phenotypic predictions\n\nDetails\n\nThe function implements a mixed model fitting strategy with the following principles:\n\nAvoids over-parameterization\nUses unstructured variance-covariance matrix for random effects\nPrefers REML over ML estimation\nCompares BLUEs vs BLUPs of entries\nHandles both parallel and iterative model fitting based on model complexity\n\nNotes\n\nAll formulae must model the same trait\nModels are fitted using REML\nSimple models are fitted in parallel while complex models are fitted iteratively to avoid memory issues\nReturns empty results if no models can be successfully fitted\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> formulae, n_levels = trialsmodelsfomulae!(df; trait = \"trait_1\", max_levels = 10);\n\njulia> idx_parallel_models::Vector{Int64} = findall(n_levels .<= (15));\n\njulia> idx_iterative_models::Vector{Int64} = findall((n_levels .<= (15)) .!= true);\n\njulia> formula_string, model, df_BLUEs, df_BLUPs, phenomes = analyse(df, formulae=formulae, idx_parallel_models=idx_parallel_models, idx_iterative_models=idx_iterative_models);\n\njulia> length(phenomes.entries) == length(unique(df.entries))\ntrue\n\njulia> df_2 = df[(df.years .== df.years[1]) .&& (df.harvests .== df.harvests[1]) .&& (df.seasons .== df.seasons[1]) .&& (df.sites .== df.sites[1]) .&& (df.replications .== df.replications[1]), :];\n\njulia> formula_string_2, model_2, df_BLUEs_2, df_BLUPs_2, phenomes_2 = analyse(df_2, formulae=[\"trait_1 ~ 1 + 1|entries\"]);\n\njulia> cor(phenomes_2.phenotypes[sortperm(phenomes_2.entries),1], df_2.trait_1[sortperm(df_2.entries)]) > 0.99\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{CV}","page":"Home","title":"GBCore.checkdims","text":"checkdims(cv::CV)::Bool\n\nCheck dimension compatibility of the fields of the CV struct.\n\nThe function verifies that:\n\nThe fit object dimensions are valid\nThe number of validation populations matches the number of validation entries\nThe number of validation true values matches the number of validation predictions\nThe number of metrics matches the number of metrics in the fit object\n\nReturns:\n\ntrue if all dimensions are compatible\nfalse if any dimension mismatch is found\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> checkdims(cv)\ntrue\n\njulia> cv.validation_y_true = [0.0, 0.0];\n\njulia> checkdims(cv)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{Fit}","page":"Home","title":"GBCore.checkdims","text":"checkdims(fit::Fit)::Bool\n\nCheck dimension compatibility of the internal fields of a Fit struct.\n\nThis function verifies that all vector fields in the Fit struct have compatible dimensions:\n\nLength of entries, populations, y_true, and y_pred must be equal (denoted as n)\nLength of b_hat and b_hat_labels must be equal (denoted as l)\n\nReturns true if all dimensions are compatible, false otherwise.\n\nArguments\n\nfit::Fit: The Fit struct to check dimensions for\n\nReturns\n\nBool: true if dimensions are compatible, false otherwise\n\nExamples\n\njulia> fit = Fit(n=1, l=4);\n\njulia> checkdims(fit)\ntrue\n\njulia> fit.b_hat_labels = [\"chr1\\t1\\tA|T\\tA\"];\n\njulia> checkdims(fit)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{Genomes}","page":"Home","title":"GBCore.checkdims","text":"checkdims(genomes::Genomes)::Bool\n\nCheck dimension compatibility of the fields in a Genomes struct.\n\nReturns true if all dimensions are compatible, false otherwise.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genomic data\n\nDetails\n\nVerifies that:\n\nNumber of entries matches number of populations (n)\nEntry names are unique\nNumber of loci alleles matches width of frequency matrix (p) \nLocus-allele combinations are unique\nEntries are unique\nDimensions of frequency matrix (nÃ—p) match mask matrix dimensions\n\nExamples\n\njulia> genomes = Genomes(n=2,p=4);\n\njulia> checkdims(genomes)\nfalse\n\njulia> genomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> genomes.loci_alleles = [\"chr1\\t1\\tA|T\\tA\", \"chr1\\t2\\tC|G\\tG\", \"chr2\\t3\\tA|T\\tA\", \"chr2\\t4\\tG|T\\tG\"];\n\njulia> checkdims(genomes)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{Phenomes}","page":"Home","title":"GBCore.checkdims","text":"checkdims(y::Phenomes)::Bool\n\nVerify dimensional compatibility between all fields of a Phenomes struct.\n\nChecks if:\n\nNumber of entries matches the number of rows in phenotypes matrix\nAll entry names are unique\nNumber of populations matches number of entries\nNumber of traits matches number of columns in phenotypes matrix\nAll trait names are unique\nDimensions of mask matrix match phenotypes matrix\n\nArguments\n\ny::Phenomes: A Phenomes struct containing phenotypic data\n\nReturns\n\nBool: true if all dimensions are compatible, false otherwise\n\nExamples\n\njulia> y = Phenomes(n=2, t=2);\n\njulia> checkdims(y)\nfalse\n\njulia> y.entries = [\"entry_1\", \"entry_2\"];\n\njulia> y.traits = [\"trait_1\", \"trait_2\"];\n\njulia> checkdims(y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{SimulatedEffects}","page":"Home","title":"GBCore.checkdims","text":"checkdims(effects::SimulatedEffects)::Bool\n\nCheck dimension compatibility of the fields of the SimulatedEffects struct.\n\nArguments\n\neffects::SimulatedEffects: A SimulatedEffects struct containing various genetic and experimental effects\n\nReturns\n\nBool: true if all dimensions are compatible, false otherwise\n\nVerifies that:\n\nid has length 6\nfield_layout has 4 columns \nAll following vectors have the same length (n):\nreplications_x_site_x_harvest_x_season_x_year\nblocks_x_site_x_harvest_x_season_x_year\nrows_x_site_x_harvest_x_season_x_year\ncols_x_site_x_harvest_x_season_x_year\nadditive_genetic\ndominance_genetic\nepistasis_genetic\nadditive_allele_x_site_x_harvest_x_season_x_year\ndominance_allele_x_site_x_harvest_x_season_x_year\nepistasis_allele_x_site_x_harvest_x_season_x_year\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> typeof(hash(effects))\nUInt64\n\njldoctest; setup = :(using GBCore) julia> effects = SimulatedEffects();\n\njulia> checkdims(effects) true\n\njulia> effects.id = [\"beaking_change\"];\n\njulia> checkdims(effects) false ```\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{TEBV}","page":"Home","title":"GBCore.checkdims","text":"checkdims(y::TEBV)::Bool\n\nCheck if all fields in the TEBV struct have compatible dimensions. The function verifies that the length of all arrays in the TEBV struct match the number of traits.\n\nArguments\n\ntebv::TEBV: A TEBV (Trial-estimated Breeding Values) struct containing traits, formulae, models, BLUEs, BLUPs, and phenomes.\n\nReturns\n\nBool: Returns true if all fields have matching dimensions (equal to the number of traits), false otherwise.\n\nDetails\n\nThe function checks if the following fields have the same length as traits:\n\nformulae\nunique models\nunique BLUEs DataFrames\nunique BLUPs DataFrames\nunique phenomes\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], dfBLUEs=[DataFrame(x=1)], dfBLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> checkdims(tebv) true ```\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.checkdims-Tuple{Trials}","page":"Home","title":"GBCore.checkdims","text":"checkdims(trials::Trials)::Bool\n\nCheck dimension compatibility of all fields in a Trials struct.\n\nThis function verifies that the dimensions of all vector fields in the Trials struct are  consistent with the size of the phenotypes matrix. Specifically, it checks:\n\nNumber of traits (t) matches number of columns in phenotypes and length of traits vector\nNumber of entries (n) matches number of rows in phenotypes and length of:\nyears\nseasons\nharvests\nsites\nreplications\nblocks\nrows\ncols\nentries\npopulations\n\nReturns true if all dimensions are compatible, false otherwise.\n\nArguments\n\ntrials::Trials: A Trials struct containing trial data\n\nReturns\n\nBool: true if dimensions are compatible, false otherwise\n\nExamples\n\njulia> trials = Trials(n=1, t=2);\n\njulia> trials.entries = [\"entry_1\"]; trials.traits = [\"trait_1\", \"trait_2\"];\n\njulia> checkdims(trials)\ntrue\n\njulia> trials.entries = [\"entering_2_entries\", \"instead_of_just_1\"];\n\njulia> checkdims(trials)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{CV}","page":"Home","title":"GBCore.clone","text":"clone(x::CV)::CV\n\nCreate a deep copy of a CV (cross-validation) object.\n\nCreates a new CV object with deep copies of all fields from the input object. The clone function ensures that modifications to the cloned object do not affect  the original object.\n\nArguments\n\nx::CV: The CV object to be cloned\n\nReturns\n\nCV: A new CV object containing deep copies of all fields from the input\n\nExample\n\nClone a CV object\n\nExample\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> copy_cv = clone(cv)\nCV(\"replication_1\", \"fold_1\", Fit(\"\", [\"\", \"\"], [0.0, 0.0], \"\", [\"\"], [\"\"], [0.0], [0.0], Dict(\"\" => 0.0), nothing), [\"population_1\"], [\"entry_1\"], [0.0], [0.0], Dict(\"\" => 0.0))\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{Fit}","page":"Home","title":"GBCore.clone","text":"clone(x::Fit)::Fit\n\nCreate a deep copy of a Fit object, duplicating all its fields.\n\nThis function performs a deep clone of the input Fit object, ensuring that all nested structures and arrays are also copied, preventing any shared references between the original and the cloned object.\n\nArguments\n\nx::Fit: The Fit object to be cloned\n\nReturns\n\nFit: A new Fit object with identical but independent values\n\nFields copied\n\nmodel: The statistical model\nb_hat_labels: Labels for the estimated parameters\nb_hat: Estimated parameters\ntrait: The trait being analyzed\nentries: Entry identifiers\npopulations: Population identifiers\nmetrics: Performance metrics\ny_true: Observed values\ny_pred: Predicted values\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> copy_fit = clone(fit)\nFit(\"\", [\"\", \"\"], [0.0, 0.0], \"\", [\"\"], [\"\"], [0.0], [0.0], Dict(\"\" => 0.0), nothing)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{Genomes}","page":"Home","title":"GBCore.clone","text":"clone(x::Genomes)::Genomes\n\nCreate a deep copy of a Genomes object.\n\nThis function performs a deep clone of all fields in the Genomes object, including:\n\nentries\npopulations \nloci_alleles\nallele_frequencies\nmask\n\nReturns a new Genomes instance with identical but independent data.\n\nArguments\n\nx::Genomes: The source Genomes object to clone\n\nReturns\n\nGenomes: A new Genomes object containing deep copies of all fields\n\nExample\n\njulia> genomes = Genomes(n=2, p=2);\n\njulia> copy_genomes = clone(genomes)\nGenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{Phenomes}","page":"Home","title":"GBCore.clone","text":"clone(x::Phenomes)::Phenomes\n\nCreate a deep copy of a Phenomes object, including all its fields.\n\nThis function performs a deep copy of the following fields:\n\nentries: Vector of entry names\npopulations: Vector of population identifiers\ntraits: Vector of trait names\nphenotypes: Matrix of phenotypic values\nmask: Matrix of boolean masks\n\nReturns a new Phenomes object with identical structure but independent memory allocation.\n\nArguments\n\nx::Phenomes: The source Phenomes object to be cloned\n\nReturns\n\nPhenomes: A new Phenomes object containing deep copies of all fields\n\nExample\n\njulia> phenomes = Phenomes(n=2, t=2);\n\njulia> copy_phenomes = clone(phenomes)\nPhenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{TEBV}","page":"Home","title":"GBCore.clone","text":"clone(x::TEBV)::TEBV\n\nCreate a deep copy of a TEBV (Trial-Estimated Breeding Value) object.\n\nReturns a new TEBV instance with all fields deeply copied from the input object, ensuring complete independence between the original and cloned objects.\n\nArguments\n\nx::TEBV: The source TEBV object to be cloned\n\nReturns\n\nTEBV: A new TEBV object containing deep copies of all fields from the input\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> copy_tebv = clone(tebv);\n\njulia> copy_tebv.traits == tebv.traits\ntrue\n\njulia> copy_tebv.phenomes == tebv.phenomes\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.clone-Tuple{Trials}","page":"Home","title":"GBCore.clone","text":"clone(x::Trials)::Trials\n\nCreate a deep copy of a Trials object, including all its fields.\n\nThis function performs a complete deep copy of the input Trials object, ensuring that all nested data structures are also copied rather than referenced.\n\nArguments\n\nx::Trials: The source Trials object to be cloned\n\nReturns\n\nTrials: A new Trials object containing copies of all data from the input\n\nExample\n\njulia> trials = Trials(n=2, t=2);\n\njulia> copy_trials = clone(trials)\nTrials(Union{Missing, Float64}[missing missing; missing missing], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"])\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.countlevels-Tuple{DataFrames.DataFrame}","page":"Home","title":"GBCore.countlevels","text":"countlevels(df::DataFrame; column_names::Vector{String})::Int64\n\nCount the total number of unique values (factor levels) across specified columns in a DataFrame.\n\nArguments\n\ndf::DataFrame: Input DataFrame to analyze\ncolumn_names::Vector{String}: Vector of column names to count unique values from\n\nReturns\n\nInt64: Sum of unique values across all specified columns\n\nThrows\n\nArgumentError: If any of the specified column names are not found in the DataFrame\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.dimensions-Tuple{Genomes}","page":"Home","title":"GBCore.dimensions","text":"dimensions(genomes::Genomes)::Dict{String, Int64}\n\nCalculate various dimensional metrics of a Genomes struct.\n\nReturns a dictionary containing the following metrics:\n\n\"n_entries\": Number of unique entries/samples\n\"n_populations\": Number of unique populations\n\"n_loci_alleles\": Total number of loci-allele combinations\n\"n_chr\": Number of chromosomes\n\"n_loci\": Number of unique loci across all chromosomes\n\"max_n_alleles\": Maximum number of alleles observed at any locus\n\"n_missing\": Count of missing values in allele frequencies\n\nArguments\n\ngenomes::Genomes: A valid Genomes struct containing genetic data\n\nReturns\n\nDict{String,Int64}: Dictionary containing dimensional metrics\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted (fails dimension check)\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> dimensions(genomes)\nDict{String, Int64} with 7 entries:\n  \"n_entries\"      => 100\n  \"n_chr\"          => 7\n  \"n_loci\"         => 1000\n  \"n_loci_alleles\" => 3000\n  \"n_populations\"  => 1\n  \"n_missing\"      => 0\n  \"max_n_alleles\"  => 4\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.dimensions-Tuple{Phenomes}","page":"Home","title":"GBCore.dimensions","text":"dimensions(phenomes::Phenomes)::Dict{String, Int64}\n\nCalculate various dimensional statistics of a Phenomes struct.\n\nReturns a dictionary containing counts of:\n\n\"n_entries\": unique entries in the dataset\n\"n_populations\": unique populations\n\"n_traits\": number of traits\n\"n_total\": total number of phenotypic observations (entries Ã— traits)\n\"n_zeroes\": number of zero values in phenotypes\n\"n_missing\": number of missing values\n\"n_nan\": number of NaN values\n\"n_inf\": number of infinite values\n\nArguments\n\nphenomes::Phenomes: A Phenomes struct containing phenotypic data\n\nReturns\n\nDict{String,Int64}: Dictionary with dimensional statistics\n\nThrows\n\nArgumentError: If the Phenomes struct dimensions are inconsistent\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> dimensions(phenomes)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 30\n  \"n_zeroes\"      => 30\n  \"n_nan\"         => 0\n  \"n_entries\"     => 10\n  \"n_traits\"      => 3\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 0\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.dimensions-Tuple{TEBV}","page":"Home","title":"GBCore.dimensions","text":"dimensions(tebv::TEBV)::Dict{String, Int64}\n\nCalculate various dimensional metrics for a TEBV (Trial-Estimated Breeding Values) struct.\n\nArguments\n\ntebv::TEBV: A TEBV struct containing traits, formulae, models, BLUEs, BLUPs, and phenomes data\n\nReturns\n\nA dictionary containing the following counts:\n\n\"n_entries\": Number of unique entries across all phenomes\n\"n_populations\": Number of unique populations across all phenomes\n\"n_traits\": Number of traits in the TEBV struct\n\"n_total\": Total number of observations across all traits\n\"n_zeroes\": Total number of zero values across all traits\n\"n_missing\": Total number of missing values across all traits\n\"n_nan\": Total number of NaN values across all traits\n\"n_inf\": Total number of Infinite values across all traits\n\nThrows\n\nArgumentError: If the TEBV struct dimensions are inconsistent or corrupted\n\nExamples\n\njulia> tebv = TEBV(traits=[\"trait_1\"], formulae=[\"trait_1 ~ 1 + 1|entries\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> dimensions(tebv)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 1\n  \"n_zeroes\"      => 0\n  \"n_nan\"         => 0\n  \"n_entries\"     => 1\n  \"n_traits\"      => 1\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 1\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.dimensions-Tuple{Trials}","page":"Home","title":"GBCore.dimensions","text":"dimensions(trials::Trials)::Dict{String, Int64}\n\nCalculate dimensional statistics of a Trials struct, returning a dictionary with counts of various elements.\n\nArguments\n\ntrials::Trials: A Trials struct containing trial data\n\nReturns\n\nA Dict{String, Int64} with the following keys:\n\n\"n_traits\": Number of unique traits\n\"n_years\": Number of unique years\n\"n_seasons\": Number of unique seasons\n\"n_harvests\": Number of unique harvests\n\"n_sites\": Number of unique sites\n\"n_replications\": Number of unique replications\n\"n_blocks\": Number of unique blocks\n\"n_rows\": Number of unique rows\n\"n_cols\": Number of unique columns\n\"n_entries\": Number of unique entries\n\"n_populations\": Number of unique populations\n\"n_total\": Total number of phenotype observations (entries Ã— traits)\n\"n_zeroes\": Count of zero values in phenotypes\n\"n_missing\": Count of missing values in phenotypes\n\"n_nan\": Count of NaN values in phenotypes\n\"n_inf\": Count of Inf values in phenotypes\n\nThrows\n\nArgumentError: If the Trials struct dimensions are inconsistent\n\nExamples\n\njulia> trials = Trials(n=1, t=2);\n\njulia> trials.entries = [\"entry_1\"]; trials.traits = [\"trait_1\", \"trait_2\"];\n\njulia> dimensions(trials)\nDict{String, Int64} with 16 entries:\n  \"n_zeroes\"       => 0\n  \"n_harvests\"     => 1\n  \"n_nan\"          => 0\n  \"n_entries\"      => 1\n  \"n_traits\"       => 2\n  \"n_seasons\"      => 1\n  \"n_rows\"         => 1\n  \"n_blocks\"       => 1\n  \"n_missing\"      => 2\n  \"n_inf\"          => 0\n  \"n_total\"        => 2\n  \"n_replications\" => 1\n  \"n_years\"        => 1\n  \"n_sites\"        => 1\n  \"n_cols\"         => 1\n  \"n_populations\"  => 1\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.distances-Tuple{Genomes}","page":"Home","title":"GBCore.distances","text":"distances(\n    genomes::Genomes; \n    distance_metrics::Vector{String}=[\"euclidean\", \"correlation\", \"mad\", \"rmsd\", \"Ï‡Â²\"],\n    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,\n    include_loci_alleles::Bool = true,\n    include_entries::Bool = true,\n    include_counts::Bool = true,\n    verbose::Bool = false\n)::Tuple{Vector{String},Vector{String},Dict{String,Matrix{Float64}}}\n\nCalculate pairwise distances/similarity metrics between loci-alleles and entries in a Genomes object.\n\nArguments\n\ngenomes::Genomes: Input Genomes object\ndistance_metrics::Vector{String}: Vector of distance metrics to calculate. Valid options:\n\"euclidean\": Euclidean distance\n\"correlation\": Pearson correlation coefficient \n\"mad\": Mean absolute deviation\n\"rmsd\": Root mean square deviation \n\"Ï‡Â²\": Chi-square distance\nidx_loci_alleles::Union{Nothing, Vector{Int64}}: Optional indices of loci-alleles to include. If nothing, randomly samples 100 loci-alleles.\ninclude_loci_alleles::Bool: Whether to calculate distances between loci-alleles. Defaults to true.\ninclude_entries::Bool: Whether to calculate distances between entries. Defaults to true.\ninclude_counts::Bool: Whether to include matrices showing number of valid pairs used. Defaults to true.\nverbose::Bool: Whether to show progress bars. Defaults to false.\n\nReturns\n\nTuple containing:\n\nVector of loci-allele names used\nVector of entry names  \nDictionary mapping \"{dimension}|{metric}\" to distance matrices, where:\ndimension is either \"loci_alleles\" or \"entries\"\nmetric is one of the distance metrics or \"counts\" (number of valid pairs used)\nmatrices contain pairwise distances/correlations (-Inf where insufficient data)\n\nDetails\n\nFor loci-alleles, calculates distances between allele frequency profiles across entries\nFor entries, calculates distances between entries based on their allele frequencies\nRequires at least 2 valid (non-missing, finite) pairs to calculate metrics\nIncludes count matrices showing number of valid pairs used per calculation\nMulti-threaded implementation which uses indexing on pre-allocated vectors and matrices which should avoid data races\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> (loci_alleles_names, entries, dist) = distances(genomes, distance_metrics=[\"correlation\", \"Ï‡Â²\"]);\n\njulia> sort(string.(keys(dist))) == [\"entries|correlation\", \"entries|counts\", \"entries|Ï‡Â²\", \"loci_alleles|correlation\", \"loci_alleles|counts\", \"loci_alleles|Ï‡Â²\"]\ntrue\n\njulia> C = dist[\"entries|correlation\"]; C[diagind(C)] == repeat([1], length(genomes.entries))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.distances-Tuple{Phenomes}","page":"Home","title":"GBCore.distances","text":"distances(\n    phenomes::Phenomes; \n    distance_metrics::Vector{String}=[\"euclidean\", \"correlation\", \"mad\", \"rmsd\", \"Ï‡Â²\"],\n    standardise_traits::Bool = false\n)::Tuple{Vector{String}, Vector{String}, Dict{String, Matrix{Float64}}}\n\nCalculate pairwise distances/correlations between traits and entries in a phenotypic dataset.\n\nArguments\n\nphenomes::Phenomes: A Phenomes struct containing phenotypic data\ndistance_metrics::Vector{String}: Vector of distance metrics to compute. Valid options are:\n\"euclidean\": Euclidean distance\n\"correlation\": Pearson correlation coefficient\n\"mad\": Mean absolute deviation\n\"rmsd\": Root mean square deviation\n\"Ï‡Â²\": Chi-square distance\nstandardise_traits::Bool: If true, standardizes traits to mean=0 and sd=1 before computing distances\n\nReturns\n\nA tuple containing:\n\nVector of trait names\nVector of entry names\nDictionary mapping \"{dimension}|{metric}\" to distance matrices, where:\ndimension âˆˆ [\"traits\", \"entries\"]\nmetric âˆˆ distance_metrics âˆª [\"counts\"]\n\"counts\" matrices contain the number of non-missing pairs used in calculations\n\nNotes\n\nPairs with fewer than 2 non-missing values result in -Inf distance values\nFor correlation calculations, traits with near-zero variance (< 1e-7) are skipped\nÏ‡Â² distance adds machine epsilon to denominator to avoid division by zero\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3); phenomes.phenotypes[2,2] = missing;\n\njulia> (traits, entries, dist) = distances(phenomes, distance_metrics=[\"correlation\", \"Ï‡Â²\"]);\n\njulia> sort(string.(keys(dist))) == [\"entries|correlation\", \"entries|counts\", \"entries|Ï‡Â²\", \"traits|correlation\", \"traits|counts\", \"traits|Ï‡Â²\"]\ntrue\n\njulia> C = dist[\"entries|correlation\"]; C[diagind(C)] == repeat([1], length(phenomes.entries))\ntrue\n\njulia> dist[\"traits|counts\"][:, 2] == dist[\"traits|counts\"][2, :] == repeat([9], length(phenomes.traits))\ntrue\n\njulia> dist[\"entries|counts\"][:, 2] == dist[\"entries|counts\"][2, :] == repeat([2], length(phenomes.entries))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.divideintomockscaffolds-Tuple{Genomes}","page":"Home","title":"GBCore.divideintomockscaffolds","text":"divideintomockscaffolds(genomes::Genomes; max_n_loci_per_chrom::Int64 = 100_000, verbose::Bool = false)::Vector{String}\n\nDivide genomic loci into mock scaffolds based on a maximum number of loci per chromosome.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genomic data\nmax_n_loci_per_chrom::Int64: Maximum number of loci per chromosome (default: 100,000)\nverbose::Bool: If true, prints additional information during execution (default: false)\n\nReturns\n\nVector{String}: A vector containing mock scaffold assignments for each locus\n\nDescription\n\nThis function takes a Genomes struct and divides the loci into mock scaffolds based on the  specified maximum number of loci per chromosome. It creates scaffold names in the format  \"mockscaffoldX\" where X is the scaffold number.\n\nThrows\n\nArgumentError: If the Genomes struct dimensions are invalid or corrupted\n\nExample\n\njulia> genomes = simulategenomes(n=10, sparsity=0.3, verbose=false);\n\njulia> mock_scaffolds = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);\n\njulia> sum(mock_scaffolds .== mock_scaffolds[1]) == Int64(length(genomes.loci_alleles) / 100)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.estimateld-Tuple{Genomes}","page":"Home","title":"GBCore.estimateld","text":"estimateld(genomes::Genomes; chromosomes::Union{Nothing, Vector{String}} = nothing, verbose::Bool=false)::Vector{Matrix{Float64}}\n\nCalculate linkage disequilibrium (LD) matrices for each chromosome in the given genomic data.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genomic data\nchromosomes::Union{Nothing, Vector{String}}: Optional vector of chromosome names to analyze. If nothing, all chromosomes in the data will be used\nverbose::Bool: If true, prints progress information during computation\n\nReturns\n\nVector{Matrix{Float64}}: A vector of correlation matrices, one for each unique chromosome, containing pairwise LD values between loci\n\nExamples\n\njulia> genomes = simulategenomes(n=10, l=1_000, sparsity=0.3, verbose=false);\n\njulia> LDs_all_chroms = estimateld(genomes);\n\njulia> chrom, pos, allele = loci_alleles(genomes);\n\njulia> mock_scaffolds = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);\n\njulia> LDs_mock_chroms = estimateld(genomes, chromosomes=mock_scaffolds);\n\njulia> length(LDs_all_chroms) == length(unique(chrom))\ntrue\n\njulia> length(LDs_mock_chroms) == Int(length(chrom) / 100)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.extractphenomes-Tuple{TEBV}","page":"Home","title":"GBCore.extractphenomes","text":"extractphenomes(tebv::TEBV)::Phenomes\n\nExtract phenotypic values from a Trial-Estimated Breeding Value (TEBV) object.\n\nThis function processes phenotypic data from a TEBV object, handling intercept effects and merging multiple phenomes if present. It performs the following operations:\n\nValidates input TEBV dimensions\nProcesses intercept effects if present by:\nIdentifying intercept terms\nCombining intercept values with trait effects\nAdjusting trait names and phenotypic values accordingly\nMerges multiple phenomes if present\nRenames traits to match input TEBV traits if dimensions align\nValidates output Phenomes dimensions\n\nArguments\n\ntebv::TEBV: A Trial Estimated Breeding Value object containing phenotypic data\n\nReturns\n\nPhenomes: A Phenomes object containing processed phenotypic values\n\nThrows\n\nArgumentError: If input TEBV or output Phenomes dimensions are invalid\n\nExamples\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);\n\njulia> tebv = analyse(trials, max_levels=50, verbose=false);\n\njulia> phenomes = extractphenomes(tebv);\n\njulia> phenomes.traits == [\"trait_1\", \"trait_2\", \"trait_3\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.extractphenomes-Tuple{Trials}","page":"Home","title":"GBCore.extractphenomes","text":"extractphenomes(trials::Trials)::Phenomes\n\nConvert a Trials struct into a Phenomes struct by extracting phenotypic values across different environments.\n\nDetails\n\nCombines trait measurements with their environmental contexts\nCreates unique trait identifiers by combining trait names with environment variables\nEnvironment variables include: years, harvests, seasons, sites, and replications\nFor single environment scenarios, trait names remain without environmental suffixes\n\nArguments\n\ntrials::Trials: A Trials struct containing phenotypic measurements across different environments\n\nReturns\n\nA Phenomes struct containing:\nphenotypes: Matrix of phenotypic values (entries Ã— traits)\nentries: Vector of entry names\npopulations: Vector of population names\ntraits: Vector of trait names (with environmental contexts)\n\nThrows\n\nArgumentError: If duplicate entries exist within year-harvest-season-site-replication combinations\nErrorException: If dimensional validation fails during Phenomes construction\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> size(phenomes.phenotypes)\n(100, 384)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.histallelefreqs-Tuple{Genomes}","page":"Home","title":"GBCore.histallelefreqs","text":"histallelefreqs(genomes::Genomes)::Nothing\n\nPlot a histogram of allele frequencies from a Genomes object.\n\nArguments\n\ngenomes::Genomes: A Genomes object containing allele frequency data in its allele_frequencies field\n\nReturns\n\nNothing: Displays a histogram plot and returns nothing\n\nDescription\n\nCreates and displays a vertical histogram of non-missing allele frequencies using UnicodePlots. The histogram shows frequency distribution in the range [0,1] with 50 bins.\n\nExample\n\njulia> genomes = simulategenomes(n=100, l=10_000, n_alleles=3, n_populations=3, verbose=false);\n\njulia> histallelefreqs(genomes)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.loci-Tuple{Genomes}","page":"Home","title":"GBCore.loci","text":"loci(genomes::Genomes; verbose::Bool = false)::Tuple{Vector{String},Vector{Int64},Vector{Int64},Vector{Int64}}\n\nExtract genomic positional information from a Genomes object, returning a tuple of vectors containing chromosome names, positions, and locus boundary indices.\n\nArguments\n\ngenomes::Genomes: A Genomes object containing genomic data\nverbose::Bool = false: If true, displays a progress bar during computation\n\nReturns\n\nA tuple containing four vectors:\n\nchromosomes::Vector{String}: Names of chromosomes\npositions::Vector{Int64}: Positions within chromosomes\nloci_ini_idx::Vector{Int64}: Starting indices for each locus\nloci_fin_idx::Vector{Int64}: Ending indices for each locus\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> chromosomes, positions, loci_ini_idx, loci_fin_idx = loci(genomes);\n\njulia> length(chromosomes), length(positions), length(loci_ini_idx), length(loci_fin_idx)\n(1000, 1000, 1000, 1000)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.loci_alleles-Tuple{Genomes}","page":"Home","title":"GBCore.loci_alleles","text":"loci_alleles(genomes::Genomes; verbose::Bool = false)::Tuple{Vector{String},Vector{Int64},Vector{String}}\n\nExtract chromosomes, positions, and alleles information from a Genomes object.\n\nReturns a tuple of three vectors containing:\n\nChromosomes identifiers as strings\nBase-pair positions as integers\nAllele identifiers as strings\n\nEach vector has length equal to the total number of loci-allele combinations in the genome. The function processes the data in parallel using multiple threads for performance optimization.\n\nArguments\n\ngenomes::Genomes: A valid Genomes object containing loci and allele information\nverbose::Bool = false: If true, displays a progress bar during extraction\n\nReturns\n\nTuple{Vector{String},Vector{Int64},Vector{String}}: A tuple containing three vectors:\nchromosomes: Vector of chromosome identifiers\npositions: Vector of base-pair positions\nalleles: Vector of allele identifiers\n\nThrows\n\nArgumentError: If the Genomes struct dimensions are invalid or corrupted\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> chromosomes, positions, alleles = loci_alleles(genomes);\n\njulia> length(chromosomes), length(positions), length(alleles)\n(3000, 3000, 3000)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.maskmissing!-Tuple{Genomes}","page":"Home","title":"GBCore.maskmissing!","text":"maskmissing!(genomes::Genomes; verbose::Bool = false)\n\nUpdate the mask matrix for missing values in the genomes struct.\n\nThis function updates the mask matrix in a Genomes struct by marking positions where allele frequencies are not missing. The mask is set to true for non-missing values and false for missing values.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genomic data including allele frequencies and mask matrix\nverbose::Bool=false: If true, displays a progress bar during computation\n\nThrows\n\nArgumentError: If the dimensions in the Genomes struct are inconsistent\n\nEffects\n\nModifies the mask field of the input genomes struct in-place\n\nThreads\n\nUses multi-threading for parallel computation across loci\nUses a thread lock for safe concurrent access to shared memory\n\nExample\n\njulia> genomes = simulategenomes(n=10, sparsity=0.3, verbose=false);\n\njulia> round(1.00 - mean(genomes.mask), digits=10)\n0.0\n\njulia> maskmissing!(genomes);\n\njulia> round(1.00 - mean(genomes.mask), digits=10)\n0.3\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.plot","page":"Home","title":"GBCore.plot","text":"plot(genomes::Genomes, seed::Int64 = 42)::Nothing\n\nGenerate visualization plots for allele frequencies in genomic data.\n\nFor each population in the dataset, creates three plots:\n\nHistogram of per-entry allele frequencies\nHistogram of mean allele frequencies per locus\nCorrelation heatmap of allele frequencies between loci\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing allele frequency data\nseed::Int64=42: Random seed for reproducibility of sampling loci\n\nReturns\n\nNothing: Displays plots but doesn't return any value\n\nNotes\n\nUses up to 100 randomly sampled loci for visualization\nHandles missing values in the data\nDisplays folded frequency spectra (both q and 1-q)\nWill throw ArgumentError if the Genomes struct is corrupted\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> GBCore.plot(genomes)\n\n\n\n\n\n\n","category":"function"},{"location":"#GBCore.plot-2","page":"Home","title":"GBCore.plot","text":"plot(fit::Fit, distribution::Any=[TDist(1), Normal()][2], Î±::Float64=0.05)\n\nGenerate diagnostic plots for genetic association analysis results.\n\nArguments\n\nfit::Fit: A Fit object containing the association analysis results, specifically the b_hat field with effect sizes\ndistribution::Any: The null distribution for p-value calculation. Defaults to Normal distribution\nÎ±::Float64: Significance level for multiple testing correction (Bonferroni). Defaults to 0.05\n\nReturns\n\nDisplays three plots:\n\nHistogram showing the distribution of effect sizes\nManhattan plot showing -log10(p-values) across loci with Bonferroni threshold\nQ-Q plot comparing observed vs expected -log10(p-values)\n\nExamples\n\njulia> distribution = [TDist(1), Normal()][2];\n\njulia> fit = Fit(n=100, l=10_000); fit.b_hat = rand(distribution, 10_000);  Î± = 0.05;\n\njulia> GBCore.plot(fit);\n\n\n\n\n\n","category":"function"},{"location":"#GBCore.plot-Tuple{Phenomes}","page":"Home","title":"GBCore.plot","text":"plot(phenomes::Phenomes; nbins::Int64 = 10)::Nothing\n\nGenerate diagnostic plots for phenotypic data stored in a Phenomes struct.\n\nArguments\n\nphenomes::Phenomes: A Phenomes struct containing phenotypic data\nnbins::Int64=10: Number of bins for the histograms (optional)\n\nDescription\n\nFor each population in the dataset:\n\nCreates histograms showing the distribution of each trait\nGenerates a heatmap of trait correlations for traits with non-zero variance\n\nNotes\n\nSkips traits with all missing, NaN, or infinite values\nOnly includes traits with variance > 1e-10 in correlation analysis\nRequires at least 3 data points to generate a histogram\nUses UnicodePlots for visualization in terminal\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3);\n\njulia> GBCore.plot(phenomes);\n\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.plot-Tuple{TEBV}","page":"Home","title":"GBCore.plot","text":"plot(tebv::TEBV)\n\nCreate a visualization of True Estimated Breeding Values (TEBV) analysis results.\n\nThis function extracts phenomes from the TEBV object and generates a plot to visualize the breeding value estimates.\n\nArguments\n\ntebv::TEBV: A TEBV object containing the analysis results\n\nReturns\n\nA plot object representing the visualization of the phenomes data\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.plot-Tuple{Trials}","page":"Home","title":"GBCore.plot","text":"plot(trials::Trials; nbins::Int64 = 10)::Nothing\n\nGenerate a comprehensive visualization of trial data through histograms, correlation heatmaps, and bar plots.\n\nArguments\n\ntrials::Trials: A Trials struct containing the trial data to be visualized\nnbins::Int64=10: Number of bins for the histogram plots (optional)\n\nDetails\n\nThe function creates three types of plots:\n\nHistograms for each trait within each population, showing the distribution of trait values\nCorrelation heatmaps between traits for each population\nBar plots showing mean trait values across different trial factors:\nYears\nSeasons\nHarvests\nSites\nReplications\nRows\nColumns\nPopulations\n\nMissing, NaN, or infinite values are automatically filtered out before plotting.\n\nReturns\n\nNothing: The function displays plots but does not return any value\n\nNotes\n\nRequires valid trial data with non-zero variance for correlation plots\nUses UnicodePlots for visualization in terminal\nSkips plotting for traits with insufficient data points\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> GBCore.plot(trials);\n\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulateeffects-Tuple{}","page":"Home","title":"GBCore.simulateeffects","text":"simulateeffects(; p::Int64 = 2, q::Int64 = 1, Î»::Float64 = 1.00, seed::Int64 = 42)::Matrix{Float64}\n\nSimulate correlated effects by sampling from a multivariate normal distribution.\n\nThis function generates a matrix of correlated effects by:\n\nSampling means (Î¼) from an exponential distribution with parameter Î»\nCreating a covariance matrix Î£ = Î¼Î¼'\nDrawing samples from MvNormal(Î¼, Î£)\nEnsuring numerical stability by adjusting the covariance matrix if necessary\n\nArguments\n\np::Int64: Number of correlated effects to simulate (default = 2)\nq::Int64: Number of times to simulate the correlated effects from the same distribution (default = 1)\nÎ»::Float64: Rate parameter of the exponential distribution for sampling means (default = 1.00)\nseed::Int64: Random number generator seed for reproducibility (default = 42)\n\nReturns\n\nMatrix{Float64}: A p Ã— q matrix where each column represents a set of correlated effects\n\nExamples\n\njulia> Î¸::Matrix{Float64} = simulateeffects();\n\njulia> sum(abs.(Î¸ - [-0.0886501800782904; -0.596478483888422])) < 0.00001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulategenomes-Tuple{}","page":"Home","title":"GBCore.simulategenomes","text":"simulategenomes(;\n    n::Int64 = 100,\n    n_populations::Int64 = 1,\n    l::Int64 = 10_000,\n    n_chroms::Int64 = 7,\n    n_alleles::Int64 = 2,\n    max_pos::Int64 = 135_000_000,\n    ld_corr_50perc_kb::Int64 = 1_000,\n    Î¼_Î²_params::Tuple{Float64,Float64} = (0.5, 0.5),\n    sparsity::Float64 = 0.0,\n    seed::Int64 = 42,\n    verbose::Bool = true\n)::Genomes\n\nSimulates genomic data with population structure and linkage disequilibrium.\n\nArguments\n\nn::Int64: Number of entries/individuals to simulate (1 to 1e9)\nn_populations::Int64: Number of populations to simulate (1 to n)\nl::Int64: Number of loci to simulate (2 to 1e9)\nn_chroms::Int64: Number of chromosomes (1 to 1e6)\nn_alleles::Int64: Number of alleles per locus (2 to 5, representing A, T, C, G, D)\nmax_pos::Int64: Maximum position in base pairs (10 to 160e9)\nld_corr_50perc_kb::Int64: Distance in kb where correlation decay reaches 50%\nÎ¼_Î²_params::Tuple{Float64,Float64}: Shape parameters for Beta distribution of allele frequencies\nsparsity::Float64: Proportion of missing data to simulate (0.0 to 1.0)\nseed::Int64: Random seed for reproducibility\nverbose::Bool: Whether to show progress bar and final plot\n\nReturns\n\nGenomes: A struct containing:\nentries: Vector of entry IDs\npopulations: Vector of population assignments\nloci_alleles: Vector of locus-allele combinations\nallele_frequencies: Matrix of allele frequencies\nmask: Boolean matrix indicating valid data points\n\nDetails\n\nSimulates genomic data by:\nGenerating chromosome lengths and loci positions\nAssigning alleles to loci\nGrouping entries into populations\nSimulating allele frequencies with linkage disequilibrium using multivariate normal distribution\nAdding optional sparsity (missing data)\nChromosome lengths are distributed evenly, with any remainder added to last chromosome\nLoci positions are randomly sampled without replacement within each chromosome\nLD decay follows an exponential function: corr = 1/exp(r*d), where d is normalized distance\nMean alele frequencies are sampled from Beta(Î±,Î²) distribution\nPopulation structure is implemented by sampling the mean allele frequencies per population\nFor each entry and locus, allele frequencies with linkage disequilibrium are simulated by sampling a multivariate normal distribution per chromosome\nMissing data is randomly assigned if sparsity > 0\n\nThrows\n\nArgumentError: If input parameters are outside acceptable ranges\nDimensionMismatch: If there's an error in the simulation process\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=10_000, n_alleles=3, verbose=false);\n\njulia> length(genomes.entries)\n100\n\njulia> length(genomes.populations)\n100\n\njulia> length(genomes.loci_alleles)\n20000\n\njulia> size(genomes.allele_frequencies)\n(100, 20000)\n\njulia> mean(ismissing.(genomes.allele_frequencies))\n0.0\n\njulia> rng::TaskLocalRNG = Random.seed!(123);\n\njulia> idx = StatsBase.sample(rng, range(1, 20_000, step=2), 250, replace = false, ordered = true);\n\njulia> correlations = StatsBase.cor(genomes.allele_frequencies[:, idx]);\n\njulia> correlations[10,10] == 1.00\ntrue\n\njulia> correlations[10,10] > correlations[10,250]\ntrue\n\njulia> genomes = simulategenomes(n=100, l=10_000, n_alleles=3, sparsity=0.25, verbose=false);\n\njulia> mean(ismissing.(genomes.allele_frequencies))\n0.25\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulategenomiceffects-Tuple{}","page":"Home","title":"GBCore.simulategenomiceffects","text":"simulategenomiceffects(;\n    genomes::Genomes,\n    f_additive::Float64 = 0.01,\n    f_dominance::Float64 = 0.10,\n    f_epistasis::Float64 = 0.05,\n    seed::Int64 = 42,\n)::Tuple{Matrix{Float64},Matrix{Float64}}\n\nSimulate additive, dominance, and epistatic effects for multiple loci.\n\nArguments\n\ngenomes::Genomes: Genome struct containing n entries x p loci-alleles combinations\nf_additive::Float64: Proportion of loci with non-zero additive effects (default = 0.01)\nf_dominance::Float64: Proportion of additive loci with dominance effects (default = 0.10)\nf_epistasis::Float64: Proportion of additive loci with epistasis effects (default = 0.05)\nseed::Int64: Random seed for reproducibility (default = 42)\n\nReturns\n\nTuple{Matrix{Float64},Matrix{Float64}}:\nFirst matrix (n x 3): Additive, dominance and epistasis effects per entry\nSecond matrix (p x 3): Effects per locus-allele combination\n\nDetails\n\nThe additive, dominance, and epistasis allele effects share a common exponential distribution (Î»=1) from which  the mean of the effects (Î¼) are sampled, and the covariance matrix is derived (Î£ = Î¼ * Î¼';  where if det(Î£)â‰ˆ0 then we iteratively add 1.00 to the diagonals until it becomes invertible or 10 iterations  finishes and throws an error). The non-additive or epistasis allele effects were simulated by multiplying the allele  frequencies of all possible unique pairs of epistasis alleles and their effects.\n\nExamples\n\njulia> genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);\n\njulia> G, B = simulategenomiceffects(genomes=genomes, f_additive=0.05, f_dominance=0.75, f_epistasis=0.25);\n\njulia> size.([G, B])\n2-element Vector{Tuple{Int64, Int64}}:\n (100, 3)\n (4000, 3)\n\njulia> sum(B .!= 0.0, dims=1)\n1Ã—3 Matrix{Int64}:\n 200  75  50\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulatemating-Tuple{}","page":"Home","title":"GBCore.simulatemating","text":"simulatemating(;\n    parent_genomes::Genomes,\n    n_generations::Int = 1,\n    pop_size_per_gen::Vector{Int64} = [100],\n    seed::Int64 = 42,\n    verbose::Bool = false\n)::Vector{Genomes}\n\nSimulates mating processes across multiple generations using a multivariate normal distribution approach.\n\nArguments\n\nparent_genomes::Genomes: Initial parent genomic information containing allele frequencies\nn_generations::Int: Number of generations to simulate (default: 1)\npop_size_per_gen::Vector{Int64}: Vector of population sizes for each generation (default: [100])\nseed::Int64: Random seed for reproducibility (default: 42)\nverbose::Bool: Whether to print progress messages (default: false)\n\nReturns\n\nVector{Genomes}: Vector of genomes across generations\n\nDescription\n\nThis function simulates genetic inheritance across generations by:\n\nSampling progeny allele frequencies using multivariate normal distribution\nEnforcing biological constraints (frequencies between 0 and 1)\nNormalizing frequencies for multiallelic loci\nDisplaying frequency histograms for each generation\n\nThe simulation maintains allele frequency correlations within chromosomes and handles multiallelic loci by ensuring their frequencies sum to 1.\n\nThrows\n\nArgumentError: If parent genomes contain missing values or invalid dimensions\n\nExample\n\njulia> parent_genomes = simulategenomes(n=5, l=10_000, n_alleles=3, verbose=false);\n\njulia> great_great_offspring_genomes = simulatemating(parent_genomes=parent_genomes, n_generations=3, pop_size_per_gen=[10, 20, 30]);\n\njulia> [length(x.entries) for x in great_great_offspring_genomes] == [5, 10, 20, 30]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.simulatetrials-Tuple{}","page":"Home","title":"GBCore.simulatetrials","text":"simulatetrials(;\n    genomes::Genomes,\n    f_add_dom_epi::Matrix{Float64} = [\n        0.01 0.25 0.10\n        0.05 0.50 0.25\n        0.10 0.25 0.00\n    ],\n    n_years::Int64 = 2,\n    n_seasons::Int64 = 4,\n    n_harvests::Int64 = 2,\n    n_sites::Int64 = 4,\n    n_replications::Int64 = 2,\n    n_blocks::Union{Missing,Int64} = missing,\n    n_rows::Union{Missing,Int64} = missing,\n    n_cols::Union{Missing,Int64} = missing,\n    proportion_of_variance::Union{Missing,Matrix{Float64}} = missing,\n    sparsity::Float64 = 0.0,\n    seed::Int64 = 42,\n    verbose::Bool = true,\n)::Tuple{Trials,Vector{SimulatedEffects}}\n\nArguments\n\ngenomes: Genome struct includes the n entries x p loci-alleles combinations (p = l loci x a-1 alleles)\nf_add_dom_epi: n_traits x 3 numeric matrix of loci proportion with additive, dominance and epistasis effects, i.e. each column refers to:\nf_additive: proportion of the l loci with non-zero additive effects on the phenotype\nf_dominance: proportion of the l*f_additive additive effects loci with additional dominance effects\nf_epistasis: proportion of the l*f_additive additive effects loci with additional epistasis effects\n(default = [0.01 0.25 0.10; 0.05 0.50 0.25; 0.10 0.25 0.00])\nn_years: Number of years (default = 2)\nn_seasons: Number of seasons (default = 4)\nn_harvests: Number of harvests (default = 2)\nn_sites: Number of sites (default = 4)\nn_replications: Number of replications (default = 2)\nn_blocks: Number of blocks across the entire field layout (default = missing)\nn_rows: Number of rows across the entire field layout (default = missing)\nn_cols: Number of columns across the entire field layout (default = missing)\nproportion_of_variance: 9 x n_traits numeric matrix of scaled/non-scaled proportion of variances allocated to   genetic and environmental effects (default = missing; values will be sampled from a uniform distribution  followed by a biased sample on the first row, i.e. additive effects row).  The rows correspond to the variance allocated to:\nadditive genetic effects\ndominance genetic effects\nepistasis genetic effects\nyears effects\nseasons effects\nsites effects\nenvironmental interactions\nspatial interactions\nGxE interactiions\nseed: Randomisation seed (default = 42)\nsparsity: Proportion of missing data (default = 0.0)\nverbose: Show trials simulation progress bar? (default = true)\n\nOutputs\n\nTrials struct of simulated phenotype data\nVector of SimulatedEffects each corresponding to each trait-year-season-harvest-site-replication combination\n\nDetails\n\nThe function simulates trial data by:\n\nGenerating genetic effects (additive, dominance, epistasis)\nSimulating environmental effects for:\nYears, seasons, sites\nEnvironmental interactions\nSpatial field effects (blocks, rows, columns)\nGenotype-by-environment interactions\nCombining effects according to specified variance proportions\nApplying optional sparsity to create missing data\n\nThe field layout is optimized to have:\n\nNumber of rows â‰¤ number of columns\nBlocks divided along columns\nEven distribution of entries and replications\n\nExamples\n\njulia> genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);\n\njulia> trials::Trials, vector_of_effects::Array{SimulatedEffects,1} = simulatetrials(genomes=genomes, sparsity=0.25, verbose=false);\n\njulia> size(trials.phenotypes)\n(12800, 3)\n\njulia> size(trials.traits)\n(3,)\n\njulia> unique(trials.entries) == genomes.entries\ntrue\n\njulia> unique(trials.populations) == unique(genomes.populations)\ntrue\n\njulia> abs(mean(ismissing.(trials.phenotypes)) - 0.25) < 0.00001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.slice-Tuple{Genomes}","page":"Home","title":"GBCore.slice","text":"slice(\n    genomes::Genomes; \n    idx_entries::Union{Nothing, Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,\n    verbose::Bool = false\n)::Genomes\n\nCreate a subset of a Genomes struct by selecting specific entries and loci-allele combinations.\n\nArguments\n\ngenomes::Genomes: The source genomic data structure to be sliced\nidx_entries::Union{Nothing, Vector{Int64}}: Indices of entries to keep. If nothing, all entries are kept\nidx_loci_alleles::Union{Nothing, Vector{Int64}}: Indices of loci-allele combinations to keep. If nothing, all loci-alleles are kept\nverbose::Bool: If true, displays a progress bar during slicing. Defaults to false\n\nReturns\n\nGenomes: A new Genomes struct containing only the selected entries and loci-allele combinations\n\nPerformance Notes\n\nThe function uses multi-threaded implementation for optimal performance\nProgress bar is available when verbose=true to monitor the slicing operation\nMemory efficient implementation that creates a new pre-allocated structure\n\nBehaviour\n\nBoth index vectors are automatically sorted and deduplicated\nIf both idx_entries and idx_loci_alleles are nothing, returns a clone of the input\nMaintains all relationships and structure of the original genomic data\nPreserves population assignments and allele frequencies for selected entries\n\nValidation\n\nPerforms dimension checks on both input and output genomic structures\nValidates that all indices are within proper bounds\nEnsures data consistency throughout the slicing operation\n\nThrows\n\nArgumentError: If input Genomes struct is corrupted or indices are out of bounds\nDimensionMismatch: If the resulting sliced genome has inconsistent dimensions\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> sliced_genomes = slice(genomes, idx_entries=collect(1:10), idx_loci_alleles=collect(1:300));\n\njulia> dimensions(sliced_genomes)\nDict{String, Int64} with 7 entries:\n  \"n_entries\"      => 10\n  \"n_chr\"          => 1\n  \"n_loci\"         => 100\n  \"n_loci_alleles\" => 300\n  \"n_populations\"  => 1\n  \"n_missing\"      => 0\n  \"max_n_alleles\"  => 4\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.slice-Tuple{Phenomes}","page":"Home","title":"GBCore.slice","text":"slice(phenomes::Phenomes; idx_entries::Union{Nothing, Vector{Int64}}=nothing, idx_traits::Union{Nothing, Vector{Int64}}=nothing)::Phenomes\n\nCreate a new Phenomes object containing a subset of the original data by selecting specific entries and traits.\n\nArguments\n\nphenomes::Phenomes: The original Phenomes object to slice\nidx_entries::Union{Nothing, Vector{Int64}}=nothing: Indices of entries to keep. If nothing, all entries are kept\nidx_traits::Union{Nothing, Vector{Int64}}=nothing: Indices of traits to keep. If nothing, all traits are kept\n\nReturns\n\nPhenomes: A new Phenomes object containing only the selected entries and traits\n\nNotes\n\nThe function preserves the original structure while reducing dimensions\nIndices must be within valid ranges (1 to nentries/ntraits)\nDuplicate indices are automatically removed\nThe resulting object maintains all relationships between entries, populations, traits, and phenotypes\n\nThrows\n\nArgumentError: If the input Phenomes struct is corrupted or if indices are out of bounds\nDimensionMismatch: If the slicing operation results in invalid dimensions\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> sliced_phenomes = slice(phenomes, idx_entries=collect(1:5); idx_traits=collect(2:3));\n\njulia> dimensions(sliced_phenomes)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 10\n  \"n_zeroes\"      => 10\n  \"n_nan\"         => 0\n  \"n_entries\"     => 5\n  \"n_traits\"      => 2\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 0\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.slice-Tuple{Trials}","page":"Home","title":"GBCore.slice","text":"slice(\n    trials::Trials; \n    traits::Union{Nothing, Vector{String}} = nothing,\n    populations::Union{Nothing, Vector{String}} = nothing,\n    entries::Union{Nothing, Vector{String}} = nothing,\n    years::Union{Nothing, Vector{String}} = nothing,\n    harvests::Union{Nothing, Vector{String}} = nothing,\n    seasons::Union{Nothing, Vector{String}} = nothing,\n    sites::Union{Nothing, Vector{String}} = nothing,\n    replications::Union{Nothing, Vector{String}} = nothing,\n    blocks::Union{Nothing, Vector{String}} = nothing,\n    rows::Union{Nothing, Vector{String}} = nothing,\n    cols::Union{Nothing, Vector{String}} = nothing,\n)::Trials\n\nCreate a subset of a Trials struct by filtering its components based on specified criteria.\n\nArguments\n\ntrials::Trials: The source trials data structure to be sliced\ntraits::Vector{String}: Selected trait names to include\npopulations::Vector{String}: Selected population names to include\nentries::Vector{String}: Selected entry names to include\nyears::Vector{String}: Selected years to include\nharvests::Vector{String}: Selected harvest identifiers to include\nseasons::Vector{String}: Selected seasons to include\nsites::Vector{String}: Selected site names to include\nreplications::Vector{String}: Selected replication identifiers to include\nblocks::Vector{String}: Selected block identifiers to include\nrows::Vector{String}: Selected row identifiers to include\ncols::Vector{String}: Selected column identifiers to include\n\nAll arguments except trials are optional. When an argument is not provided (i.e., nothing),  all values for that category are included in the slice.\n\nReturns\n\nA new Trials struct containing only the selected data\n\nThrows\n\nArgumentError: If invalid names are provided for any category or if no data remains after filtering\nDimensionMismatch: If the resulting sliced trials structure has inconsistent dimensions\nArgumentError: If the input trials structure is corrupted\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> sliced_trials = slice(trials, traits=trials.traits[2:3], years=[unique(trials.years)[1]], seasons=unique(trials.seasons)[2:3]);\n\njulia> dimensions(sliced_trials)\nDict{String, Int64} with 16 entries:\n  \"n_zeroes\"       => 0\n  \"n_harvests\"     => 2\n  \"n_nan\"          => 0\n  \"n_entries\"      => 100\n  \"n_traits\"       => 2\n  \"n_seasons\"      => 2\n  \"n_blocks\"       => 10\n  \"n_rows\"         => 10\n  \"n_missing\"      => 0\n  \"n_inf\"          => 0\n  \"n_total\"        => 6400\n  \"n_replications\" => 2\n  \"n_years\"        => 1\n  \"n_sites\"        => 4\n  \"n_cols\"         => 20\n  \"n_populations\"  => 1\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.sparsities-Tuple{Genomes}","page":"Home","title":"GBCore.sparsities","text":"sparsities(genomes::Genomes) -> Tuple{Vector{Float64}, Vector{Float64}}\n\nCalculate the sparsity (proportion of missing data) for each entry and locus in a Genomes object.\n\nReturns a tuple of two vectors:\n\nFirst vector contains sparsity values for each entry (row-wise mean of missing values)\nSecond vector contains sparsity values for each locus (column-wise mean of missing values)\n\nThe function processes the data in parallel using multiple threads for performance optimization.\n\nArguments\n\ngenomes::Genomes: A Genomes object containing allele frequency data with potentially missing values\n\nReturns\n\nTuple{Vector{Float64}, Vector{Float64}}: A tuple containing:\nVector of entry sparsities (values between 0.0 and 1.0)\nVector of locus sparsities (values between 0.0 and 1.0)\n\nExample\n\njulia> genomes = simulategenomes(n=100, l=1_000, sparsity=0.25, verbose=false);\n\njulia> entry_sparsities, locus_sparsities = sparsities(genomes);\n\njulia> abs(0.25 - mean(entry_sparsities)) < 0.0001\ntrue\n\njulia> abs(0.25 - mean(locus_sparsities)) < 0.0001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.summarise-Tuple{Vector{CV}}","page":"Home","title":"GBCore.summarise","text":"summarise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}\n\nSummarize cross-validation results from a vector of CV structs into two DataFrames.\n\nReturns\n\nA tuple containing two DataFrames:\nSummary DataFrame with mean metrics across entries, replications, and folds\nContains means and standard deviations of correlation coefficients\nIncludes average training and validation set sizes\nGrouped by training population, validation population, trait, and model\nEntry-level DataFrame with phenotype prediction statistics\nContains true phenotype values, predicted means (Î¼), and standard deviations (Ïƒ)\nGrouped by training population, validation population, trait, model, and entry\n\nArguments\n\ncvs::Vector{CV}: Vector of CV structs containing cross-validation results\n\nNotes\n\nValidates dimensions of input CV structs before processing\nHandles missing values in phenotype predictions\n\nThrows\n\nArgumentError: If any CV struct in the input vector has inconsistent dimensions\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(\"cor\" => 0.0, \"rmse\" => 1.0); fit_1.trait = \"trait_1\";\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit_1, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit_1.metrics);\n\njulia> fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(\"cor\" => 1.0, \"rmse\" => 0.0); fit_2.trait = \"trait_1\";\n\njulia> cv_2 = CV(\"replication_2\", \"fold_2\", fit_2, [\"population_2\"], [\"entry_2\"], [0.0], [0.0], fit_2.metrics);\n\njulia> cvs = [cv_1, cv_2];\n\njulia> df_summary, df_summary_per_entry = summarise(cvs);\n\njulia> size(df_summary)\n(2, 8)\n\njulia> size(df_summary_per_entry)\n(2, 8)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.tabularise","page":"Home","title":"GBCore.tabularise","text":"tabularise(fit::Fit, metric::String = \"cor\")::DataFrame\n\nConvert a Fit struct into a DataFrame for easier data manipulation and analysis.\n\nArguments\n\nfit::Fit: A Fit struct containing model results and parameters\nmetric::String = \"cor\": The metric to extract from fit.metrics dictionary (default: \"cor\")\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nmodel: The model name\ntrait: The trait name\npopulation: Semicolon-separated string of unique population names\nmetric: The specified metric value from fit.metrics\nb_hat_labels: Labels for the effect sizes\nb_hat: Estimated effect sizes\n\nExamples\n\njulia> fit = Fit(n=100, l=10_000); fit.b_hat = rand(10_000); fit.model=\"some_model\"; fit.trait=\"some_trait\"; \n\njulia> fit.metrics = Dict(\"cor\" => rand(), \"rmse\" => rand()); fit.populations .= \"pop_1\";\n\njulia> df = tabularise(fit);\n\njulia> size(df)\n(10000, 6)\n\n\n\n\n\n","category":"function"},{"location":"#GBCore.tabularise-Tuple{Phenomes}","page":"Home","title":"GBCore.tabularise","text":"tabularise(phenomes::Phenomes)::DataFrame\n\nConvert a Phenomes struct into a tabular format as a DataFrame.\n\nThe resulting DataFrame contains the following columns:\n\nid: Integer index for each entry\nentries: Entry identifiers\npopulations: Population assignments\nAdditional columns for each trait in phenomes.traits\n\nArguments\n\nphenomes::Phenomes: A valid Phenomes struct containing phenotypic data\n\nReturns\n\nDataFrame: A DataFrame with entries as rows and traits as columns\n\nThrows\n\nArgumentError: If the Phenomes struct dimensions are inconsistent\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> tabularise(phenomes)\n10Ã—6 DataFrame\n Row â”‚ id     entries   populations  A         B         C        \n     â”‚ Int64  String    String       Float64?  Float64?  Float64? \nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n   1 â”‚     1  entry_1   pop_1             0.0       0.0       0.0\n   2 â”‚     2  entry_2   pop_1             0.0       0.0       0.0\n   3 â”‚     3  entry_3   pop_1             0.0       0.0       0.0\n   4 â”‚     4  entry_4   pop_1             0.0       0.0       0.0\n   5 â”‚     5  entry_5   pop_1             0.0       0.0       0.0\n   6 â”‚     6  entry_6   pop_1             0.0       0.0       0.0\n   7 â”‚     7  entry_7   pop_1             0.0       0.0       0.0\n   8 â”‚     8  entry_8   pop_1             0.0       0.0       0.0\n   9 â”‚     9  entry_9   pop_1             0.0       0.0       0.0\n  10 â”‚    10  entry_10  pop_1             0.0       0.0       0.0\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.tabularise-Tuple{Trials}","page":"Home","title":"GBCore.tabularise","text":"tabularise(trials::Trials)::DataFrame\n\nConvert a Trials struct into a DataFrame representation for easier data manipulation and analysis.\n\nArguments\n\ntrials::Trials: A valid Trials struct containing experimental field trial data.\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nid: Unique identifier for each trial observation\nyears: Year of the trial\nseasons: Season identifier\nharvests: Harvest identifier\nsites: Location/site identifier\nreplications: Replication number\nblocks: Block identifier\nrows: Row position\ncols: Column position\nentries: Entry identifier\npopulations: Population identifier\nAdditional columns for each trait in trials.traits\n\nThrows\n\nArgumentError: If the Trials struct dimensions are inconsistent\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> size(df)\n(12800, 14)\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.tabularise-Tuple{Vector{CV}}","page":"Home","title":"GBCore.tabularise","text":"tabularise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}\n\nConvert a vector of CV (Cross-Validation) structs into two DataFrames containing metrics and predictions.\n\nArguments\n\ncvs::Vector{CV}: Vector of CV structs containing cross-validation results\n\nReturns\n\nTuple{DataFrame,DataFrame}: A tuple of two DataFrames:\ndf_across_entries: Contains aggregated metrics across entries with columns:\ntraining_population: Semicolon-separated list of training populations\nvalidation_population: Semicolon-separated list of validation populations\ntrait: Name of the trait\nmodel: Name of the model used\nreplication: Replication identifier\nfold: Fold identifier\ntraining_size: Number of entries in training set\nvalidation_size: Number of entries in validation set\nAdditional columns for each metric (e.g., cor, rmse)\ndf_per_entry: Contains per-entry predictions with columns:\ntraining_population: Training population identifier\nvalidation_population: Validation population identifier\nentry: Entry identifier\ntrait: Name of the trait\nmodel: Name of the model used\nreplication: Replication identifier\nfold: Fold identifier\ny_true: True values\ny_pred: Predicted values\n\nThrows\n\nArgumentError: If input vector is empty or if any CV struct is corrupted\n\nNotes\n\nWarns if there are empty CV structs resulting from insufficient training sizes or fixed traits\nMetrics are extracted from the metrics dictionary in each CV struct\nPopulation identifiers are sorted and joined with semicolons when multiple populations exist\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(\"cor\" => 0.0, \"rmse\" => 1.0); fit_1.trait = \"trait_1\";\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit_1, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit_1.metrics);\n\njulia> fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(\"cor\" => 1.0, \"rmse\" => 0.0); fit_2.trait = \"trait_1\";\n\njulia> cv_2 = CV(\"replication_2\", \"fold_2\", fit_2, [\"population_2\"], [\"entry_2\"], [0.0], [0.0], fit_2.metrics);\n\njulia> cvs = [cv_1, cv_2];\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> names(df_across_entries)\n10-element Vector{String}:\n \"training_population\"\n \"validation_population\"\n \"trait\"\n \"model\"\n \"replication\"\n \"fold\"\n \"training_size\"\n \"validation_size\"\n \"cor\"\n \"rmse\"\n\njulia> df_across_entries[!, [:cor, :rmse]]\n2Ã—2 DataFrame\n Row â”‚ cor      rmse    \n     â”‚ Float64  Float64 \nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n   1 â”‚     0.0      1.0\n   2 â”‚     1.0      0.0\n\njulia> names(df_per_entry)\n9-element Vector{String}:\n \"training_population\"\n \"validation_population\"\n \"entry\"\n \"trait\"\n \"model\"\n \"replication\"\n \"fold\"\n \"y_true\"\n \"y_pred\"\n\njulia> df_per_entry[!, [:entry, :y_true, :y_pred]]\n2Ã—3 DataFrame\n Row â”‚ entry    y_true   y_pred  \n     â”‚ String   Float64  Float64 \nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n   1 â”‚ entry_1      0.0      0.0\n   2 â”‚ entry_2      0.0      0.0\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}","page":"Home","title":"GBCore.trialsmodelsfomulae!","text":"trialsmodelsfomulae!(df::DataFrame; trait::String, max_levels::Int64 = 100)::Tuple{Vector{String},Vector{Int64}}\n\nGenerate mixed model formulae for analyzing multi-environment trial data.\n\nArguments\n\ndf::DataFrame: Input DataFrame containing trial data, will be modified in-place\ntrait::String: Name of the response variable column\nmax_levels::Int64=100: Maximum number of factor levels allowed in interaction terms\n\nReturns\n\nA tuple containing:\n\nVector{String}: Collection of mixed model formulae with increasing complexity\nVector{Int64}: Corresponding number of factor levels for each formula\n\nDetails\n\nThe function:\n\nIdentifies available trial design variables (nesters, spatial components, targets)\nCreates interaction terms between variables and adds them to the DataFrame\nGenerates model formulae considering:\nSingle and multi-environment models\nFixed and random entry effects\nSpatial error components\nNested random effects\nFilters redundant models and sorts by complexity\n\nNotes\n\nWarns if trials are unreplicated\nThrows error if only one entry is present\nAutomatically removes block effects when both row and column effects are present\nRemoves redundant nesting structures\n\nExamples\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> size(df)\n(12800, 14)\n\njulia> formulae, n_levels = trialsmodelsfomulae!(df, trait=\"trait_1\");\n\njulia> size(df)\n(12800, 134)\n\njulia> length(formulae)\n76\n\njulia> sum(n_levels .== sort(n_levels))\n76\n\n\n\n\n\n","category":"method"},{"location":"#GBCore.@string2formula-Tuple{Any}","page":"Home","title":"GBCore.@string2formula","text":"@string2formula(x::String)\n\nConvert a string representation of a formula into a Formula object.\n\nThis macro parses a string containing a formula expression and evaluates it into a proper Formula object that can be used in statistical modeling.\n\nArguments\n\nx::String: A string containing the formula expression (e.g., \"y ~ x + z\")\n\nReturns\n\nFormula: A Formula object representing the parsed expression\n\n\n\n\n\n","category":"macro"},{"location":"#GBCore.@stringevaluation-Tuple{Any}","page":"Home","title":"GBCore.@stringevaluation","text":"@stringevaluation(x)\n\nParse and evaluate a string expression at compile time.\n\nArguments\n\nx: A string containing a Julia expression to be parsed.\n\nReturns\n\nThe parsed expression as an Expr object ready for evaluation.\n\n\n\n\n\n","category":"macro"}]
}
