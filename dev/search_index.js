var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GenomicBreedingCore","category":"page"},{"location":"#GenomicBreedingCore","page":"Home","title":"GenomicBreedingCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GenomicBreedingCore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GenomicBreedingCore]","category":"page"},{"location":"#GenomicBreedingCore.AbstractGB","page":"Home","title":"GenomicBreedingCore.AbstractGB","text":"AbstractGB\n\nThe root abstract type for all core types in GenomicBreeding.jl package.\n\nThis type serves as the common ancestor for the type hierarchy in the package, enabling shared functionality and type-based dispatch across all derived types.\n\nExtended help\n\nAll custom core types in GenomicBreeding.jl should subtype from AbstractGB to ensure consistency in the type system and to enable generic implementations of common operations.\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.CV","page":"Home","title":"GenomicBreedingCore.CV","text":"Cross-validation struct\n\nContains genomic prediction cross-validation details.\n\nFields\n\nreplication: replication name\nfold: fold name\nfit: genomic prediction model fit on the training set\nvalidation_populations: vector of validation populations corresponding to each validation entry\nvalidation_entries: corresponding vector of entries in the validation population/s\nvalidation_y_true: corresponding vector of observed phenotypes in the validation population/s\nvalidation_y_pred: corresponding vector of predicted phenotypes in the validation population/s\nmetrics: dictionary of genomic prediction accuracy metrics on the validation population/s\n\nConstructor\n\nUses the default constructor.\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.Fit","page":"Home","title":"GenomicBreedingCore.Fit","text":"Genomic prediction model fit\n\nContains genomic prediction model fit details.\n\nFields\n\nmodel: name of the genomic prediction model used\nb_hat_labels: names of the loci-alleles used\nb_hat: effects of the loci-alleles\ntrait: name of the trait\nentries: names of the entries used in the current cross-validation replication and fold\npopulations: names of the populations used in the current cross-validation replication and fold\ny_true: corresponding observed phenotype values\ny_pred: corresponding predicted phenotype values\nmetrics: dictionary of genomic prediction accuracy metrics, inluding Pearson's correlation, mean absolute error and root mean-squared error\nlux_model: Nothing or a trained Lux neural network model\n\nConstructor\n\nFit(; n=1, l=10)\nwhere:\n- n::Int64: Number of entries\n- l::Int64: Number of loci-alleles\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.GRM","page":"Home","title":"GenomicBreedingCore.GRM","text":"Genomic relationship matrix struct\n\nContains genomic relationship matrix as well as the corresponding entries and loci-alleles used to compute it.\n\nFields\n\nentries: names of the n entries corresponding to the rows and columns of the genomic relationship matrix\nloci_alleles: names of the loci-alleles used to compute the genomic relationship matrix\ngenomic_relationship_matrix: n x n matrix of genomic relationship values between entries\n\nConstructor\n\nUses the default constructor.\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.Genomes","page":"Home","title":"GenomicBreedingCore.Genomes","text":"Genomes struct\n\nContaines unique entries and loci_alleles where allele frequencies can have missing values\n\nFields\n\nentries: names of the n entries or samples\npopulations: name/s of the population/s each entries or samples belong to\nloci_alleles: names of the p loci-alleles combinations (p = l loci x a-1 alleles) including the chromsome or scaffold name, position, all alleles and current allele separated by tabs (\"\\t\")\nallele_frequencies: n x p matrix of allele frequencies between 0 and 1 which can have missing values\nmask: n x p matrix of boolean mask for selective analyses and slicing\n\nConstructor\n\nGenomes(; n::Int64 = 1, p::Int64 = 2)\n\nwhere:\n\nn::Int64=1: Number of entries in the genomic dataset\np::Int64=2: Number of locus-allele combinations in the genomic dataset\n\nExamples\n\njulia> genomes = Genomes(n=2, p=2)\nGenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\njulia> fieldnames(Genomes)\n(:entries, :populations, :loci_alleles, :allele_frequencies, :mask)\n\njulia> genomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> genomes.populations = [\"pop_1\", \"pop_1\"];\n\njulia> genomes.loci_alleles = [\"chr1\\t12345\\tA|T\\tA\", \"chr2\\t678910\\tC|D\\tD\"];\n\njulia> genomes.allele_frequencies = [0.5 0.25; 0.9 missing];\n\njulia> genomes.mask = [true true; true false];\n\njulia> genomes\nGenomes([\"entry_1\", \"entry_2\"], [\"pop_1\", \"pop_1\"], [\"chr1\\t12345\\tA|T\\tA\", \"chr2\\t678910\\tC|D\\tD\"], Union{Missing, Float64}[0.5 0.25; 0.9 missing], Bool[1 1; 1 0])\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.Phenomes","page":"Home","title":"GenomicBreedingCore.Phenomes","text":"Phenomes struct\n\nConstains unique entries and traits where phenotype data can have missing values\n\nFields\n\nentries: names of the n entries or samples\npopulations: name/s of the population/s each entries or samples belong to\ntraits: names of the t traits\nphenotypes: n x t matrix of numeric (R) phenotype data which can have missing values\nmask: n x t matrix of boolean mask for selective analyses and slicing\n\nConstructor\n\nPhenomes(; n::Int64 = 1, t::Int64 = 2)\n\nwhere:\n\nn::Int64=1: Number of entries in the phenomic dataset\nt::Int64=2: Number of traits in the phenomic dataset\n\nExamples\n\njulia> phenomes = Phenomes(n=2, t=2)\nPhenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\njulia> fieldnames(Phenomes)\n(:entries, :populations, :traits, :phenotypes, :mask)\n\njulia> phenomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> phenomes.populations = [\"pop_A\", \"pop_B\"];\n\njulia> phenomes.traits = [\"height\", \"yield\"];\n\njulia> phenomes.phenotypes = [200.0 2.5; 150.0 missing];\n\njulia> phenomes.mask = [true true; true false];\n\njulia> phenomes\nPhenomes([\"entry_1\", \"entry_2\"], [\"pop_A\", \"pop_B\"], [\"height\", \"yield\"], Union{Missing, Float64}[200.0 2.5; 150.0 missing], Bool[1 1; 1 0])\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.SimulatedEffects","page":"Home","title":"GenomicBreedingCore.SimulatedEffects","text":"SimulatedEffects struct\n\nContains the various simulated genetic, environmental and GxE effects.\n\nFields\n\nid::Vector{String}: Vector of identifiers\nyear::Float64: Year effect\nseason::Float64: Season effect\nsite::Float64: Site effect\nseasons_x_year::Float64: Interaction effect between seasons and years\nharvests_x_season_x_year::Float64: Interaction effect between harvests, seasons and years\nsites_x_harvest_x_season_x_year::Float64: Interaction effect between sites, harvests, seasons and years\nfield_layout::Matrix{Int64}: 2D matrix representing field layout\nreplications_x_site_x_harvest_x_season_x_year::Vector{Float64}: Replication interaction effects\nblocks_x_site_x_harvest_x_season_x_year::Vector{Float64}: Block interaction effects\nrows_x_site_x_harvest_x_season_x_year::Vector{Float64}: Row interaction effects\ncols_x_site_x_harvest_x_season_x_year::Vector{Float64}: Column interaction effects\nadditive_genetic::Vector{Float64}: Additive genetic effects\ndominance_genetic::Vector{Float64}: Dominance genetic effects\nepistasis_genetic::Vector{Float64}: Epistasis genetic effects\nadditive_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}: Additive allele interaction effects\ndominance_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}: Dominance allele interaction effects\nepistasis_allele_x_site_x_harvest_x_season_x_year::Vector{Float64}: Epistasis allele interaction effects\n\nConstructor\n\nSimulatedEffects()\n\nCreates a new SimulatedEffects instance with default values:\n\nEmpty strings for IDs (vector of size 6)\n0.0 for all float values\n4x4 zero matrix for field_layout\nSingle-element zero vectors for all vector fields\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.TEBV","page":"Home","title":"GenomicBreedingCore.TEBV","text":"Trial-estimated breeding values (TEBV) struct\n\nContains trial-estimated breeding values as generated by analyse(trials::Trials, ...).\n\nFields\n\ntraits: names of the traits t traits\nformulae: best-fitting formula for each trait\nmodels: best-fitting linear mixed model for each trait which may be MixedModes.jl model or a tuple of coefficient names, the coefficients and the design matrix from Bayesial linear regression\ndf_BLUEs: vector of data frames of best linear unbiased estimators or fixed effects table of each best fitting model\ndf_BLUPs: vector of data frames of best linear unbiased predictors or random effects table of each best fitting model\nphenomes: vector of Phenomes structs each containing the breeding values\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1, t=1)]);\n\njulia> tebv.traits\n1-element Vector{String}:\n \"\"\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.Trials","page":"Home","title":"GenomicBreedingCore.Trials","text":"Trials struct\n\nContains phenotype data across years, seasons, harvest, sites, populations, replications, blocks, rows, and columns\n\nFields\n\nphenotypes: n x t matrix of numeric phenotype data which can have missing values\ntraits: names of the traits t traits\nyears: names of the years corresponding to each row in the phenotype matrix\nseasons: names of the seasons corresponding to each row in the phenotype matrix\nharvests: names of the harvests corresponding to each row in the phenotype matrix\nsites: names of the sites corresponding to each row in the phenotype matrix\nreplications: names of the replications corresponding to each row in the phenotype matrix\nblocks: names of the blocks corresponding to each row in the phenotype matrix\nrows: names of the rows corresponding to each row in the phenotype matrix\ncols: names of the cols corresponding to each row in the phenotype matrix\nentries: names of the entries corresponding to each row in the phenotype matrix\npopulations: names of the populations corresponding to each row in the phenotype matrix\n\nConstructor\n\nTrials(; n::Int64 = 2, p::Int64 = 2)\n\nwhere:\n\nn::Int64=1: Number of entries in the trials\nt::Int64=2: Number of traits in the trials\n\nExamples\n\njulia> trials = Trials(n=1, t=2)\nTrials(Union{Missing, Float64}[missing missing], [\"\", \"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"], [\"\"])\n\njulia> fieldnames(Trials)\n(:phenotypes, :traits, :years, :seasons, :harvests, :sites, :replications, :blocks, :rows, :cols, :entries, :populations)\n\n\n\n\n\n","category":"type"},{"location":"#Base.:==-Tuple{CV, CV}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::CV, y::CV)::Bool\n\nCompare two CV (Cross-Validation) structs for equality.\n\nThis method overloads the equality operator (==) for CV structs by comparing their hash values. Two CV structs are considered equal if they have identical values for all fields.\n\nArguments\n\nx::CV: First CV struct to compare\ny::CV: Second CV struct to compare\n\nReturns\n\nBool: true if the CV structs are equal, false otherwise\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> cv_2 = clone(cv_1);\n\njulia> cv_3 = clone(cv_1); cv_3.replication = \"other_replication\";\n\njulia> cv_1 == cv_2\ntrue\n\njulia> cv_1 == cv_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Fit, Fit}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::Fit, y::Fit)::Bool\n\nCompare two Fit structs for equality based on their hash values.\n\nThis method defines equality comparison for Fit structs by comparing their hash values. Two Fit structs are considered equal if they have identical hash values, which means they have the same values for all their fields.\n\nArguments\n\nx::Fit: First Fit struct to compare\ny::Fit: Second Fit struct to compare\n\nReturns\n\nBool: true if the Fit structs are equal, false otherwise\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=4);\n\njulia> fit_2 = Fit(n=1, l=4);\n\njulia> fit_3 = Fit(n=1, l=2);\n\njulia> fit_1 == fit_2\ntrue\n\njulia> fit_1 == fit_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{GRM, GRM}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::GRM, y::GRM)::Bool\n\nCompare two GRM structs for equality.\n\nOverloads the equality operator (==) for GRM structs by comparing their hash values. Two GRM structs are considered equal if they have identical values for all their fields.\n\nArguments\n\nx::GRM: First GRM struct to compare\ny::GRM: Second GRM struct to compare\n\nReturns\n\nBool: true if the GRM structs are equal, false otherwise\n\nExamples\n\njulia> grm_1 = GRM(string.([\"entries_1\", \"entries_2\"]), string.([\"chr1\t123\tA|T\tA\", \"chr1\t456\tC|G\tG\"]), Float64.(rand(2,2)));\n\njulia> grm_2 = clone(grm_1);\n\njulia> grm_3 = GRM(string.([\"entries_1\", \"entries_2\"]), string.([\"chr1\t123\tA|T\tA\", \"chr1\t456\tC|G\tG\"]), Float64.(rand(2,2)));\n\njulia> grm_1 == grm_2\ntrue\n\njulia> grm_1 == grm_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Genomes, Genomes}","page":"Home","title":"Base.:==","text":"==(x::Genomes, y::Genomes)::Bool\n\nCompare two Genomes structs for equality by comparing their hash values.\n\nThis method implements equality comparison for Genomes structs by utilizing their hash values, ensuring that two genomes are considered equal if and only if they have identical structural properties and content.\n\nArguments\n\nx::Genomes: First Genomes struct to compare\ny::Genomes: Second Genomes struct to compare\n\nReturns\n\nBool: true if the genomes are equal, false otherwise\n\nExamples\n\njulia> genomes_1 = genomes = Genomes(n=2,p=4);\n\njulia> genomes_2 = genomes = Genomes(n=2,p=4);\n\njulia> genomes_3 = genomes = Genomes(n=1,p=2);\n\njulia> genomes_1 == genomes_2\ntrue\n\njulia> genomes_1 == genomes_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Phenomes, Phenomes}","page":"Home","title":"Base.:==","text":"==(x::Phenomes, y::Phenomes)::Bool\n\nCompare two Phenomes structs for equality using their hash values.\n\nThis method implements equality comparison for Phenomes objects by comparing their hash values, ensuring that two phenomes with identical structure and content are considered equal.\n\nArguments\n\nx::Phenomes: First phenomes object to compare\ny::Phenomes: Second phenomes object to compare\n\nReturns\n\nBool: true if the phenomes are equal, false otherwise\n\nExamples\n\njulia> phenomes_1 = phenomes = Phenomes(n=2, t=4);\n\njulia> phenomes_2 = phenomes = Phenomes(n=2, t=4);\n\njulia> phenomes_3 = phenomes = Phenomes(n=1, t=2);\n\njulia> phenomes_1 == phenomes_2\ntrue\n\njulia> phenomes_1 == phenomes_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{SimulatedEffects, SimulatedEffects}","page":"Home","title":"Base.:==","text":"Base.:(==)(x::SimulatedEffects, y::SimulatedEffects)::Bool\n\nDefines equality comparison for SimulatedEffects structs by comparing their hash values.\n\nThis method overloads the == operator for SimulatedEffects type and determines if two SimulatedEffects instances are equal by comparing their hash values rather than doing a field-by-field comparison.\n\nArguments\n\nx::SimulatedEffects: First SimulatedEffects instance to compare\ny::SimulatedEffects: Second SimulatedEffects instance to compare\n\nReturns\n\nBool: true if the hash values of both instances are equal, false otherwise\n\nExamples\n\njulia> effects_1 = SimulatedEffects();\n\njulia> effects_2 = SimulatedEffects();\n\njulia> effects_3 = SimulatedEffects(); effects_3.id[1] = \"SOMETHING_ELSE\";\n\njulia> effects_1 == effects_2\ntrue\n\njulia> effects_1 == effects_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{TEBV, TEBV}","page":"Home","title":"Base.:==","text":"==(x::TEBV, y::TEBV)::Bool\n\nCompare two TEBV (Trial-Estimated Breeding Values) objects for equality.\n\nThis method implements equality comparison for TEBV structs by comparing their hash values. Two TEBV objects are considered equal if they have identical values for all their fields: traits, formulae, models, dfBLUEs, dfBLUPs, and phenomes.\n\nArguments\n\nx::TEBV: First TEBV object to compare\ny::TEBV: Second TEBV object to compare\n\nReturns\n\nBool: true if the TEBV objects are equal, false otherwise\n\nExamples\n\njulia> tebv_1 = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> tebv_2 = clone(tebv_1);\n\njulia> tebv_3 = TEBV(traits=[\"SOMETHING_ELSE\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> tebv_1 == tebv_2\ntrue\n\njulia> tebv_1 == tebv_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Tuple{Trials, Trials}","page":"Home","title":"Base.:==","text":"==(x::Trials, y::Trials)::Bool\n\nCompare two Trials structs for equality by comparing their hash values.\n\nTwo Trials structs are considered equal if they have identical hash values, which implies they have the same configuration parameters (number of trials n and time steps t).\n\nArguments\n\nx::Trials: First Trials struct to compare\ny::Trials: Second Trials struct to compare\n\nReturns\n\nBool: true if the Trials structs are equal, false otherwise\n\nExamples\n\njulia> trials_1 = trials = Trials(n=2, t=4);\n\njulia> trials_2 = trials = Trials(n=2, t=4);\n\njulia> trials_3 = trials = Trials(n=1, t=2);\n\njulia> trials_1 == trials_2\ntrue\n\njulia> trials_1 == trials_3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Genomes, Float64}","page":"Home","title":"Base.filter","text":"filter(\n    genomes::Genomes,\n    maf::Float64;\n    max_entry_sparsity::Float64 = 0.0,\n    max_locus_sparsity::Float64 = 0.0,\n    max_prop_pc_varexp::Float64 = 0.90,\n    max_entry_sparsity_percentile::Float64 = 0.90,\n    max_locus_sparsity_percentile::Float64 = 0.50,\n    chr_pos_allele_ids::Union{Nothing,Vector{String}} = nothing,\n    verbose::Bool = false,\n)::Tuple{Genomes, Dict{String,Vector{String}}}\n\nFilter genomic data based on multiple criteria including sparsity, minor allele frequency (MAF), principal component analysis (PCA), and a list of loci-allele combinations.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nmaf::Float64: The minimum allele frequency threshold.\nmax_entry_sparsity::Float64: The maximum allowable sparsity for entries. Default is 0.0.\nmax_locus_sparsity::Float64: The maximum allowable sparsity for loci. Default is 0.0.\nmax_prop_pc_varexp::Float64: The maximum proportion of variance explained by the first two principal components (PC1 and PC2). Default is 0.90.\nmax_entry_sparsity_percentile::Float64: The percentile threshold for entry sparsity. Default is 0.90.\nmax_locus_sparsity_percentile::Float64: The percentile threshold for locus sparsity. Default is 0.50.\nchr_pos_allele_ids::Union{Nothing, Vector{String}}: A vector of loci-allele combination names in the format \"chromosome\tposition\tallele\". If nothing, no filtering is applied. Default is nothing.\nverbose::Bool: If true, prints detailed progress information during the filtering process. Default is false.\n\nReturns\n\nTuple{Genomes, Dict{String, Vector{String}}}: A tuple containing:\nA Genomes struct with filtered genomic data.\nA dictionary of omitted loci-allele names categorized by the filtering criteria.\n\nDetailS\n\nThis function filters genomic data based on multiple criteria including sparsity, minor allele frequency (MAF), principal component analysis (PCA), and a list of loci-allele combinations. The function performs the following steps:\n\nInput Validation: Ensures that the Genomes struct is not corrupted and that the filtering thresholds are within valid ranges. Throws an ArgumentError if any argument is out of range.\nFilter by Sparsity: Removes the sparsest entries and loci-alleles until the maximum allowable sparsity thresholds are met.\nFilter by MAF: Removes loci-alleles with minor allele frequencies below the specified threshold.\nFilter by PCA: Removes outlier loci-alleles based on the proportion of variance explained by the first two principal components.\nFilter by SNP List: Retains only the specified loci-allele combinations.\nVerbose Output: If verbose is true, prints detailed progress information during each filtering step.\nOutput: Returns the filtered Genomes struct and a dictionary of omitted loci-allele names categorized by the filtering criteria.\n\nNotes\n\nThe function uses multi-threading to improve performance on large datasets.\nThe verbose option provides additional insights into the filtering process by printing progress information.\nThe function ensures that the filtered genomic data retains a minimum number of entries and loci-alleles.\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted or any of the filtering thresholds are out of range.\nErrorException: If no loci-alleles are retained after filtering.\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, sparsity=0.01, verbose=false);\n\njulia> filtered_genomes_1, omitted_loci_alleles_1 = filter(genomes, 0.1);\n\njulia> filtered_genomes_2, omitted_loci_alleles_2 = filter(genomes, 0.1, chr_pos_allele_ids=genomes.loci_alleles[1:1000]);\n\njulia> size(genomes.allele_frequencies)\n(100, 3000)\n\njulia> prod(size(filtered_genomes_1.allele_frequencies)) < prod(size(genomes.allele_frequencies))\ntrue\n\njulia> prod(size(filtered_genomes_2.allele_frequencies)) < prod(size(filtered_genomes_1.allele_frequencies))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Genomes}","page":"Home","title":"Base.filter","text":"filter(genomes::Genomes; verbose::Bool = false)::Genomes\n\nFilter a Genomes struct by removing entries and loci with missing data based on the mask matrix.\n\nDescription\n\nThis function filters a Genomes struct by:\n\nRemoving rows (entries) where any column has a false value in the mask matrix\nRemoving columns (loci) where any row has a false value in the mask matrix\n\nArguments\n\ngenomes::Genomes: Input Genomes struct containing genetic data and a mask matrix\nverbose::Bool: Optional flag to control verbose output (default: false)\n\nReturns\n\nGenomes: A new filtered Genomes struct with complete data (no missing values)\n\nExamples\n\njulia> genomes = simulategenomes(verbose=false); genomes.mask[1:10, 42:100] .= false;\n    \njulia> filtered_genomes = filter(genomes);\n\njulia> size(filtered_genomes.allele_frequencies)\n(90, 9941)\n\n\n\n\n\n","category":"method"},{"location":"#Base.filter-Tuple{Phenomes}","page":"Home","title":"Base.filter","text":"filter(phenomes::Phenomes)::Phenomes\n\nFilter a Phenomes struct by removing rows (entries) and columns (traits) as indicated by the mask matrix.  An entry or trait is removed if it contains at least one false value in the mask.\n\nArguments\n\nphenomes::Phenomes: The Phenomes struct to be filtered, containing entries, populations, traits, phenotypes, and a boolean mask matrix.\n\nReturns\n\nPhenomes: A new Phenomes struct with filtered entries and traits, where the mask matrix is all true.\n\nDetails\n\nThe function uses the mean of rows and columns in the mask matrix to identify which entries and traits should be kept. Only entries and traits with a mean of 1.0 (all true values) are retained in the filtered result.\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> phenomes.mask .= true; phenomes.mask[6:10, 1] .= false;\n    \njulia> filtered_phenomes = filter(phenomes);\n\njulia> size(filtered_phenomes.phenotypes)\n(5, 2)\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{CV, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::CV, h::UInt)::UInt\n\nCompute a hash value for a CV (Cross-Validation) struct.\n\nThis method defines how CV structs should be hashed, which is useful for using CV objects in hash-based collections like Sets or as Dict keys.\n\nArguments\n\nx::CV: The CV struct to be hashed\nh::UInt: The hash value to be mixed with the new hash\n\nReturns\n\nUInt: A hash value for the CV struct\n\nImplementation Details\n\nThe hash is computed by combining the following fields:\n\nreplication\nfold\nfit\nvalidation_populations\nvalidation_entries\nvalidationytrue\nvalidationypred\nmetrics\n\nExample\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> typeof(hash(cv))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Fit, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Fit, h::UInt)::UInt\n\nCalculate a hash value for a Fit struct.\n\nThis method implements hashing for the Fit type by combining the hashes of its core components in a specific order. The hash is computed using the following fields:\n\nmodel\nb_hat (estimated effects)\ntrait\nentries\npopulations\nmetrics\ny_true (observed values)\ny_pred (predicted values)\n\nArguments\n\nx::Fit: The Fit struct to be hashed\nh::UInt: The hash value to be mixed with\n\nReturns\n\nUInt: The computed hash value\n\nExample\n\njulia> fit = Fit(n=1, l=2);\n\njulia> typeof(hash(fit))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{GRM, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::GRM, h::UInt)::UInt\n\nCompute a hash value for a GRM (Genomic Relationship Matrix) struct.\n\nThis method defines how GRM structs should be hashed, making them usable in  hash-based collections like Sets or as Dict keys. The hash is computed by  iteratively combining the hash values of all fields in the struct.\n\nArguments\n\nx::GRM: The GRM struct to be hashed\nh::UInt: The initial hash value to be combined with the struct's hash\n\nReturns\n\nUInt: A combined hash value for the entire GRM struct\n\nExample\n\njulia> grm = GRM(string.([\"entries_1\", \"entries_2\"]), string.([\"chr1\t123\tA|T\tA\", \"chr1\t456\tC|G\tG\"]), Float64.(rand(2,2)));\n\njulia> typeof(hash(grm))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Genomes, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Genomes, h::UInt)::UInt\n\nCompute a hash value for a Genomes struct.\n\nThis hash function considers three key components of the Genomes struct:\n\nentries\npopulations\nloci_alleles\n\nFor performance reasons, allele_frequencies and mask fields are deliberately excluded  from the hash computation.\n\nArguments\n\nx::Genomes: The Genomes struct to hash\nh::UInt: The hash seed value\n\nReturns\n\nUInt: A hash value for the Genomes struct\n\nExamples\n\njulia> genomes = Genomes(n=2, p=2);\n\njulia> typeof(hash(genomes))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Phenomes, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Phenomes, h::UInt)::UInt\n\nCompute a hash value for a Phenomes struct by recursively hashing its internal fields.\n\nArguments\n\nx::Phenomes: The Phenomes struct to be hashed\nh::UInt: The hash value to be mixed with\n\nReturns\n\nUInt: A hash value for the entire Phenomes struct\n\nNote\n\nThis function is used for dictionary operations and computing hash-based data structures. The hash is computed by combining hashes of all internal fields: entries, populations, traits, phenotypes, and mask.\n\nExamples\n\njulia> phenomes = Phenomes(n=2, t=2);\n\njulia> typeof(hash(phenomes))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{SimulatedEffects, UInt64}","page":"Home","title":"Base.hash","text":"hash(x::SimulatedEffects, h::UInt)::UInt\n\nCompute a hash value for a SimulatedEffects object.\n\nThis method implements custom hashing for SimulatedEffects by iterating through all fields of the object and combining their hash values with the provided seed hash h.\n\nArguments\n\nx::SimulatedEffects: The object to be hashed\nh::UInt: The hash seed value\n\nReturns\n\nUInt: The computed hash value\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> typeof(hash(effects))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{TEBV, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::TEBV, h::UInt)::UInt\n\nCalculate a hash value for a TEBV (Trial-Estimated Breeding Value) struct.\n\nThis method implements hashing for TEBV objects by combining the hash values of selected fields:\n\ntraits: Vector of trait names\nformulae: Vector of formula strings\nphenomes: Vector of Phenomes objects\n\nNote: For performance reasons, the following fields are deliberately excluded from the hash calculation:\n\nmodels\ndf_BLUEs\ndf_BLUPs\n\nArguments\n\nx::TEBV: The TEBV struct to be hashed\nh::UInt: The hash value to be mixed with the object's hash\n\nReturns\n\nUInt: A unique hash value for the TEBV object\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> typeof(hash(tebv))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.hash-Tuple{Trials, UInt64}","page":"Home","title":"Base.hash","text":"Base.hash(x::Trials, h::UInt)::UInt\n\nCompute a hash value for a Trials struct by recursively hashing all of its fields.\n\nThis method implements hash functionality for the Trials type, allowing Trials  objects to be used as dictionary keys or in hash-based collections.\n\nArguments\n\nx::Trials: The Trials struct to be hashed\nh::UInt: The hash value to be mixed with the object's hash\n\nReturns\n\nUInt: A hash value for the entire Trials struct\n\nExamples\n\njulia> trials = Trials(n=2, t=2);\n\njulia> typeof(hash(trials))\nUInt64\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Genomes, Genomes}","page":"Home","title":"Base.merge","text":"merge(\n    genomes::Genomes,\n    other::Genomes;\n    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),\n    verbose::Bool = true\n)::Genomes\n\nMerge two Genomes structs by combining their entries and loci_alleles while resolving conflicts in allele frequencies.\n\nArguments\n\ngenomes::Genomes: First Genomes struct to merge\nother::Genomes: Second Genomes struct to merge\nconflict_resolution::Tuple{Float64,Float64}: Weights for resolving conflicts between allele frequencies (must sum to 1.0)\nverbose::Bool: If true, displays a progress bar during merging\n\nReturns\n\nGenomes: A new Genomes struct containing the merged data\n\nDetails\n\nThe function performs the following operations:\n\nCombines unique entries and loci_alleles from both input structs\nResolves population conflicts by concatenating conflicting values\nFor overlapping entries and loci:\nIf allele frequencies match, uses the existing value\nIf frequencies differ, applies weighted average using conflict_resolution\nFor missing values, uses available non-missing value\nResolves mask conflicts using weighted average\n\nExamples\n\njulia> n = 100; l = 5_000; n_alleles = 2;\n\njulia> all = simulategenomes(n=n, l=l, n_alleles=n_alleles, verbose=false);\n\njulia> genomes = slice(all, idx_entries=collect(1:Int(floor(n*0.75))), idx_loci_alleles=collect(1:Int(floor(l*(n_alleles-1)*0.75))));\n\njulia> other = slice(all, idx_entries=collect(Int(floor(n*0.50)):n), idx_loci_alleles=collect(Int(floor(l*(n_alleles-1)*0.50)):l*(n_alleles-1)));\n\njulia> merged_genomes = merge(genomes, other, conflict_resolution=(0.75, 0.25), verbose=false);\n\njulia> size(merged_genomes.allele_frequencies)\n(100, 5000)\n\njulia> sum(ismissing.(merged_genomes.allele_frequencies))\n123725\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Genomes, Phenomes}","page":"Home","title":"Base.merge","text":"merge(genomes::Genomes, phenomes::Phenomes; keep_all::Bool=true)::Tuple{Genomes,Phenomes}\n\nMerge Genomes and Phenomes structs based on their entries, combining genomic and phenotypic data.\n\nArguments\n\ngenomes::Genomes: A struct containing genomic data including entries, populations, and allele frequencies\nphenomes::Phenomes: A struct containing phenotypic data including entries, populations, and phenotypes\nkeep_all::Bool=true: If true, performs a union of entries; if false, performs an intersection\n\nReturns\n\nTuple{Genomes,Phenomes}: A tuple containing:\nA new Genomes struct with merged entries and corresponding genomic data\nA new Phenomes struct with merged entries and corresponding phenotypic data\n\nDetails\n\nMaintains dimensional consistency between input and output structs\nHandles population conflicts by creating a combined population name\nPreserves allele frequencies and phenotypic data for matched entries\nWhen keep_all=true, includes all entries from both structs\nWhen keep_all=false, includes only entries present in both structs\n\nExamples\n\njulia> genomes = simulategenomes(n=10, verbose=false);\n\njulia> trials, effects = simulatetrials(genomes=slice(genomes, idx_entries=collect(1:5), idx_loci_alleles=collect(1:length(genomes.loci_alleles))), f_add_dom_epi=[0.90 0.05 0.05;], n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=2, verbose=false);\n\njulia> phenomes = Phenomes(n=5, t=1);\n\njulia> phenomes.entries = trials.entries[1:5];\n\njulia> phenomes.populations = trials.populations[1:5];\n\njulia> phenomes.traits = trials.traits;\n\njulia> phenomes.phenotypes = trials.phenotypes[1:5, :];\n\njulia> phenomes.mask .= true;\n\njulia> genomes_merged_1, phenomes_merged_1 = merge(genomes, phenomes, keep_all=true);\n\njulia> size(genomes_merged_1.allele_frequencies), size(phenomes_merged_1.phenotypes)\n((10, 10000), (10, 1))\n\njulia> genomes_merged_2, phenomes_merged_2 = merge(genomes, phenomes, keep_all=false);\n\njulia> size(genomes_merged_2.allele_frequencies), size(phenomes_merged_2.phenotypes)\n((5, 10000), (5, 1))\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{Phenomes, Phenomes}","page":"Home","title":"Base.merge","text":"merge(\n    phenomes::Phenomes,\n    other::Phenomes;\n    conflict_resolution::Tuple{Float64,Float64} = (0.5, 0.5),\n    verbose::Bool = true\n)::Phenomes\n\nMerge two Phenomes structs into a single combined struct, handling overlapping entries and traits.\n\nArguments\n\nphenomes::Phenomes: The first Phenomes struct to merge\nother::Phenomes: The second Phenomes struct to merge\nconflict_resolution::Tuple{Float64,Float64}: Weights for resolving conflicts between overlapping values (must sum to 1.0)\nverbose::Bool: Whether to display a progress bar during merging\n\nReturns\n\nPhenomes: A new merged Phenomes struct containing all entries and traits from both input structs\n\nDetails\n\nThe merge operation combines:\n\nAll unique entries from both structs\nAll unique traits from both structs\nPhenotype values and masks, using weighted averaging for conflicts\nPopulation information, marking conflicts with a \"CONFLICT\" prefix\n\nFor overlapping entries and traits:\n\nIdentical values are preserved as-is\nDifferent values are combined using the weights specified in conflict_resolution\nMissing values are handled by using the available non-missing value\nPopulation conflicts are marked in the format \"CONFLICT (pop1, pop2)\"\n\nThrows\n\nArgumentError: If either Phenomes struct is corrupted (invalid dimensions)\nArgumentError: If conflict_resolution weights don't sum to 1.0 or aren't a 2-tuple\nErrorException: If the merging operation produces an invalid result\n\nExamples\n\njulia> all = Phenomes(n=10, t=3); all.entries = string.(\"entry_\", 1:10); all.traits = [\"A\", \"B\", \"C\"]; all.phenotypes = rand(10,3);\n\njulia> phenomes = slice(all, idx_entries=collect(1:7), idx_traits=[1,2]);\n\njulia> other = slice(all, idx_entries=collect(5:10), idx_traits=[2,3]);\n\njulia> merged_phenomes = merge(phenomes, other, conflict_resolution=(0.75, 0.25), verbose=false);\n\njulia> size(merged_phenomes.phenotypes)\n(10, 3)\n\njulia> sum(ismissing.(merged_phenomes.phenotypes))\n7\n\n\n\n\n\n","category":"method"},{"location":"#Base.sum-Tuple{SimulatedEffects}","page":"Home","title":"Base.sum","text":"sum(effects::SimulatedEffects)::Vector{Float64}\n\nSum up all simulated effects to generate the simulated phenotype values. The function iterates through all fields of the SimulatedEffects struct (except :id and :field_layout) and adds their values element-wise to produce a vector of phenotypic values.\n\nArguments\n\neffects::SimulatedEffects: A struct containing various genetic and environmental effects\n\nReturns\n\nVector{Float64}: A vector containing the summed effects (phenotypic values)\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> sum(effects)\n1-element Vector{Float64}:\n 0.0\n\njulia> effects.additive_genetic[1] = pi;\n\njulia> sum(effects)\n1-element Vector{Float64}:\n 3.141592653589793\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.addcompositetrait-Tuple{Phenomes}","page":"Home","title":"GenomicBreedingCore.addcompositetrait","text":"addcompositetrait(phenomes::Phenomes; composite_trait_name::String, formula_string::String)::Phenomes\n\nCreate a new composite trait by combining existing traits using mathematical operations.\n\nArguments\n\nphenomes::Phenomes: A Phenomes struct containing the original trait data\ncomposite_trait_name::String: Name for the new composite trait\nformula_string::String: Mathematical formula describing how to combine existing traits.  Supports traits as variables and the following operations:\nBasic arithmetic: +, -, *, /, ^, %\nFunctions: abs(), sqrt(), log(), log2(), log10()\nParentheses for operation precedence\n\nReturns\n\nPhenomes: A new Phenomes struct with the composite trait added as the last column\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3);\n\njulia> phenomes_new = addcompositetrait(phenomes, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"A\");\n\njulia> phenomes_new.phenotypes[:, end] == phenomes.phenotypes[:, 1]\ntrue\n\njulia> phenomes_new = addcompositetrait(phenomes, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"(A^B) + (C/A) - sqrt(abs(B-A)) + log(1.00 + C)\");\n\njulia> phenomes_new.phenotypes[:, end] == (phenomes.phenotypes[:,1].^phenomes.phenotypes[:,2]) .+ (phenomes.phenotypes[:,3]./phenomes.phenotypes[:,1]) .- sqrt.(abs.(phenomes.phenotypes[:,2].-phenomes.phenotypes[:,1])) .+ log.(1.00 .+ phenomes.phenotypes[:,3])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.addcompositetrait-Tuple{Trials}","page":"Home","title":"GenomicBreedingCore.addcompositetrait","text":"addcompositetrait(trials::Trials; composite_trait_name::String, formula_string::String)::Trials\n\nCreate a new composite trait by combining existing traits using a mathematical formula.\n\nArguments\n\ntrials::Trials: A Trials struct containing phenotypic data\ncomposite_trait_name::String: Name for the new composite trait\nformula_string::String: Mathematical formula defining how to combine existing traits\n\nFormula Syntax\n\nThe formula can include:\n\nTrait names (e.g., \"trait1\", \"trait2\")\nMathematical operators: +, -, *, /, ^, %\nFunctions: abs(), sqrt(), log(), log2(), log10()\nParentheses for grouping operations\n\nReturns\n\nTrials: A new Trials struct with the added composite trait\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> trials_new = addcompositetrait(trials, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"trait_1\");\n\njulia> trials_new.phenotypes[:, end] == trials.phenotypes[:, 1]\ntrue\n\njulia> trials_new = addcompositetrait(trials, composite_trait_name = \"some_wild_composite_trait\", formula_string = \"(trait_1^(trait_2/100)) + (trait_3/trait_1) - sqrt(abs(trait_2-trait_1)) + log(1.00 + trait_3)\");\n\njulia> trials_new.phenotypes[:, end] == (trials.phenotypes[:,1].^(trials.phenotypes[:,2]/100)) .+ (trials.phenotypes[:,3]./trials.phenotypes[:,1]) .- sqrt.(abs.(trials.phenotypes[:,2].-trials.phenotypes[:,1])) .+ log.(1.00 .+ trials.phenotypes[:,3])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.analyse","page":"Home","title":"GenomicBreedingCore.analyse","text":"analyse(\n    trials::Trials,\n    formula_string::String = \"\";\n    traits::Union{Nothing,Vector{String}} = nothing,\n    max_levels::Int64 = 100,\n    max_time_per_model::Int64 = 60,\n    covariates_continuous::Union{Nothing,Vector{String}} = nothing,\n    verbose::Bool = true\n)::TEBV\n\nAnalyze trial data using linear mixed models to estimate Best Linear Unbiased Estimates (BLUEs)  and Best Linear Unbiased Predictions (BLUPs).\n\nArguments\n\ntrials: A Trials struct containing the experimental data\nformula_string: Optional model formula string. If empty, automatic model selection is performed\ntraits: Optional vector of trait names to analyze. If nothing, all traits are analyzed\nmax_levels: Maximum number of levels for non-entry random effects (default: 100)\nmax_time_per_model: Maximum fitting time in seconds per model (default: 60)\ncovariates_continuous: Optional vector of continuous covariates to include in models\nverbose: Whether to display analysis progress (default: true)\n\nReturns\n\nA TEBV struct containing:\n\ntraits: Vector of analyzed trait names\nformulae: Vector of best-fitting model formulae\nmodels: Vector of fitted LinearMixedModel objects\ndf_BLUEs: Vector of DataFrames containing BLUEs\ndf_BLUPs: Vector of DataFrames containing BLUPs\nphenomes: Vector of Phenomes objects with predicted values\n\nDetails\n\nThe function implements a mixed model fitting strategy with the following principles:\n\nAvoids over-parameterization\nUses unstructured variance-covariance matrix for random effects\nPrefers REML over ML estimation\nCompares BLUEs vs BLUPs of entries\nHandles both parallel and iterative model fitting based on model complexity\n\nNotes\n\nModels are fitted using REML\nSimple models are fitted in parallel while complex models are fitted iteratively to avoid memory issues\nReturns empty results if no models can be successfully fitted\n\nExamples\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);\n\njulia> tebv_1 = analyse(trials, \"trait_1 ~ 1 + (1|entries)\", max_levels=50, verbose=false);\n\njulia> tebv_1.traits\n3-element Vector{String}:\n \"trait_1\"\n \"trait_2\"\n \"trait_3\"\n\njulia> tebv_2 = analyse(trials, max_levels=50, verbose=false);\n\njulia> mean(tebv_2.phenomes[1].phenotypes) < mean(tebv_2.phenomes[2].phenotypes)\ntrue\n\njulia> trials = addcompositetrait(trials, composite_trait_name = \"covariate\", formula_string = \"(trait_1 + trait_2) / (trait_3 + 0.0001)\");\n\njulia> tebv_3 = Suppressor.@suppress analyse(trials, \"y ~ 1 + covariate + entries + (1|blocks)\", max_levels=50, verbose=false);\n\njulia> mean(tebv_3.phenomes[1].phenotypes) < mean(tebv_3.phenomes[2].phenotypes)\ntrue\n\njulia> tebv_4 = Suppressor.@suppress analyse(trials, max_levels=50, covariates_continuous=[\"covariate\"], verbose=false);\n\njulia> mean(tebv_4.phenomes[1].phenotypes) < mean(tebv_4.phenomes[2].phenotypes)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#GenomicBreedingCore.analyse-Tuple{DataFrames.DataFrame}","page":"Home","title":"GenomicBreedingCore.analyse","text":"analyse(\n    df::DataFrame; \n    formulae::Vector{String},\n    idx_parallel_models::Vector{Int64},\n    idx_iterative_models::Vector{Int64},\n    max_time_per_model::Int64 = 60,\n    verbose::Bool=false\n)::Tuple{String, Any, DataFrame, DataFrame, Phenomes}\n\nFit univariate linear mixed models to extract entry effects from the best-fitting model.\n\nArguments\n\ndf::DataFrame: Input data frame containing trial data with columns for entries, traits, and other experimental factors\nformulae::Vector{String}: Vector of model formulae strings to be tested\nidx_parallel_models::Vector{Int64}: Indices of simpler models to be fitted in parallel\nidx_iterative_models::Vector{Int64}: Indices of complex models to be fitted iteratively\nmax_time_per_model::Int64: Maximum time in seconds allowed for fitting each model (default: 60)\nverbose::Bool: Whether to display progress information (default: false)\n\nReturns\n\nA tuple containing:\n\nString: Formula of the best-fitting model\nAny: The fitted model object\nDataFrame: BLUEs (Best Linear Unbiased Estimates) results\nDataFrame: BLUPs (Best Linear Unbiased Predictions) results\nPhenomes: Struct containing consolidated phenotypic predictions\n\nDetails\n\nThe function implements a mixed model fitting strategy with the following principles:\n\nAvoids over-parameterization\nUses unstructured variance-covariance matrix for random effects\nPrefers REML over ML estimation\nCompares BLUEs vs BLUPs of entries\nHandles both parallel and iterative model fitting based on model complexity\n\nNotes\n\nAll formulae must model the same trait\nModels are fitted using REML\nSimple models are fitted in parallel while complex models are fitted iteratively to avoid memory issues\nReturns empty results if no models can be successfully fitted\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> formulae, n_levels = trialsmodelsfomulae!(df; trait = \"trait_1\", max_levels = 10);\n\njulia> idx_parallel_models::Vector{Int64} = findall(n_levels .<= (15));\n\njulia> idx_iterative_models::Vector{Int64} = findall((n_levels .<= (15)) .!= true);\n\njulia> formula_string, model, df_BLUEs, df_BLUPs, phenomes = analyse(df, formulae=formulae, idx_parallel_models=idx_parallel_models, idx_iterative_models=idx_iterative_models);\n\njulia> length(phenomes.entries) == length(unique(df.entries))\ntrue\n\njulia> df_2 = df[(df.years .== df.years[1]) .&& (df.harvests .== df.harvests[1]) .&& (df.seasons .== df.seasons[1]) .&& (df.sites .== df.sites[1]) .&& (df.replications .== df.replications[1]), :];\n\njulia> formula_string_2, model_2, df_BLUEs_2, df_BLUPs_2, phenomes_2 = analyse(df_2, formulae=[\"trait_1 ~ 1 + 1|entries\"]);\n\njulia> cor(phenomes_2.phenotypes[sortperm(phenomes_2.entries),1], df_2.trait_1[sortperm(df_2.entries)]) > 0.99\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.checkdims-Tuple{CV}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(cv::CV)::Bool\n\nCheck dimension compatibility of the fields of the CV struct.\n\nThe function verifies that:\n\nThe fit object dimensions are valid\nThe number of validation populations matches the number of validation entries\nThe number of validation true values matches the number of validation predictions\nThe number of metrics matches the number of metrics in the fit object\n\nReturns:\n\ntrue if all dimensions are compatible\nfalse if any dimension mismatch is found\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> checkdims(cv)\ntrue\n\njulia> cv.validation_y_true = [0.0, 0.0];\n\njulia> checkdims(cv)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.checkdims-Tuple{Fit}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(fit::Fit)::Bool\n\nCheck dimension compatibility of the internal fields of a Fit struct.\n\nThis function verifies that all vector fields in the Fit struct have compatible dimensions:\n\nLength of entries, populations, y_true, and y_pred must be equal (denoted as n)\nLength of b_hat and b_hat_labels must be equal (denoted as l)\n\nReturns true if all dimensions are compatible, false otherwise.\n\nArguments\n\nfit::Fit: The Fit struct to check dimensions for\n\nReturns\n\nBool: true if dimensions are compatible, false otherwise\n\nExamples\n\njulia> fit = Fit(n=1, l=4);\n\njulia> checkdims(fit)\ntrue\n\njulia> fit.b_hat_labels = [\"chr1\\t1\\tA|T\\tA\"];\n\njulia> checkdims(fit)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.checkdims-Tuple{GRM}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(grm::GRM)::Bool\n\nCheck dimension compatibility of the GRM (Genomic Relationship Matrix) struct fields.\n\nArguments\n\ngrm::GRM: A Genomic Relationship Matrix struct containing entries and relationship matrix\n\nReturns\n\ntrue if the number of entries matches the dimensions of the genomic relationship matrix\nfalse if there is a mismatch between the number of entries and matrix dimensions\n\nDetails\n\nThe function verifies that:\n\nThe number of entries equals the number of rows in the genomic relationship matrix\nThe number of entries equals the number of columns in the genomic relationship matrix\n\n(The genomic relationship matrix should be square with dimensions matching the number of entries)\n\nExamples\n\njulia> grm = GRM(string.([\"entries_1\", \"entries_2\"]), string.([\"chr1\t123\tA|T\tA\", \"chr1\t456\tC|G\tG\"]), Float64.(rand(2,2)));\n\njulia> checkdims(grm)\ntrue\n\njulia> grm.entries = [\"dummy_entry\"];\n\njulia> checkdims(grm)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.checkdims-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(genomes::Genomes)::Bool\n\nCheck dimension compatibility of the fields in a Genomes struct.\n\nReturns true if all dimensions are compatible, false otherwise.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genomic data\n\nDetails\n\nVerifies that:\n\nNumber of entries matches number of populations (n)\nEntry names are unique\nNumber of loci alleles matches width of frequency matrix (p) \nLocus-allele combinations are unique\nEntries are unique\nDimensions of frequency matrix (n×p) match mask matrix dimensions\n\nExamples\n\njulia> genomes = Genomes(n=2,p=4);\n\njulia> checkdims(genomes)\nfalse\n\njulia> genomes.entries = [\"entry_1\", \"entry_2\"];\n\njulia> genomes.loci_alleles = [\"chr1\\t1\\tA|T\\tA\", \"chr1\\t2\\tC|G\\tG\", \"chr2\\t3\\tA|T\\tA\", \"chr2\\t4\\tG|T\\tG\"];\n\njulia> checkdims(genomes)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.checkdims-Tuple{Phenomes}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(y::Phenomes)::Bool\n\nVerify dimensional compatibility between all fields of a Phenomes struct.\n\nChecks if:\n\nNumber of entries matches the number of rows in phenotypes matrix\nAll entry names are unique\nNumber of populations matches number of entries\nNumber of traits matches number of columns in phenotypes matrix\nAll trait names are unique\nDimensions of mask matrix match phenotypes matrix\n\nArguments\n\ny::Phenomes: A Phenomes struct containing phenotypic data\n\nReturns\n\nBool: true if all dimensions are compatible, false otherwise\n\nExamples\n\njulia> y = Phenomes(n=2, t=2);\n\njulia> checkdims(y)\nfalse\n\njulia> y.entries = [\"entry_1\", \"entry_2\"];\n\njulia> y.traits = [\"trait_1\", \"trait_2\"];\n\njulia> checkdims(y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.checkdims-Tuple{SimulatedEffects}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(effects::SimulatedEffects)::Bool\n\nCheck dimension compatibility of the fields of the SimulatedEffects struct.\n\nArguments\n\neffects::SimulatedEffects: A SimulatedEffects struct containing various genetic and experimental effects\n\nReturns\n\nBool: true if all dimensions are compatible, false otherwise\n\nVerifies that:\n\nid has length 6\nfield_layout has 4 columns \nAll following vectors have the same length (n):\nreplications_x_site_x_harvest_x_season_x_year\nblocks_x_site_x_harvest_x_season_x_year\nrows_x_site_x_harvest_x_season_x_year\ncols_x_site_x_harvest_x_season_x_year\nadditive_genetic\ndominance_genetic\nepistasis_genetic\nadditive_allele_x_site_x_harvest_x_season_x_year\ndominance_allele_x_site_x_harvest_x_season_x_year\nepistasis_allele_x_site_x_harvest_x_season_x_year\n\nExamples\n\njulia> effects = SimulatedEffects();\n\njulia> typeof(hash(effects))\nUInt64\n\njldoctest; setup = :(using GenomicBreedingCore) julia> effects = SimulatedEffects();\n\njulia> checkdims(effects) true\n\njulia> effects.id = [\"beaking_change\"];\n\njulia> checkdims(effects) false ```\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.checkdims-Tuple{TEBV}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(y::TEBV)::Bool\n\nCheck if all fields in the TEBV struct have compatible dimensions. The function verifies that the length of all arrays in the TEBV struct match the number of traits.\n\nArguments\n\ntebv::TEBV: A TEBV (Trial-estimated Breeding Values) struct containing traits, formulae, models, BLUEs, BLUPs, and phenomes.\n\nReturns\n\nBool: Returns true if all fields have matching dimensions (equal to the number of traits), false otherwise.\n\nDetails\n\nThe function checks if the following fields have the same length as traits:\n\nformulae\nunique models\nunique BLUEs DataFrames\nunique BLUPs DataFrames\nunique phenomes\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], dfBLUEs=[DataFrame(x=1)], dfBLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> checkdims(tebv) true ```\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.checkdims-Tuple{Trials}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(trials::Trials)::Bool\n\nCheck dimension compatibility of all fields in a Trials struct.\n\nThis function verifies that the dimensions of all vector fields in the Trials struct are  consistent with the size of the phenotypes matrix. Specifically, it checks:\n\nNumber of traits (t) matches number of columns in phenotypes and length of traits vector\nNumber of entries (n) matches number of rows in phenotypes and length of:\nyears\nseasons\nharvests\nsites\nreplications\nblocks\nrows\ncols\nentries\npopulations\n\nReturns true if all dimensions are compatible, false otherwise.\n\nArguments\n\ntrials::Trials: A Trials struct containing trial data\n\nReturns\n\nBool: true if dimensions are compatible, false otherwise\n\nExamples\n\njulia> trials = Trials(n=1, t=2);\n\njulia> trials.entries = [\"entry_1\"]; trials.traits = [\"trait_1\", \"trait_2\"];\n\njulia> checkdims(trials)\ntrue\n\njulia> trials.entries = [\"entering_2_entries\", \"instead_of_just_1\"];\n\njulia> checkdims(trials)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.clone-Tuple{CV}","page":"Home","title":"GenomicBreedingCore.clone","text":"clone(x::CV)::CV\n\nCreate a deep copy of a CV (cross-validation) object.\n\nCreates a new CV object with deep copies of all fields from the input object. The clone function ensures that modifications to the cloned object do not affect  the original object.\n\nArguments\n\nx::CV: The CV object to be cloned\n\nReturns\n\nCV: A new CV object containing deep copies of all fields from the input\n\nExample\n\nClone a CV object\n\nExample\n\njulia> fit = Fit(n=1, l=2);\n\njulia> cv = CV(\"replication_1\", \"fold_1\", fit, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit.metrics);\n\njulia> copy_cv = clone(cv)\nCV(\"replication_1\", \"fold_1\", Fit(\"\", [\"\", \"\"], [0.0, 0.0], \"\", [\"\"], [\"\"], [0.0], [0.0], Dict(\"\" => 0.0), nothing), [\"population_1\"], [\"entry_1\"], [0.0], [0.0], Dict(\"\" => 0.0))\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.clone-Tuple{Fit}","page":"Home","title":"GenomicBreedingCore.clone","text":"clone(x::Fit)::Fit\n\nCreate a deep copy of a Fit object, duplicating all its fields.\n\nThis function performs a deep clone of the input Fit object, ensuring that all nested structures and arrays are also copied, preventing any shared references between the original and the cloned object.\n\nArguments\n\nx::Fit: The Fit object to be cloned\n\nReturns\n\nFit: A new Fit object with identical but independent values\n\nFields copied\n\nmodel: The statistical model\nb_hat_labels: Labels for the estimated parameters\nb_hat: Estimated parameters\ntrait: The trait being analyzed\nentries: Entry identifiers\npopulations: Population identifiers\nmetrics: Performance metrics\ny_true: Observed values\ny_pred: Predicted values\n\nExamples\n\njulia> fit = Fit(n=1, l=2);\n\njulia> copy_fit = clone(fit)\nFit(\"\", [\"\", \"\"], [0.0, 0.0], \"\", [\"\"], [\"\"], [0.0], [0.0], Dict(\"\" => 0.0), nothing)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.clone-Tuple{GRM}","page":"Home","title":"GenomicBreedingCore.clone","text":"clone(x::GRM)::GRM\n\nCreate a deep copy of a GRM (Genomic Relationship Matrix) object.\n\nCreates a new GRM object with deep copies of all fields from the input object. The clone function ensures that modifications to the cloned object do not affect  the original object.\n\nArguments\n\nx::GRM: The GRM object to be cloned \n\nReturns\n\nGRM: A new GRM object containing deep copies of the entries, locialleles,         and genomicrelationship_matrix fields from the input\n\nExample\n\njulia> grm = GRM(string.([\"entries_1\", \"entries_2\"]), string.([\"chr1\t123\tA|T\tA\", \"chr1\t456\tC|G\tG\"]), Float64.(rand(2,2)));\n\njulia> copy_grm = clone(grm);\n\njulia> (copy_grm.entries == grm.entries) && (copy_grm.loci_alleles == grm.loci_alleles) && (copy_grm.genomic_relationship_matrix == grm.genomic_relationship_matrix)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.clone-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.clone","text":"clone(x::Genomes)::Genomes\n\nCreate a deep copy of a Genomes object.\n\nThis function performs a deep clone of all fields in the Genomes object, including:\n\nentries\npopulations \nloci_alleles\nallele_frequencies\nmask\n\nReturns a new Genomes instance with identical but independent data.\n\nArguments\n\nx::Genomes: The source Genomes object to clone\n\nReturns\n\nGenomes: A new Genomes object containing deep copies of all fields\n\nExample\n\njulia> genomes = Genomes(n=2, p=2);\n\njulia> copy_genomes = clone(genomes)\nGenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.clone-Tuple{Phenomes}","page":"Home","title":"GenomicBreedingCore.clone","text":"clone(x::Phenomes)::Phenomes\n\nCreate a deep copy of a Phenomes object, including all its fields.\n\nThis function performs a deep copy of the following fields:\n\nentries: Vector of entry names\npopulations: Vector of population identifiers\ntraits: Vector of trait names\nphenotypes: Matrix of phenotypic values\nmask: Matrix of boolean masks\n\nReturns a new Phenomes object with identical structure but independent memory allocation.\n\nArguments\n\nx::Phenomes: The source Phenomes object to be cloned\n\nReturns\n\nPhenomes: A new Phenomes object containing deep copies of all fields\n\nExample\n\njulia> phenomes = Phenomes(n=2, t=2);\n\njulia> copy_phenomes = clone(phenomes)\nPhenomes([\"\", \"\"], [\"\", \"\"], [\"\", \"\"], Union{Missing, Float64}[missing missing; missing missing], Bool[1 1; 1 1])\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.clone-Tuple{TEBV}","page":"Home","title":"GenomicBreedingCore.clone","text":"clone(x::TEBV)::TEBV\n\nCreate a deep copy of a TEBV (Trial-Estimated Breeding Value) object.\n\nReturns a new TEBV instance with all fields deeply copied from the input object, ensuring complete independence between the original and cloned objects.\n\nArguments\n\nx::TEBV: The source TEBV object to be cloned\n\nReturns\n\nTEBV: A new TEBV object containing deep copies of all fields from the input\n\nExamples\n\njulia> tebv = TEBV(traits=[\"\"], formulae=[\"\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> copy_tebv = clone(tebv);\n\njulia> copy_tebv.traits == tebv.traits\ntrue\n\njulia> copy_tebv.phenomes == tebv.phenomes\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.clone-Tuple{Trials}","page":"Home","title":"GenomicBreedingCore.clone","text":"clone(x::Trials)::Trials\n\nCreate a deep copy of a Trials object, including all its fields.\n\nThis function performs a complete deep copy of the input Trials object, ensuring that all nested data structures are also copied rather than referenced.\n\nArguments\n\nx::Trials: The source Trials object to be cloned\n\nReturns\n\nTrials: A new Trials object containing copies of all data from the input\n\nExample\n\njulia> trials = Trials(n=2, t=2);\n\njulia> copy_trials = clone(trials)\nTrials(Union{Missing, Float64}[missing missing; missing missing], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"], [\"\", \"\"])\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.countlevels-Tuple{DataFrames.DataFrame}","page":"Home","title":"GenomicBreedingCore.countlevels","text":"countlevels(df::DataFrame; column_names::Vector{String})::Int64\n\nCount the total number of unique values (factor levels) across specified columns in a DataFrame.\n\nArguments\n\ndf::DataFrame: Input DataFrame to analyze\ncolumn_names::Vector{String}: Vector of column names to count unique values from\n\nReturns\n\nInt64: Sum of unique values across all specified columns\n\nThrows\n\nArgumentError: If any of the specified column names are not found in the DataFrame\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.dimensions-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.dimensions","text":"dimensions(genomes::Genomes)::Dict{String, Int64}\n\nCalculate various dimensional metrics of a Genomes struct.\n\nReturns a dictionary containing the following metrics:\n\n\"n_entries\": Number of unique entries/samples\n\"n_populations\": Number of unique populations\n\"n_loci_alleles\": Total number of loci-allele combinations\n\"n_chr\": Number of chromosomes\n\"n_loci\": Number of unique loci across all chromosomes\n\"max_n_alleles\": Maximum number of alleles observed at any locus\n\"n_missing\": Count of missing values in allele frequencies\n\nArguments\n\ngenomes::Genomes: A valid Genomes struct containing genetic data\n\nReturns\n\nDict{String,Int64}: Dictionary containing dimensional metrics\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted (fails dimension check)\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> dimensions(genomes)\nDict{String, Int64} with 7 entries:\n  \"n_entries\"      => 100\n  \"n_chr\"          => 7\n  \"n_loci\"         => 1000\n  \"n_loci_alleles\" => 3000\n  \"n_populations\"  => 1\n  \"n_missing\"      => 0\n  \"max_n_alleles\"  => 4\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.dimensions-Tuple{Phenomes}","page":"Home","title":"GenomicBreedingCore.dimensions","text":"dimensions(phenomes::Phenomes)::Dict{String, Int64}\n\nCalculate various dimensional statistics of a Phenomes struct.\n\nReturns a dictionary containing counts of:\n\n\"n_entries\": unique entries in the dataset\n\"n_populations\": unique populations\n\"n_traits\": number of traits\n\"n_total\": total number of phenotypic observations (entries × traits)\n\"n_zeroes\": number of zero values in phenotypes\n\"n_missing\": number of missing values\n\"n_nan\": number of NaN values\n\"n_inf\": number of infinite values\n\nArguments\n\nphenomes::Phenomes: A Phenomes struct containing phenotypic data\n\nReturns\n\nDict{String,Int64}: Dictionary with dimensional statistics\n\nThrows\n\nArgumentError: If the Phenomes struct dimensions are inconsistent\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> dimensions(phenomes)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 30\n  \"n_zeroes\"      => 30\n  \"n_nan\"         => 0\n  \"n_entries\"     => 10\n  \"n_traits\"      => 3\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 0\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.dimensions-Tuple{TEBV}","page":"Home","title":"GenomicBreedingCore.dimensions","text":"dimensions(tebv::TEBV)::Dict{String, Int64}\n\nCalculate various dimensional metrics for a TEBV (Trial-Estimated Breeding Values) struct.\n\nArguments\n\ntebv::TEBV: A TEBV struct containing traits, formulae, models, BLUEs, BLUPs, and phenomes data\n\nReturns\n\nA dictionary containing the following counts:\n\n\"n_entries\": Number of unique entries across all phenomes\n\"n_populations\": Number of unique populations across all phenomes\n\"n_traits\": Number of traits in the TEBV struct\n\"n_total\": Total number of observations across all traits\n\"n_zeroes\": Total number of zero values across all traits\n\"n_missing\": Total number of missing values across all traits\n\"n_nan\": Total number of NaN values across all traits\n\"n_inf\": Total number of Infinite values across all traits\n\nThrows\n\nArgumentError: If the TEBV struct dimensions are inconsistent or corrupted\n\nExamples\n\njulia> tebv = TEBV(traits=[\"trait_1\"], formulae=[\"trait_1 ~ 1 + 1|entries\"], models=[MixedModel(@formula(y~1+(1|x)), DataFrame(y=1, x=1))], df_BLUEs=[DataFrame(x=1)], df_BLUPs=[DataFrame(x=1)], phenomes=[Phenomes(n=1,t=1)]);\n\njulia> dimensions(tebv)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 1\n  \"n_zeroes\"      => 0\n  \"n_nan\"         => 0\n  \"n_entries\"     => 1\n  \"n_traits\"      => 1\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 1\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.dimensions-Tuple{Trials}","page":"Home","title":"GenomicBreedingCore.dimensions","text":"dimensions(trials::Trials)::Dict{String, Int64}\n\nCalculate dimensional statistics of a Trials struct, returning a dictionary with counts of various elements.\n\nArguments\n\ntrials::Trials: A Trials struct containing trial data\n\nReturns\n\nA Dict{String, Int64} with the following keys:\n\n\"n_traits\": Number of unique traits\n\"n_years\": Number of unique years\n\"n_seasons\": Number of unique seasons\n\"n_harvests\": Number of unique harvests\n\"n_sites\": Number of unique sites\n\"n_replications\": Number of unique replications\n\"n_blocks\": Number of unique blocks\n\"n_rows\": Number of unique rows\n\"n_cols\": Number of unique columns\n\"n_entries\": Number of unique entries\n\"n_populations\": Number of unique populations\n\"n_total\": Total number of phenotype observations (entries × traits)\n\"n_zeroes\": Count of zero values in phenotypes\n\"n_missing\": Count of missing values in phenotypes\n\"n_nan\": Count of NaN values in phenotypes\n\"n_inf\": Count of Inf values in phenotypes\n\nThrows\n\nArgumentError: If the Trials struct dimensions are inconsistent\n\nExamples\n\njulia> trials = Trials(n=1, t=2);\n\njulia> trials.entries = [\"entry_1\"]; trials.traits = [\"trait_1\", \"trait_2\"];\n\njulia> dimensions(trials)\nDict{String, Int64} with 16 entries:\n  \"n_zeroes\"       => 0\n  \"n_harvests\"     => 1\n  \"n_nan\"          => 0\n  \"n_entries\"      => 1\n  \"n_traits\"       => 2\n  \"n_seasons\"      => 1\n  \"n_rows\"         => 1\n  \"n_blocks\"       => 1\n  \"n_missing\"      => 2\n  \"n_inf\"          => 0\n  \"n_total\"        => 2\n  \"n_replications\" => 1\n  \"n_years\"        => 1\n  \"n_sites\"        => 1\n  \"n_cols\"         => 1\n  \"n_populations\"  => 1\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.distances-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.distances","text":"distances(\n    genomes::Genomes; \n    distance_metrics::Vector{String}=[\"euclidean\", \"correlation\", \"mad\", \"rmsd\", \"χ²\"],\n    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,\n    include_loci_alleles::Bool = true,\n    include_entries::Bool = true,\n    include_counts::Bool = true,\n    verbose::Bool = false\n)::Tuple{Vector{String},Vector{String},Dict{String,Matrix{Float64}}}\n\nCalculate pairwise distances/similarity metrics between loci-alleles and entries in a Genomes object.\n\nArguments\n\ngenomes::Genomes: Input Genomes object\ndistance_metrics::Vector{String}: Vector of distance metrics to calculate. Valid options:\n\"euclidean\": Euclidean distance\n\"correlation\": Pearson correlation coefficient \n\"mad\": Mean absolute deviation\n\"rmsd\": Root mean square deviation \n\"χ²\": Chi-square distance\nidx_loci_alleles::Union{Nothing, Vector{Int64}}: Optional indices of loci-alleles to include. If nothing, randomly samples 100 loci-alleles.\ninclude_loci_alleles::Bool: Whether to calculate distances between loci-alleles. Defaults to true.\ninclude_entries::Bool: Whether to calculate distances between entries. Defaults to true.\ninclude_counts::Bool: Whether to include matrices showing number of valid pairs used. Defaults to true.\nverbose::Bool: Whether to show progress bars. Defaults to false.\n\nReturns\n\nTuple containing:\n\nVector of loci-allele names used\nVector of entry names  \nDictionary mapping \"{dimension}|{metric}\" to distance matrices, where:\ndimension is either \"loci_alleles\" or \"entries\"\nmetric is one of the distance metrics or \"counts\" (number of valid pairs used)\nmatrices contain pairwise distances/correlations (-Inf where insufficient data)\n\nDetails\n\nFor loci-alleles, calculates distances between allele frequency profiles across entries\nFor entries, calculates distances between entries based on their allele frequencies\nRequires at least 2 valid (non-missing, finite) pairs to calculate metrics\nIncludes count matrices showing number of valid pairs used per calculation\nMulti-threaded implementation which uses indexing on pre-allocated vectors and matrices which should avoid data races\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> (loci_alleles_names, entries, dist) = distances(genomes, distance_metrics=[\"correlation\", \"χ²\"]);\n\njulia> sort(string.(keys(dist))) == [\"entries|correlation\", \"entries|counts\", \"entries|χ²\", \"loci_alleles|correlation\", \"loci_alleles|counts\", \"loci_alleles|χ²\"]\ntrue\n\njulia> C = dist[\"entries|correlation\"]; C[diagind(C)] == repeat([1], length(genomes.entries))\ntrue\n\njulia> χ² = dist[\"loci_alleles|χ²\"]; χ²[diagind(χ²)] == repeat([0.0], 100)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.distances-Tuple{Phenomes}","page":"Home","title":"GenomicBreedingCore.distances","text":"distances(\n    phenomes::Phenomes; \n    distance_metrics::Vector{String}=[\"euclidean\", \"correlation\", \"mad\", \"rmsd\", \"χ²\"],\n    standardise_traits::Bool = false\n)::Tuple{Vector{String}, Vector{String}, Dict{String, Matrix{Float64}}}\n\nCalculate pairwise distances/correlations between traits and entries in a phenotypic dataset.\n\nArguments\n\nphenomes::Phenomes: A Phenomes struct containing phenotypic data\ndistance_metrics::Vector{String}: Vector of distance metrics to compute. Valid options are:\n\"euclidean\": Euclidean distance\n\"correlation\": Pearson correlation coefficient\n\"mad\": Mean absolute deviation\n\"rmsd\": Root mean square deviation\n\"χ²\": Chi-square distance\nstandardise_traits::Bool: If true, standardizes traits to mean=0 and sd=1 before computing distances\n\nReturns\n\nA tuple containing:\n\nVector of trait names\nVector of entry names\nDictionary mapping \"{dimension}|{metric}\" to distance matrices, where:\ndimension ∈ [\"traits\", \"entries\"]\nmetric ∈ distance_metrics ∪ [\"counts\"]\n\"counts\" matrices contain the number of non-missing pairs used in calculations\n\nNotes\n\nPairs with fewer than 2 non-missing values result in -Inf distance values\nFor correlation calculations, traits with near-zero variance (< 1e-7) are skipped\nχ² distance adds machine epsilon to denominator to avoid division by zero\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3); phenomes.phenotypes[2,2] = missing;\n\njulia> (traits, entries, dist) = distances(phenomes, distance_metrics=[\"correlation\", \"χ²\"]);\n\njulia> sort(string.(keys(dist))) == [\"entries|correlation\", \"entries|counts\", \"entries|χ²\", \"traits|correlation\", \"traits|counts\", \"traits|χ²\"]\ntrue\n\njulia> C = dist[\"entries|correlation\"]; C[diagind(C)] == repeat([1], length(phenomes.entries))\ntrue\n\njulia> dist[\"traits|counts\"][:, 2] == dist[\"traits|counts\"][2, :] == repeat([9], length(phenomes.traits))\ntrue\n\njulia> dist[\"entries|counts\"][:, 2] == dist[\"entries|counts\"][2, :] == repeat([2], length(phenomes.entries))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.divideintomockscaffolds-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.divideintomockscaffolds","text":"ddivideintomockscaffolds(\n    genomes::Genomes;\n    max_n_loci_per_chrom::Int64 = 100_000,\n    verbose::Bool = false,\n)::Vector{String}\n\nDivide genomic loci into mock scaffolds based on a maximum number of loci per chromosome.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genomic data\nmax_n_loci_per_chrom::Int64: Maximum number of loci per chromosome (default: 100,000)\nverbose::Bool: If true, prints additional information during execution (default: false)\n\nReturns\n\nVector{String}: A vector containing mock scaffold assignments for each locus\n\nDescription\n\nThis function takes a Genomes struct and divides the loci into mock scaffolds based on the  specified maximum number of loci per chromosome. It creates scaffold names in the format  \"mockscaffoldX\" where X is the scaffold number.\n\nThrows\n\nArgumentError: If the Genomes struct dimensions are invalid or corrupted\n\nExample\n\njulia> genomes = simulategenomes(n=20, sparsity=0.3, verbose=false);\n\njulia> mock_scaffolds = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);\n\njulia> sum(mock_scaffolds .== mock_scaffolds[1]) == Int64(length(genomes.loci_alleles) / 100)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.estimatedistances-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.estimatedistances","text":"estimatedistances(\n    genomes::Genomes;\n    LD::Matrix{Float64},\n    idx_focal_locus::Int64,\n    idx_loci_alleles_per_chrom::Vector{Int64},\n    min_loci_corr::Float64,\n    min_l_loci::Int64,\n    verbose::Bool = false,\n)::Matrix{Float64}\n\nEstimate pairwise distances between entries based on loci most linked to a focal locus.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nLD::Matrix{Float64}: A linkage disequilibrium (LD) matrix.\nidx_focal_locus::Int64: The local index of the focal locus, i.e. index at the current chromosome or mock scaffold.\nidx_loci_alleles_per_chrom::Vector{Int64}: A vector of global indices for loci-alleles per chromosome, i.e. indices corresponding the whole genomes.allele_frequencies matrix.\nmin_loci_corr::Float64: The minimum correlation threshold for loci to be considered linked.\nmin_l_loci::Int64: The minimum number of loci required to be linked to the focal locus.\nverbose::Bool: If true, prints detailed progress information.\n\nReturns\n\nMatrix{Float64}: A matrix of pairwise distances between entries, estimated using the mean absolute difference (MAD) in allele frequencies of loci most linked to the focal locus.\n\nDetails\n\nThis function calculates pairwise distances between entries in a genomic dataset. The distances are based on loci that are most correlated with a specified focal locus. The function uses the following steps:\n\nInput Validation: Checks the validity of the input arguments, ensuring the Genomes struct is not corrupted, the LD matrix is square, and the indices are within valid ranges.\nIdentify Linked Loci: Determines which loci are most linked to the focal locus based on the provided LD matrix and correlation threshold. If the number of linked loci is below the specified minimum, the top loci are selected based on their correlation values.\nEstimate Distances: Calculates pairwise distances between entries using the mean absolute difference (MAD) in allele frequencies of the selected loci.\nOutput: Returns a matrix of pairwise distances.\n\nNotes\n\nThe function identifies loci most linked to the focal locus based on the provided LD matrix and correlation threshold.\nIf all loci have undetermined level of linkage with the focal locus (i.e. -Inf values in the LD matrix), then all the loci-alleles are selected to estimate distances.\nIf the number of linked loci is below the specified minimum, then the minimum number of loci most correlated to the focal locus are selected to estimate distances.\nPairwise distances are estimated using the mean absolute difference (MAD) in allele frequencies of the selected loci.\nIntermediate results and progress can be printed if verbose is set to true.\n\nThrows\n\nArgumentError: If the input arguments are invalid or the Genomes struct is corrupted.\nArgumentError: If there are less than 2 indices for loci-alleles in the current chromosome.\nArgumentError: If the LD matrix is not square.\nArgumentError: If the LD matrix and the vector of indices are incompatible.\nArgumentError: If the focal locus index is out of range.\nArgumentError: If the minimum correlation threshold is out of range.\nArgumentError: If the minimum number of loci is out of range. \n\nExample\n\njulia> genomes = simulategenomes(n=40, l=1_000, sparsity=0.3, verbose=false);\n\njulia> chromosomes = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);\n\njulia> chroms_uniq, LDs = estimateld(genomes, chromosomes=chromosomes);\n\njulia> rm.(readdir()[.!isnothing.(match.(Regex(\"jld2\"), readdir()))]);\n\njulia> k = 1; LD = LDs[k]; chrom = chroms_uniq[k]; idx_focal_locus = 1;\n\njulia> idx_loci_alleles_per_chrom = findall(chromosomes .== chrom);\n\njulia> min_loci_corr = 0.9; min_l_loci = 2;\n\njulia> D = estimatedistances(genomes, LD=LD, idx_focal_locus=idx_focal_locus, idx_loci_alleles_per_chrom=idx_loci_alleles_per_chrom, min_loci_corr=min_loci_corr, min_l_loci=min_l_loci);\n\njulia> size(D) == (length(genomes.entries), length(genomes.entries))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.estimateld-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.estimateld","text":"estimateld(\n    genomes::Genomes;\n    chromosomes::Union{Nothing,Vector{String}} = nothing,\n    verbose::Bool = false,\n)::Tuple{Vector{String},Vector{Matrix{Float64}}}\n\nCalculate linkage disequilibrium (LD) matrices for each chromosome in the given genomic data.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genomic data\nchromosomes::Union{Nothing, Vector{String}}: Optional vector of chromosome names to analyse. If nothing, all chromosomes in the data will be used\nverbose::Bool: If true, prints progress information during computation\n\nReturns\n\nTuple{Vector{String}, Vector{Matrix{Float64}}}: A tuple containing:\nA vector of unique chromosome names.\nA vector of LD matrices corresponding to each chromosome.\n\nExamples\n\njulia> genomes = simulategenomes(n=30, l=1_000, sparsity=0.3, verbose=false);\n\njulia> chroms_uniq, LDs_all_chroms = estimateld(genomes);\n\njulia> chrom, pos, allele = loci_alleles(genomes);\n\njulia> rm.(readdir()[.!isnothing.(match.(Regex(\"jld2\"), readdir()))]);\n\njulia> mock_scaffolds = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);\n\njulia> mock_scaffolds_uniq, LDs_mock_scaffolds = estimateld(genomes, chromosomes=mock_scaffolds);\n\njulia> rm.(readdir()[.!isnothing.(match.(Regex(\"jld2\"), readdir()))]);\n\njulia> length(LDs_all_chroms) == length(chroms_uniq) == length(unique(chrom))\ntrue\n\njulia> length(LDs_mock_scaffolds) == length(mock_scaffolds_uniq) == Int(length(chrom) / 100)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.extractphenomes-Tuple{TEBV}","page":"Home","title":"GenomicBreedingCore.extractphenomes","text":"extractphenomes(tebv::TEBV)::Phenomes\n\nExtract phenotypic values from a Trial-Estimated Breeding Value (TEBV) object.\n\nThis function processes phenotypic data from a TEBV object, handling intercept effects and merging multiple phenomes if present. It performs the following operations:\n\nValidates input TEBV dimensions\nProcesses intercept effects if present by:\nIdentifying intercept terms\nCombining intercept values with trait effects\nAdjusting trait names and phenotypic values accordingly\nMerges multiple phenomes if present\nRenames traits to match input TEBV traits if dimensions align\nValidates output Phenomes dimensions\n\nArguments\n\ntebv::TEBV: A Trial Estimated Breeding Value object containing phenotypic data\n\nReturns\n\nPhenomes: A Phenomes object containing processed phenotypic values\n\nThrows\n\nArgumentError: If input TEBV or output Phenomes dimensions are invalid\n\nExamples\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);\n\njulia> tebv = analyse(trials, max_levels=50, verbose=false);\n\njulia> phenomes = extractphenomes(tebv);\n\njulia> phenomes.traits == [\"trait_1\", \"trait_2\", \"trait_3\"]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.extractphenomes-Tuple{Trials}","page":"Home","title":"GenomicBreedingCore.extractphenomes","text":"extractphenomes(trials::Trials)::Phenomes\n\nConvert a Trials struct into a Phenomes struct by extracting phenotypic values across different environments.\n\nDetails\n\nCombines trait measurements with their environmental contexts\nCreates unique trait identifiers by combining trait names with environment variables\nEnvironment variables include: years, harvests, seasons, sites, and replications\nFor single environment scenarios, trait names remain without environmental suffixes\n\nArguments\n\ntrials::Trials: A Trials struct containing phenotypic measurements across different environments\n\nReturns\n\nA Phenomes struct containing:\nphenotypes: Matrix of phenotypic values (entries × traits)\nentries: Vector of entry names\npopulations: Vector of population names\ntraits: Vector of trait names (with environmental contexts)\n\nThrows\n\nArgumentError: If duplicate entries exist within year-harvest-season-site-replication combinations\nErrorException: If dimensional validation fails during Phenomes construction\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> phenomes = extractphenomes(trials);\n\njulia> size(phenomes.phenotypes)\n(100, 384)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.filterbymaf-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.filterbymaf","text":"filterbymaf(\n    genomes::Genomes;\n    maf::Float64 = 0.01,\n    verbose::Bool = false,\n)::Genomes\n\nFilter genomic data by removing loci with minor allele frequencies (MAF) below a specified threshold.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nmaf::Float64: The minimum allele frequency threshold. Default is 0.01.\nverbose::Bool: If true, prints detailed progress information during the filtering process. Default is false.\n\nReturns\n\nGenomes: A Genomes struct with filtered genomic data.\n\nDetails\n\nThis function filters genomic data by removing loci with minor allele frequencies (MAF) below a specified threshold. The function performs the following steps:\n\nInput Validation: Ensures that the Genomes struct is not corrupted and that the maf argument is within the valid range (0.0 to 1.0). Throws an ArgumentError if any argument is out of range.\nEarly Return for maf = 0.0: If maf is set to 0.0, the function returns the original Genomes struct without filtering.\nCalculate MAF: Computes the mean allele frequency for each locus, skipping missing values.\nFilter Loci: Identifies loci that pass the MAF threshold and retains only those loci:\nIf all loci pass the MAF threshold, the function returns the original Genomes struct.\nIf no loci pass the MAF threshold, the function throws an ErrorException.\nVerbose Output: If verbose is true, prints detailed progress information during the filtering process.\nOutput: Returns the filtered Genomes struct.\n\nNotes\n\nThe function uses multi-threading to compute the mean allele frequencies for each locus, improving performance on large datasets.\nThe verbose option provides additional insights into the filtering process by printing progress information.\nThe function ensures that the filtered genomic data retains a minimum number of loci.\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted.\nArgumentError: If the maf argument is out of range.\nErrorException: If all loci are filtered out based on the MAF threshold.\n\nExample\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> filtered_genomes = filterbymaf(genomes, maf=0.05);\n\njulia> length(genomes.loci_alleles) >= length(filtered_genomes.loci_alleles)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.filterbypca-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.filterbypca","text":"filterbypca(\n    genomes::Genomes;\n    max_prop_pc_varexp::Float64 = 0.9,\n    verbose::Bool = false,\n)::Genomes\n\nFilter genomic data by removing outlier loci-alleles based on principal component analysis (PCA).\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nmax_prop_pc_varexp::Float64: The maximum proportion of variance explained by the first two principal components (PC1 and PC2). Default is 0.9.\nverbose::Bool: If true, prints detailed progress information during the filtering process. Default is false.\n\nReturns\n\nGenomes: A Genomes struct with filtered genomic data.\n\nDetails\n\nThis function filters genomic data by removing outlier loci-alleles based on principal component analysis (PCA). The function performs the following steps:\n\nInput Validation: Ensures that the Genomes struct is not corrupted and that the max_prop_pc_varexp argument is within the valid range (0.0 to Inf). Throws an ArgumentError if any argument is out of range.\nEarly Return for maxproppc_varexp = Inf: If max_prop_pc_varexp is set to Inf, the function returns the original Genomes struct without filtering.\nExtract Non-Missing Loci-Alleles: Identifies loci-alleles that are non-missing and have non-zero variance across all entries.\nStandardize Allele Frequencies: Standardizes the allele frequencies per locus-allele in preparation for PCA.\nPerform PCA: Conducts PCA on the standardized allele frequencies and calculates the proportion of variance explained by the first two principal components (PC1 and PC2).\nIdentify Outliers: Identifies loci-alleles that are outliers based on the specified proportion of variance explained by PC1 and PC2.\nFilter Outliers: Removes the identified outlier loci-alleles from the genomic data.\nVerbose Output: If verbose is true, prints detailed progress information during the filtering process.\nOutput: Returns the filtered Genomes struct.\n\nNotes\n\nThe function uses PCA to identify outlier loci-alleles based on the proportion of variance explained by the first two principal components.\nThe verbose option provides additional insights into the filtering process by printing progress information.\nThe function ensures that the filtered genomic data retains a minimum number of loci-alleles.\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted.\nArgumentError: If the max_prop_pc_varexp argument is out of range.\nErrorException: If there are less than 10 loci-alleles left after removing fixed and missing values across all entries.\n\nExample\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> filtered_genomes = filterbypca(genomes, max_prop_pc_varexp=0.9);\n\njulia> length(filtered_genomes.loci_alleles) <= length(genomes.loci_alleles)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.filterbysnplist-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.filterbysnplist","text":"filterbysnplist(\n    genomes::Genomes;\n    chr_pos_allele_ids::Union{Nothing,Vector{String}} = nothing,\n    verbose::Bool = false,\n)::Genomes\n\nFilter genomic data by retaining only the specified loci-allele combinations.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nchr_pos_allele_ids::Union{Nothing, Vector{String}}: A vector of loci-allele combination names in the format \"chromosome\tposition\tallele\". If nothing, no filtering is applied. Default is nothing.\nverbose::Bool: If true, prints detailed progress information during the filtering process. Default is false.\n\nReturns\n\nGenomes: A Genomes struct with filtered genomic data.\n\nDetails\n\nThis function filters genomic data by retaining only the specified loci-allele combinations. The function performs the following steps:\n\nInput Validation: Ensures that the Genomes struct is not corrupted. Throws an ArgumentError if the struct is corrupted.\nEarly Return for No Loci-Allele Combinations: If no loci-allele combination names are provided, the function returns the original Genomes struct without filtering.\nParse Loci-Allele Combination Names: Parses the input loci-allele combination names and ensures they are valid.\nExtract Available Loci-Allele Combinations: Extracts the loci-allele combination names from the Genomes struct.\nFilter Loci-Alleles: Identifies the indices of the loci-allele combinations to retain based on the provided list.\nVerbose Output: If verbose is true, prints detailed progress information during the filtering process.\nFinal Check: Ensures that there are remaining loci-alleles after filtering. Throws an ErrorException if no loci-alleles are retained.\nOutput: Returns the filtered Genomes struct.\n\nNotes\n\nThe function uses multi-threading to parse and filter the loci-allele combination names, improving performance on large datasets.\nThe verbose option provides additional insights into the filtering process by printing progress information.\nThe function ensures that the filtered genomic data retains a minimum number of loci-alleles.\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted.\nArgumentError: If the loci-allele combination names are not in the expected format.\nErrorException: If no loci-alleles are retained after filtering.\n\nExample\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> chr_pos_allele_ids = sample(genomes.loci_alleles, 100, replace=false); sort!(chr_pos_allele_ids);\n\njulia> filtered_genomes = filterbysnplist(genomes, chr_pos_allele_ids=chr_pos_allele_ids);\n\njulia> size(filtered_genomes.allele_frequencies)\n(100, 100)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.filterbysparsity-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.filterbysparsity","text":"filterbysparsity(\n    genomes::Genomes;\n    max_entry_sparsity::Float64 = 0.0,\n    max_locus_sparsity::Float64 = 0.0,\n    max_entry_sparsity_percentile::Float64 = 0.90,\n    max_locus_sparsity_percentile::Float64 = 0.50,\n    verbose::Bool = false,\n)::Genomes\n\nFilter genomic data by removing entries and loci with high sparsity.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nmax_entry_sparsity::Float64: The maximum allowable sparsity for entries. Default is 0.0.\nmax_locus_sparsity::Float64: The maximum allowable sparsity for loci. Default is 0.0.\nmax_entry_sparsity_percentile::Float64: The percentile threshold for entry sparsity. Default is 0.90.\nmax_locus_sparsity_percentile::Float64: The percentile threshold for locus sparsity. Default is 0.50.\nverbose::Bool: If true, prints detailed progress information during the filtering process. Default is false.\n\nReturns\n\nGenomes: A Genomes struct with filtered genomic data.\n\nDetails\n\nThis function filters genomic data by iteratively removing entries and loci with high sparsity. The function performs the following steps:\n\nInput Validation: Ensures that the Genomes struct is not corrupted and that the sparsity thresholds are within the valid range (0.0 to 1.0). Throws an ArgumentError if any argument is out of range.\nCalculate Sparsities: Computes the sparsities of entries and loci in the genomic data.\nInitial Check: Checks if the input Genomes struct passes all the filtering thresholds. If so, returns the original Genomes struct.\nIterative Filtering: Iteratively removes the sparsest loci and entries until the maximum allowable sparsity thresholds are met:\nRemove Sparsest Loci: Removes loci with sparsity above the specified percentile threshold.\nRemove Sparsest Entries: Removes entries with sparsity above the specified percentile threshold.\nVerbose Output: If verbose is true, prints detailed progress information during each iteration.\nFinal Check: Ensures that there are remaining entries and loci after filtering. Throws an ErrorException if all entries or loci are filtered out.\nOutput: Returns the filtered Genomes struct.\n\nNotes\n\nThe function uses percentile thresholds to iteratively remove the sparsest loci and entries.\nThe verbose option provides additional insights into the filtering process by printing progress information.\nThe function ensures that the filtered genomic data retains a minimum number of entries and loci.\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted.\nArgumentError: If any of the sparsity thresholds are out of range.\nErrorException: If all entries and/or loci are filtered out based on the sparsity thresholds.\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, sparsity=0.01, verbose=false);\n\njulia> filtered_genomes = filterbysparsity(genomes);\n\njulia> size(genomes.allele_frequencies)\n(100, 3000)\n\njulia> size(filtered_genomes.allele_frequencies)\n(92, 1239)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.grmploidyaware-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.grmploidyaware","text":"grmploidyaware(\n    genomes::Genomes;\n    ploidy::Int64 = 2,\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    verbose::Bool = false\n)::Matrix{Float64}\n\nGenerate a ploidy-aware genetic relationship matrix (GRM) based on the methods described in  Bell et al. (2017) and VanRaden et al. (2008).\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nploidy::Int64: Number of chromosome copies in the organism (default: 2)\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to select specific entries (default: nothing)\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to select specific loci/alleles (default: nothing)\nverbose::Bool: If true, displays a heatmap of the resulting GRM (default: false)\n\nReturns\n\nMatrix{Float64}: A symmetric genetic relationship matrix with dimensions (n × n), where n is the number of entries\n\nDetails\n\nThe function implements the following steps:\n\nExtracts and processes genomic data\nCalculates allele frequencies and centers the data\nComputes the GRM using VanRaden's method\nEnsures matrix invertibility by adding small values to the diagonal if necessary\n\nNote\n\nThe diagonal elements may be slightly inflated to ensure matrix invertibility for downstream analyses.\n\nExample\n\njulia> genomes = simulategenomes(l=1_000, verbose=false);\n\njulia> grm = grmploidyaware(genomes);\n\njulia> size(grm.genomic_relationship_matrix), issymmetric(grm.genomic_relationship_matrix)\n((100, 100), true)\n\njulia> det(grm.genomic_relationship_matrix) > eps(Float64)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.grmsimple-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.grmsimple","text":"grmsimple(\n    genomes::Genomes;\n    idx_entries::Union{Nothing,Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing,Vector{Int64}} = nothing,\n    verbose::Bool = false\n)::Matrix{Float64}\n\nGenerate a simple genetic relationship matrix (GRM) from genomic data.\n\nArguments\n\ngenomes::Genomes: Genomic data structure containing allele frequencies\nidx_entries::Union{Nothing,Vector{Int64}}: Optional indices to select specific entries/individuals\nidx_loci_alleles::Union{Nothing,Vector{Int64}}: Optional indices to select specific loci/alleles\nverbose::Bool: If true, displays a heatmap visualization of the GRM\n\nReturns\n\nMatrix{Float64}: A symmetric positive definite genetic relationship matrix\n\nDetails\n\nThe function computes a genetic relationship matrix by:\n\nConverting genomic data to a numerical matrix\nComputing GRM as G * G' / ncol(G)\nAdding small positive values to diagonal elements if necessary to ensure matrix invertibility\n\nNotes\n\nThe resulting matrix is always symmetric\nDiagonal elements may be slightly inflated to ensure matrix invertibility\nThe matrix dimensions will be n×n where n is the number of entries/individuals\n\nExample\n\njulia> genomes = simulategenomes(l=1_000, verbose=false);\n\njulia> grm = grmsimple(genomes);\n\njulia> size(grm.genomic_relationship_matrix), issymmetric(grm.genomic_relationship_matrix)\n((100, 100), true)\n\njulia> det(grm.genomic_relationship_matrix) > eps(Float64)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.histallelefreqs-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.histallelefreqs","text":"histallelefreqs(genomes::Genomes)::Nothing\n\nPlot a histogram of allele frequencies from a Genomes object.\n\nArguments\n\ngenomes::Genomes: A Genomes object containing allele frequency data in its allele_frequencies field\n\nReturns\n\nNothing: Displays a histogram plot and returns nothing\n\nDescription\n\nCreates and displays a vertical histogram of non-missing allele frequencies using UnicodePlots. The histogram shows frequency distribution in the range [0,1] with 50 bins.\n\nExample\n\njulia> genomes = simulategenomes(n=100, l=10_000, n_alleles=3, n_populations=3, verbose=false);\n\njulia> histallelefreqs(genomes)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.impute-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.impute","text":"impute(\n    genomes::Genomes;\n    max_n_loci_per_chrom::Int64 = 100_000,\n    n_reps::Int64 = 2,\n    optim_n::Int64 = 10,\n    min_l_loci::Int64 = 10,\n    min_k_entries::Int64 = 2,\n    verbose::Bool = false,\n)::Tuple{Genomes, Float64}\n\nImpute missing allele frequencies in a genomic dataset using optimised allele frequency k-nearest neighbours imputation (AF-kNNi).\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nmax_n_loci_per_chrom::Int64: The maximum number of loci per chromosome. Default is 100,000.\nn_reps::Int64: The number of repetitions for cross-validation during optimisation. Default is 2.\noptim_n::Int64: The number of optimisation steps for each parameter. Default is 10.\nmin_l_loci::Int64: The minimum number of loci required to be linked to the focal locus. Default is 10.\nmin_k_entries::Int64: The minimum number of nearest neighbours required for imputation. Default is 2.\nverbose::Bool: If true, prints detailed progress information. Default is false.\n\nReturns\n\nTuple{Genomes, Float64}: A tuple containing:\nAn updated Genomes struct with imputed allele frequencies.\nThe mean absolute error (MAE) of the imputed values.\n\nDetails\n\nThis function imputes missing allele frequencies in a genomic dataset using an optimised k-nearest neighbors (KNN) imputation method. The function performs the following steps:\n\nInput Validation: Checks the validity of the input arguments, ensuring the Genomes struct is not corrupted, the number of entries and loci are within valid ranges, and the parameters are correctly specified.\nChromosome Division: Divides the allele frequencies into mock scaffolds if the number of loci per chromosome exceeds the specified maximum.\nLinkage Disequilibrium (LD) Estimation: Estimates LD between loci using Pearson's correlation for each chromosome.\nImputation Process: For each locus-allele per chromosome:\nIdentifies entries with missing data.\nOptimises the parameters minlocicorr and maxentriesdist using cross-validation.\nComputes distances between entries using the optimised minlocicorr.\nImputes missing data using the weighted means of the nearest neighbors based on the optimised maxentriesdist.\nOutput: Returns the updated Genomes struct with imputed allele frequencies and the mean absolute error (MAE) of the imputed values.\n\nNotes\n\nThe function is designed to handle the following cases:\nIf all loci have undetermined level of linkage with the focal locus (i.e. -Inf values in the LD matrix), then all the loci-alleles are selected to estimate distances.\nIf the number of linked loci is below the specified minimum, then the minimum number of loci most correlated to the focal locus are selected to estimate distances.\nIf the number of nearest neighbours is less than the specified minimum, then then the minimum number of closest neighbours are used in to compute the weighted average allele frequency.\nThe verbose option provides additional insights into the imputation process by printing progress information.\nThe function is designed to handle large genomic datasets efficiently by dividing loci into mock scaffolds if necessary.\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted.\nArgumentError: If the number of entries in the Genomes struct is less than 2.\nArgumentError: If the number of loci per chromosome is less than 10.\nArgumentError: If n_reps is not between 1 and the number of entries.\nArgumentError: If minlloci is not between 10 and the number of loci per chromosome.\nArgumentError: If minkentries is not between 2 and the number of entries.\nErrorException: If an error occurs during the imputation process.\n\nExample\n\njulia> genomes = simulategenomes(n=100, l=1_000, sparsity=0.3, verbose=false);\n\njulia> genomes_imputed, mae = impute(genomes);\n\njulia> dimensions(genomes)[\"n_missing\"] == 30_000\ntrue\n\njulia> dimensions(genomes_imputed)[\"n_missing\"] == 0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.inflatediagonals!-Tuple{Matrix{Float64}}","page":"Home","title":"GenomicBreedingCore.inflatediagonals!","text":"inflatediagonals!(X::Matrix{Float64}; ϵ::Float64=eps(Float64), max_iter::Int64=1_000, verbose::Bool=false)::Nothing\n\nEnsure matrix invertibility by iteratively inflating diagonal elements until the determinant is nonzero.\n\nArguments\n\nX::Matrix{Float64}: Input square matrix to be modified in-place\nϵ::Float64=eps(Float64): Initial inflation value for diagonal elements\nmax_iter::Int64=1_000: Maximum number of iterations\nverbose::Bool=false: If true, prints information about the inflation process\n\nDetails\n\nThe function adds progressively larger values to the diagonal elements until the matrix becomes invertible (det(X) > eps(Float64)) or the maximum number of iterations is reached. The inflation value ϵ increases slightly in each iteration.\n\nReturns\n\nNothing. The input matrix X is modified in-place.\n\nExample\n\njulia> X::Matrix{Float64} = rand(10,10);\n\njulia> inflatediagonals!(X);\n\njulia> det(X) > eps(Float64)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.knni-Tuple{}","page":"Home","title":"GenomicBreedingCore.knni","text":"knni(; qs::Vector{Float64}, d::Vector{Float64}, max_entries_dist::Float64 = 0.1, min_k_entries::Int64 = 2)::Float64\n\nImpute missing allele frequencies using the k-nearest neighbours (kNN) method based on distances.\n\nArguments\n\nqs::Vector{Float64}: A vector of non-missing allele frequencies at the focal locus.\nd::Vector{Float64}: A vector of distances corresponding to the entries in qs.\nmax_entries_dist::Float64: The maximum distance threshold to consider an entry as a neighbour. Default is 0.1.\nmin_k_entries::Int64: The minimum number of nearest neighbours required for imputation. Default is 2.\n\nReturns\n\nFloat64: The imputed allele frequency at the focal locus.\n\nDetails\n\nThis function imputes missing allele frequencies at a focal locus using the k-nearest neighbours (KNN) method. The function performs the following steps:\n\nInput Validation: Ensures that the lengths of qs and d are equal. Throws an ArgumentError if they are not.\nIdentify Nearest Neighbors: Finds the indices of the nearest neighbours within the specified distance threshold (maxentriesdist). If the number of neighbours is less than the minimum required (minkentries), the nearest neighbours are selected based on the smallest distances.\nImpute Missing Data: Calculates the weighted mean of the allele frequencies of the nearest neighbours. The weights are based on the inverse of the distances to the focal locus, ensuring that closer neighbours have a higher influence on the imputed value.\nOutput: Returns the imputed allele frequency.\n\nNotes\n\nThe function uses a small epsilon value (eps(Float64)) to avoid division by zero when calculating weights.\nIf the sum of distances is infinite, a uniform weight is assigned to each neighbour.\nThe function is designed to handle cases where the number of nearest neighbours is less than the specified minimum by selecting the closest available neighbours.\n\nThrows\n\nArgumentError: If the lengths of qs and d are not equal.\n\nExample\n\njulia> genomes = simulategenomes(n=50, l=1_000, sparsity=0.3, verbose=false);\n\njulia> chromosomes = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);\n\njulia> chroms_uniq, LDs = estimateld(genomes, chromosomes=chromosomes);\n\njulia> rm.(readdir()[.!isnothing.(match.(Regex(\"jld2\"), readdir()))]);\n\njulia> k = 1; LD = LDs[k]; chrom = chroms_uniq[k]; idx_focal_locus = 1;\n\njulia> idx_loci_alleles_per_chrom = findall(chromosomes .== chrom);\n\njulia> min_loci_corr = 0.9; min_l_loci = 2;\n\njulia> D = estimatedistances(genomes, LD=LD, idx_focal_locus=idx_focal_locus, idx_loci_alleles_per_chrom=idx_loci_alleles_per_chrom, min_loci_corr=min_loci_corr, min_l_loci=min_l_loci);\n\njulia> i = findall(ismissing.(genomes.allele_frequencies[:, idx_focal_locus]))[1];\n\njulia> idx_entries_not_missing = findall(.!ismissing.(genomes.allele_frequencies[:, idx_focal_locus]));\n\njulia> qs::Vector{Float64} = genomes.allele_frequencies[idx_entries_not_missing, idx_focal_locus];\n\njulia> d = D[i, idx_entries_not_missing];\n\njulia> q̄ = knni(qs=qs, d=d, max_entries_dist=0.25, min_k_entries=2);\n\njulia> q̄ > 0.0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.knnioptim-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.knnioptim","text":"knnioptim(\n    genomes::Genomes;\n    j::Int64,\n    idx_focal_locus::Int64,\n    idx_loci_alleles_per_chrom::Vector{Int64},\n    idx_entries_not_missing::Vector{Int64},\n    LD::Matrix{Float64},\n    n_reps::Int64 = 2,\n    optim_n::Int64 = 10,\n    min_l_loci::Int64 = 10,\n    min_k_entries::Int64 = 2,\n    verbose::Bool = false,\n)::Dict{String,Float64}\n\nOptimise parameters for allele frequency k-nearest neighbours imputation (AF-kNNi) using cross-validation, i.e. the  minimum loci correlation (min_loci_corr) and maximum entries distance (max_entries_dist).\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing the genomic data.\nj::Int64: The global index of the locus for which imputation is performed, i.e. index corresponding to the whole genomes.allele_frequencies matrix.\nidx_focal_locus::Int64: The local index of the focal locus, i.e. index at the current chromosome or mock scaffold.\nidx_loci_alleles_per_chrom::Vector{Int64}: A vector of global indices for loci-alleles per chromosome, i.e. indices corresponding the whole genomes.allele_frequencies matrix.\nidx_entries_not_missing::Vector{Int64}: A vector of indices for entries with non-missing data at the focal locus.\nLD::Matrix{Float64}: A linkage disequilibrium (LD) matrix.\nn_reps::Int64: The number of repetitions for cross-validation. Default is 2.\noptim_n::Int64: The number of optimisation steps for each parameter. Default is 10.\nmin_l_loci::Int64: The minimum number of loci required to be linked to the focal locus. Default is 10.\nmin_k_entries::Int64: The minimum number of nearest neighbours required for imputation. Default is 2.\nverbose::Bool: If true, prints detailed progress information and plots the mean absolute error (MAE) heatmap. Default is false.\n\nReturns\n\nDict{String, Float64}: A dictionary containing the optimised parameters:\n\"min_loci_corr\": The optimised minimum correlation threshold for loci to be considered linked.\n\"max_entries_dist\": The optimised maximum distance threshold to consider an entry as a neighbor.\n\"mae\": The mean absolute error (MAE) of the optimised parameters.\n\nDetails\n\nThis function optimises the minimum loci correlation (min_loci_corr) and maximum entries distance (max_entries_dist) for allele frequency k-nearest neighbours imputation (AF-kNNi) using cross-validation. The function performs the following steps:\n\nInput Validation: Ensures that there are at least 2 entries with non-missing data at the focal locus. Throws an ArgumentError if this condition is not met.\nParameter Ranges: Defines the ranges for the minimum correlation threshold (min_loci_corr) and the maximum distance threshold (maxentriesdist) for optimisation.\nCross-Validation: For each combination of min_loci_corr and max_entries_dist, the function:\nEstimates pairwise distances between entries using the estimatedistances function.\nSamples entries with non-missing data to simulate missing data.\nPerforms AF-kNNi using the knni function and calculates the mean absolute error (MAE) for the imputed values.\nOptimisation: Identifies the combination of parameters that minimises the MAE.\nOutput: Returns a dictionary containing the optimised parameters and the corresponding MAE. If verbose is true, prints detailed progress information and plots a heatmap of the MAE.\n\nNotes\n\nThe function is designed to handle the following cases:\nIf all loci have undetermined level of linkage with the focal locus (i.e. -Inf values in the LD matrix), then all the loci-alleles are selected to estimate distances.\nIf the number of linked loci is below the specified minimum, then the minimum number of loci most correlated to the focal locus are selected to estimate distances.\nIf the number of nearest neighbours is less than the specified minimum, then then the minimum number of closest neighbours are used in to compute the weighted average allele frequency.\nThe verbose option provides additional insights into the optimisation process by printing the parameters and plotting the MAE heatmap.\n\nThrows\n\nArgumentError: If there are less than 2 entries with non-missing data at the focal locus. \n\nExample\n\njulia> genomes = simulategenomes(n=123, l=1_000, sparsity=0.3, rel_dist_multiplier=10.0, verbose=false);\n\njulia> chromosomes = divideintomockscaffolds(genomes, max_n_loci_per_chrom=100);\n\njulia> chroms_uniq, LDs = estimateld(genomes, chromosomes=chromosomes);\n\njulia> rm.(readdir()[.!isnothing.(match.(Regex(\"jld2\"), readdir()))]);\n\njulia> k = 1; LD = LDs[k]; chrom = chroms_uniq[k]; j = idx_focal_locus = 1;\n\njulia> idx_loci_alleles_per_chrom = findall(chromosomes .== chrom);\n\njulia> min_loci_corr = 0.9; min_l_loci = 2;\n\njulia> D = estimatedistances(genomes, LD=LD, idx_focal_locus=idx_focal_locus, idx_loci_alleles_per_chrom=idx_loci_alleles_per_chrom, min_loci_corr=min_loci_corr, min_l_loci=min_l_loci);\n\njulia> i = findall(ismissing.(genomes.allele_frequencies[:, idx_focal_locus]))[1];\n\njulia> idx_entries_not_missing = findall(.!ismissing.(genomes.allele_frequencies[:, idx_focal_locus]));\n\njulia> params = knnioptim(genomes, j=j, idx_focal_locus=idx_focal_locus, idx_loci_alleles_per_chrom=idx_loci_alleles_per_chrom, idx_entries_not_missing=idx_entries_not_missing, LD=LD);\n\njulia> params[\"min_loci_corr\"] > 0.5\ntrue\n\njulia> params[\"max_entries_dist\"] < 0.5\ntrue\n\njulia> params[\"mae\"] < 0.1\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.loci-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.loci","text":"loci(genomes::Genomes; verbose::Bool = false)::Tuple{Vector{String},Vector{Int64},Vector{Int64},Vector{Int64}}\n\nExtract genomic positional information from a Genomes object, returning a tuple of vectors containing chromosome names, positions, and locus boundary indices.\n\nArguments\n\ngenomes::Genomes: A Genomes object containing genomic data\nverbose::Bool = false: If true, displays a progress bar during computation\n\nReturns\n\nA tuple containing four vectors:\n\nchromosomes::Vector{String}: Names of chromosomes\npositions::Vector{Int64}: Positions within chromosomes\nloci_ini_idx::Vector{Int64}: Starting indices for each locus\nloci_fin_idx::Vector{Int64}: Ending indices for each locus\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> chromosomes, positions, loci_ini_idx, loci_fin_idx = loci(genomes);\n\njulia> length(chromosomes), length(positions), length(loci_ini_idx), length(loci_fin_idx)\n(1000, 1000, 1000, 1000)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.loci_alleles-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.loci_alleles","text":"loci_alleles(genomes::Genomes; verbose::Bool = false)::Tuple{Vector{String},Vector{Int64},Vector{String}}\n\nExtract chromosomes, positions, and alleles information from a Genomes object.\n\nReturns a tuple of three vectors containing:\n\nChromosomes identifiers as strings\nBase-pair positions as integers\nAllele identifiers as strings\n\nEach vector has length equal to the total number of loci-allele combinations in the genome. The function processes the data in parallel using multiple threads for performance optimization.\n\nArguments\n\ngenomes::Genomes: A valid Genomes object containing loci and allele information\nverbose::Bool = false: If true, displays a progress bar during extraction\n\nReturns\n\nTuple{Vector{String},Vector{Int64},Vector{String}}: A tuple containing three vectors:\nchromosomes: Vector of chromosome identifiers\npositions: Vector of base-pair positions\nalleles: Vector of allele identifiers\n\nThrows\n\nArgumentError: If the Genomes struct dimensions are invalid or corrupted\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> chromosomes, positions, alleles = loci_alleles(genomes);\n\njulia> length(chromosomes), length(positions), length(alleles)\n(3000, 3000, 3000)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.maskmissing!-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.maskmissing!","text":"maskmissing!(genomes::Genomes; verbose::Bool = false)\n\nUpdate the mask matrix for missing values in the genomes struct.\n\nThis function updates the mask matrix in a Genomes struct by marking positions where allele frequencies are not missing. The mask is set to true for non-missing values and false for missing values.\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing genomic data including allele frequencies and mask matrix\nverbose::Bool=false: If true, displays a progress bar during computation\n\nThrows\n\nArgumentError: If the dimensions in the Genomes struct are inconsistent\n\nEffects\n\nModifies the mask field of the input genomes struct in-place\n\nThreads\n\nUses multi-threading for parallel computation across loci\nUses a thread lock for safe concurrent access to shared memory\n\nExample\n\njulia> genomes = simulategenomes(n=10, sparsity=0.3, verbose=false);\n\njulia> round(1.00 - mean(genomes.mask), digits=10)\n0.0\n\njulia> maskmissing!(genomes);\n\njulia> round(1.00 - mean(genomes.mask), digits=10)\n0.3\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.plot","page":"Home","title":"GenomicBreedingCore.plot","text":"plot(genomes::Genomes, seed::Int64 = 42)::Nothing\n\nGenerate visualization plots for allele frequencies in genomic data.\n\nFor each population in the dataset, creates three plots:\n\nHistogram of per-entry allele frequencies\nHistogram of mean allele frequencies per locus\nCorrelation heatmap of allele frequencies between loci\n\nArguments\n\ngenomes::Genomes: A Genomes struct containing allele frequency data\nseed::Int64=42: Random seed for reproducibility of sampling loci\n\nReturns\n\nNothing: Displays plots but doesn't return any value\n\nNotes\n\nUses up to 100 randomly sampled loci for visualization\nHandles missing values in the data\nDisplays folded frequency spectra (both q and 1-q)\nWill throw ArgumentError if the Genomes struct is corrupted\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> GenomicBreedingCore.plot(genomes)\n\n\n\n\n\n\n","category":"function"},{"location":"#GenomicBreedingCore.plot-2","page":"Home","title":"GenomicBreedingCore.plot","text":"plot(fit::Fit, distribution::Any=[TDist(1), Normal()][2], α::Float64=0.05)\n\nGenerate diagnostic plots for genetic association analysis results.\n\nArguments\n\nfit::Fit: A Fit object containing the association analysis results, specifically the b_hat field with effect sizes\ndistribution::Any: The null distribution for p-value calculation. Defaults to Normal distribution\nα::Float64: Significance level for multiple testing correction (Bonferroni). Defaults to 0.05\n\nReturns\n\nDisplays three plots:\n\nHistogram showing the distribution of effect sizes\nManhattan plot showing -log10(p-values) across loci with Bonferroni threshold\nQ-Q plot comparing observed vs expected -log10(p-values)\n\nExamples\n\njulia> distribution = [TDist(1), Normal()][2];\n\njulia> fit = Fit(n=100, l=10_000); fit.b_hat = rand(distribution, 10_000);  α = 0.05;\n\njulia> GenomicBreedingCore.plot(fit);\n\n\n\n\n\n","category":"function"},{"location":"#GenomicBreedingCore.plot-Tuple{Phenomes}","page":"Home","title":"GenomicBreedingCore.plot","text":"plot(phenomes::Phenomes; nbins::Int64 = 10)::Nothing\n\nGenerate diagnostic plots for phenotypic data stored in a Phenomes struct.\n\nArguments\n\nphenomes::Phenomes: A Phenomes struct containing phenotypic data\nnbins::Int64=10: Number of bins for the histograms (optional)\n\nDescription\n\nFor each population in the dataset:\n\nCreates histograms showing the distribution of each trait\nGenerates a heatmap of trait correlations for traits with non-zero variance\n\nNotes\n\nSkips traits with all missing, NaN, or infinite values\nOnly includes traits with variance > 1e-10 in correlation analysis\nRequires at least 3 data points to generate a histogram\nUses UnicodePlots for visualization in terminal\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = rand(10,3);\n\njulia> GenomicBreedingCore.plot(phenomes);\n\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.plot-Tuple{TEBV}","page":"Home","title":"GenomicBreedingCore.plot","text":"plot(tebv::TEBV)\n\nCreate a visualization of True Estimated Breeding Values (TEBV) analysis results.\n\nThis function extracts phenomes from the TEBV object and generates a plot to visualize the breeding value estimates.\n\nArguments\n\ntebv::TEBV: A TEBV object containing the analysis results\n\nReturns\n\nA plot object representing the visualization of the phenomes data\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.plot-Tuple{Trials}","page":"Home","title":"GenomicBreedingCore.plot","text":"plot(trials::Trials; nbins::Int64 = 10)::Nothing\n\nGenerate a comprehensive visualization of trial data through histograms, correlation heatmaps, and bar plots.\n\nArguments\n\ntrials::Trials: A Trials struct containing the trial data to be visualized\nnbins::Int64=10: Number of bins for the histogram plots (optional)\n\nDetails\n\nThe function creates three types of plots:\n\nHistograms for each trait within each population, showing the distribution of trait values\nCorrelation heatmaps between traits for each population\nBar plots showing mean trait values across different trial factors:\nYears\nSeasons\nHarvests\nSites\nReplications\nRows\nColumns\nPopulations\n\nMissing, NaN, or infinite values are automatically filtered out before plotting.\n\nReturns\n\nNothing: The function displays plots but does not return any value\n\nNotes\n\nRequires valid trial data with non-zero variance for correlation plots\nUses UnicodePlots for visualization in terminal\nSkips plotting for traits with insufficient data points\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> GenomicBreedingCore.plot(trials);\n\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulateallelefreqs!-Tuple{Matrix{Union{Missing, Float64}}, Vector{UInt64}, Union{Nothing, ProgressMeter.Progress}}","page":"Home","title":"GenomicBreedingCore.simulateallelefreqs!","text":"simulateallelefreqs!(\n    allele_frequencies::Matrix{Union{Float64,Missing}}, \n    locus_counter::Vector{UInt},\n    pb::Union{Nothing, ProgressMeter.Progress};\n    μ::Vector{Float64}, \n    Σ::SparseMatrixCSC{Float64},\n    n_alleles::Int64,\n    idx_entries_per_population::Vector{Int64},\n    rng::TaskLocalRNG = Random.GLOBAL_RNG,\n)::Nothing\n\nSimulates allele frequencies for multiple loci and populations using a multivariate normal distribution.\n\nArguments\n\nallele_frequencies::Matrix{Union{Float64,Missing}}: Matrix to store the simulated allele frequencies for all loci\nlocus_counter::Vector{UInt}: Counter tracking the current locus position\npb::ProgressMeter.Progress: Progress bar for tracking simulation progress\nμ::Vector{Float64}: Mean vector for the multivariate normal distribution\nΣ::SparseMatrixCSC{Float64}: Variance-covariance matrix for the multivariate normal distribution\nn_alleles::Int64: Number of alleles per locus\nidx_entries_per_population::Vector{Int64}: Indices for entries in each population\nrng::TaskLocalRNG: Random number generator (default: global RNG)\n\nDescription\n\nSimulates allele frequencies for multiple populations and loci using a multivariate normal distribution. For each allele (except the last one) at each locus, frequencies are sampled from the specified  distribution. For alleles after the first one, frequencies are adjusted to ensure they sum to 1.0 within each locus. All frequencies are bounded between 0.0 and 1.0.\n\nReturns\n\nNothing\n\nThrows\n\nArgumentError: If length of allele_frequencies is less than or equal to length of μ\nArgumentError: If length of μ does not match the dimensions of Σ\nArgumentError: If maximum index in idxentriesper_population exceeds number of entries\n\nNote\n\nThe last allele frequency for each locus is implicitly determined as 1 minus the sum of other allele  frequencies to ensure frequencies sum to 1.0.\n\nExample\n\njulia> chrom_lengths, chrom_loci_counts = simulatechromstruct(l=100, n_chroms=7, max_pos=135_000_000);\n\njulia> positions, loci_alleles = simulateposandalleles(chrom_lengths=chrom_lengths, chrom_loci_counts=chrom_loci_counts, n_alleles=2);\n\njulia> Σ_base = simulateldblocks(chrom_positions=positions[1], chrom_length=chrom_lengths[1], ld_corr_50perc_kb=1_000);\n\njulia> μ, Σ = simulateperpopμΣ(Σ_base=Σ_base, μ_β_params=(0.5, 0.5));\n\njulia> populations, idx_population_groupings = simulatepopgroups(n=123, n_populations=3);\n\njulia> allele_frequencies::Matrix{Union{Missing, Float64}} = fill(missing, 123, 100); locus_counter::Vector{UInt} = [1]; pb = nothing;\n\njulia> simulateallelefreqs!(allele_frequencies, locus_counter, pb, μ=μ, Σ=Σ, n_alleles=2, idx_entries_per_population=idx_population_groupings[1])\n\njulia> sum(.!ismissing.(allele_frequencies[idx_population_groupings[1], 1:length(μ)])) == (length(idx_population_groupings[1]) * length(μ))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulatechromstruct-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulatechromstruct","text":"simulatechromstruct(;l::Int64, n_chroms::Int64, max_pos::Int64)\n\nGenerate chromosome structure parameters for genome simulation.\n\nArguments\n\nl::Int64: Total number of loci to distribute across chromosomes (2 to 1e9)\nn_chroms::Int64: Number of chromosomes (1 to 1e6) \nmax_pos::Int64: Maximum genome size in base pairs (10 to 160e9)\n\nReturns\n\nA tuple containing:\n\nchrom_lengths::Vector{Int64}: Vector of chromosome lengths in base pairs\nchrom_loci_counts::Vector{Int64}: Vector of loci counts per chromosome\n\nExamples\n\njulia> chrom_lengths, chrom_loci_counts = simulatechromstruct(l=10_000, n_chroms=7, max_pos=135_000_000)\n([19285714, 19285714, 19285714, 19285714, 19285714, 19285714, 19285716], [1428, 1428, 1428, 1428, 1428, 1428, 1432])\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulateeffects-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulateeffects","text":"simulateeffects(; p::Int64 = 2, q::Int64 = 1, λ::Float64 = 1.00, seed::Int64 = 42)::Matrix{Float64}\n\nSimulate correlated effects by sampling from a multivariate normal distribution.\n\nThis function generates a matrix of correlated effects by:\n\nSampling means (μ) from an exponential distribution with parameter λ\nCreating a covariance matrix Σ = μμ'\nDrawing samples from MvNormal(μ, Σ)\nEnsuring numerical stability by adjusting the covariance matrix if necessary\n\nArguments\n\np::Int64: Number of correlated effects to simulate (default = 2)\nq::Int64: Number of times to simulate the correlated effects from the same distribution (default = 1)\nλ::Float64: Rate parameter of the exponential distribution for sampling means (default = 1.00)\nseed::Int64: Random number generator seed for reproducibility (default = 42)\n\nReturns\n\nMatrix{Float64}: A p × q matrix where each column represents a set of correlated effects\n\nExamples\n\njulia> θ::Matrix{Float64} = simulateeffects();\n\njulia> sum(abs.(θ - [-0.0886501800782904; -0.596478483888422])) < 0.00001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulategenomes-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulategenomes","text":"simulategenomes(;\n    n::Int64 = 100,\n    n_populations::Int64 = 1, \n    l::Int64 = 10_000,\n    n_chroms::Int64 = 7,\n    n_alleles::Int64 = 2,\n    max_pos::Int64 = 135_000_000,\n    ld_corr_50perc_kb::Int64 = 1_000,\n    rel_dist_multiplier::Float64 = 10.0,\n    μ_β_params::Tuple{Float64,Float64} = (0.5, 0.5),\n    sparsity::Float64 = 0.0,\n    seed::Int64 = 42,\n    verbose::Bool = true\n)::Genomes\n\nSimulates genomic data with population structure and linkage disequilibrium.\n\nArguments\n\nn::Int64: Number of entries/individuals to simulate (1 to 1e9)\nn_populations::Int64: Number of populations to simulate (1 to n)\nl::Int64: Number of loci to simulate (2 to 1e9)\nn_chroms::Int64: Number of chromosomes (1 to 1e6)\nn_alleles::Int64: Number of alleles per locus (2 to 5, representing A, T, C, G, D)\nmax_pos::Int64: Maximum position in base pairs (10 to 160e9)\nld_corr_50perc_kb::Int64: Distance in kb where correlation decay reaches 50%\nrel_dist_multiplier::Float64: Multiplier for maximum relative distance to consider in LD blocks\nμ_β_params::Tuple{Float64,Float64}: Shape parameters for Beta distribution of allele frequencies\nsparsity::Float64: Proportion of missing data to simulate (0.0 to 1.0)\nseed::Int64: Random seed for reproducibility\nverbose::Bool: Whether to show progress bar and final plot\n\nReturns\n\nGenomes: A struct containing:\nentries: Vector of entry IDs\npopulations: Vector of population assignments\nloci_alleles: Vector of locus-allele combinations\nallele_frequencies: Matrix of allele frequencies\nmask: Boolean matrix indicating valid data points\n\nDetails\n\nSimulates genomic data by:\nGenerating chromosome lengths and loci positions\nAssigning alleles to loci\nGrouping entries into populations\nSimulating allele frequencies with linkage disequilibrium using multivariate normal distribution\nAdding optional sparsity (missing data)\nChromosome lengths are distributed evenly, with any remainder added to last chromosome\nLoci positions are randomly sampled without replacement within each chromosome\nLD decay follows an exponential function: corr = 1/exp(r*d), where d is normalized distance\nMean allele frequencies are sampled from Beta(α,β) distribution\nPopulation structure is implemented by sampling the mean allele frequencies per population\nFor each entry and locus, allele frequencies with linkage disequilibrium are simulated by sampling a multivariate normal distribution per chromosome\nMissing data is randomly assigned if sparsity > 0\n\nThrows\n\nArgumentError: If input parameters are outside acceptable ranges\nDimensionMismatch: If there's an error in the simulation process\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=3, verbose=false);\n\njulia> length(genomes.entries)\n100\n\njulia> length(genomes.populations)\n100\n\njulia> length(genomes.loci_alleles)\n2000\n\njulia> size(genomes.allele_frequencies)\n(100, 2000)\n\njulia> mean(ismissing.(genomes.allele_frequencies))\n0.0\n\njulia> rng::TaskLocalRNG = Random.seed!(123);\n\njulia> idx = StatsBase.sample(rng, range(1, 2_000, step=2), 250, replace = false, ordered = true);\n\njulia> correlations = StatsBase.cor(genomes.allele_frequencies[:, idx]);\n\njulia> correlations[10,10] == 1.00\ntrue\n\njulia> correlations[10,10] > correlations[10,250]\ntrue\n\njulia> genomes = simulategenomes(n=100, l=10_000, n_alleles=3, sparsity=0.25, verbose=false);\n\njulia> mean(ismissing.(genomes.allele_frequencies))\n0.25\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulategenomiceffects-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulategenomiceffects","text":"simulategenomiceffects(;\n    genomes::Genomes,\n    f_additive::Float64 = 0.01,\n    f_dominance::Float64 = 0.10,\n    f_epistasis::Float64 = 0.05,\n    seed::Int64 = 42,\n)::Tuple{Matrix{Float64},Matrix{Float64}}\n\nSimulate additive, dominance, and epistatic effects for multiple loci.\n\nArguments\n\ngenomes::Genomes: Genome struct containing n entries x p loci-alleles combinations\nf_additive::Float64: Proportion of loci with non-zero additive effects (default = 0.01)\nf_dominance::Float64: Proportion of additive loci with dominance effects (default = 0.10)\nf_epistasis::Float64: Proportion of additive loci with epistasis effects (default = 0.05)\nseed::Int64: Random seed for reproducibility (default = 42)\n\nReturns\n\nTuple{Matrix{Float64},Matrix{Float64}}:\nFirst matrix (n x 3): Additive, dominance and epistasis effects per entry\nSecond matrix (p x 3): Effects per locus-allele combination\n\nDetails\n\nThe additive, dominance, and epistasis allele effects share a common exponential distribution (λ=1) from which  the mean of the effects (μ) are sampled, and the covariance matrix is derived (Σ = μ * μ';  where if det(Σ)≈0 then we iteratively add 1.00 to the diagonals until it becomes invertible or 10 iterations  finishes and throws an error). The non-additive or epistasis allele effects were simulated by multiplying the allele  frequencies of all possible unique pairs of epistasis alleles and their effects.\n\nExamples\n\njulia> genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);\n\njulia> G, B = simulategenomiceffects(genomes=genomes, f_additive=0.05, f_dominance=0.75, f_epistasis=0.25);\n\njulia> size.([G, B])\n2-element Vector{Tuple{Int64, Int64}}:\n (100, 3)\n (4000, 3)\n\njulia> sum(B .!= 0.0, dims=1)\n1×3 Matrix{Int64}:\n 200  75  50\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulateldblocks-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulateldblocks","text":"simulateldblocks(;\n    chrom_positions::Vector{Int64}, \n    chrom_length::Int64, \n    ld_corr_50perc_kb::Int64,\n    rel_dist_multiplier::Float64 = 10.0\n)::SparseMatrixCSC{Float64}\n\nSimulate linkage disequilibrium (LD) blocks by generating a sparse variance-covariance matrix.\n\nArguments\n\nchrom_positions::Vector{Int64}: Vector of positions on the chromosome for each locus\nchrom_length::Int64: Total length of the chromosome\nld_corr_50perc_kb::Int64: Distance in kilobases at which the LD correlation decays to 50%\nrel_dist_multiplier::Float64: Multiplier for maximum relative distance to consider (default: 10.0)\n\nReturns\n\nSparseMatrixCSC{Float64}: A sparse variance-covariance matrix representing LD blocks\n\nDetails\n\nThe function creates a variance-covariance matrix where the correlation between loci decays  exponentially with distance. The decay rate is calculated to achieve 50% correlation at the  specified distance (ld_corr_50perc_kb). \n\nFor computational efficiency, correlations between loci are set to zero if:\n\nThe normalized distance is greater than reldistmultiplier * q, where q is the normalized  LD decay distance (ldcorr50perckb / chromlength)\nThe normalized distance is greater than 0.9 (90% of chromosome length)\n\nThe computation uses multi-threading with Threads.@threads to parallelize the calculation of correlation values across loci positions.\n\nThrows\n\nArgumentError: If number of loci exceeds chromosome length\nArgumentError: If LD correlation distance exceeds chromosome length\nArgumentError: If reldistmultiplier is less than 1.0\n\nExample\n\njulia> chrom_lengths, chrom_loci_counts = simulatechromstruct(l=100, n_chroms=7, max_pos=135_000_000);\n\njulia> positions, loci_alleles = simulateposandalleles(chrom_lengths=chrom_lengths, chrom_loci_counts=chrom_loci_counts, n_alleles=2);\n\njulia> Σ = simulateldblocks(chrom_positions=positions[1], chrom_length=chrom_lengths[1], ld_corr_50perc_kb=1_000);\n\njulia> size(Σ)\n(14, 14)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulatemating-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulatemating","text":"simulatemating(;\n    parent_genomes::Genomes,\n    n_generations::Int = 1,\n    pop_size_per_gen::Vector{Int64} = [100],\n    seed::Int64 = 42,\n    verbose::Bool = false\n)::Vector{Genomes}\n\nSimulates mating processes across multiple generations using a multivariate normal distribution approach.\n\nArguments\n\nparent_genomes::Genomes: Initial parent genomic information containing allele frequencies\nn_generations::Int: Number of generations to simulate (default: 1)\npop_size_per_gen::Vector{Int64}: Vector of population sizes for each generation (default: [100])\nseed::Int64: Random seed for reproducibility (default: 42)\nverbose::Bool: Whether to print progress messages (default: false)\n\nReturns\n\nVector{Genomes}: Vector of genomes across generations\n\nDescription\n\nThis function simulates genetic inheritance across generations by:\n\nSampling progeny allele frequencies using multivariate normal distribution\nEnforcing biological constraints (frequencies between 0 and 1)\nNormalizing frequencies for multiallelic loci\nDisplaying frequency histograms for each generation\n\nThe simulation maintains allele frequency correlations within chromosomes and handles multiallelic loci by ensuring their frequencies sum to 1.\n\nThrows\n\nArgumentError: If parent genomes contain missing values or invalid dimensions\n\nExample\n\njulia> parent_genomes = simulategenomes(n=5, l=10_000, n_alleles=3, verbose=false);\n\njulia> great_great_offspring_genomes = simulatemating(parent_genomes=parent_genomes, n_generations=3, pop_size_per_gen=[10, 20, 30]);\n\njulia> [length(x.entries) for x in great_great_offspring_genomes] == [5, 10, 20, 30]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulateperpopμΣ-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulateperpopμΣ","text":"simulateperpopμΣ(; \n    Σ_base::SparseMatrixCSC{Float64}, \n    μ_β_params::Tuple{Float64,Float64} = (0.5, 0.5),\n    rng::TaskLocalRNG = Random.GLOBAL_RNG\n) -> Tuple{Vector{Float64}, SparseMatrixCSC{Float64}}\n\nSimulate per-population mean allele frequencies and their variance-covariance matrix.\n\nArguments\n\nΣ_base::SparseMatrixCSC{Float64}: Base variance-covariance matrix to be scaled\nμ_β_params::Tuple{Float64,Float64}: Parameters (α, β) for Beta distribution used to generate mean allele frequencies (default: (0.5, 0.5))\nrng::TaskLocalRNG: Random number generator for reproducibility (default: GLOBAL_RNG)\n\nReturns\n\nTuple{Vector{Float64}, SparseMatrixCSC{Float64}}: A tuple containing:\nVector of mean allele frequencies (μ)\nScaled variance-covariance matrix (Σ)\n\nDetails\n\nThe function:\n\nSamples mean allele frequencies from a Beta distribution\nScales the variance-covariance matrix based on allele frequencies\nEnsures positive definiteness of the resulting matrix through iterative adjustment\n\nThe variance scaling is performed such that loci closer to fixation (0.0 or 1.0)  have lower variance, following population genetics expectations.\n\nExample\n\njulia> chrom_lengths, chrom_loci_counts = simulatechromstruct(l=100, n_chroms=7, max_pos=135_000_000);\n\njulia> positions, loci_alleles = simulateposandalleles(chrom_lengths=chrom_lengths, chrom_loci_counts=chrom_loci_counts, n_alleles=2);\n\njulia> Σ_base = simulateldblocks(chrom_positions=positions[1], chrom_length=chrom_lengths[1], ld_corr_50perc_kb=1_000);\n\njulia> μ, Σ = simulateperpopμΣ(Σ_base=Σ_base, μ_β_params=(0.5, 0.5));\n\njulia> length(μ) == length(positions[1])\ntrue\n\njulia> size(Σ) == size(Σ_base)\ntrue\n\njulia> abs(sum(Σ .- Σ_base)) > 0.0\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulatepopgroups-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulatepopgroups","text":"simulatepopgroups(; n::Int64, n_populations::Int64)::Tuple{Vector{String}, Vector{Vector{Int64}}}\n\nSimulate population groups by dividing a total number of samples into populations.\n\nArguments\n\nn::Int64: Total number of samples (between 1 and 1 billion)\nn_populations::Int64: Number of populations to create (between 1 and n)\n\nReturns\n\nA tuple containing:\n\nVector{String}: Vector of population labels for each sample\nVector{Vector{Int64}}: Vector of vectors containing indices for each population group\n\nExample\n\njulia> populations, idx_population_groupings = simulatepopgroups(n=100, n_populations=3);\n\njulia> length(populations) == 100\ntrue\n\njulia> length(idx_population_groupings) == 3\ntrue\n\njulia> pops = fill(\"\", 100); [pops[x] .= unique(populations)[i] for (i, x) in enumerate([x for x in (idx_population_groupings)])];\n\njulia> pops == populations\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulateposandalleles-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulateposandalleles","text":"simulateposandalleles(;\n    chrom_lengths::Vector{Int64}, \n    chrom_loci_counts::Vector{Int64},\n    n_alleles::Int64, \n    allele_choices::Vector{String} = [\"A\", \"T\", \"C\", \"G\", \"D\"],\n    allele_weights::Weights{Float64,Float64,Vector{Float64}} = StatsBase.Weights([1.0, 1.0, 1.0, 1.0, 0.1] / sum([1.0, 1.0, 1.0, 1.0, 0.1])),\n    rng::TaskLocalRNG = Random.GLOBAL_RNG,\n    verbose::Bool = false\n) -> Tuple{Vector{Vector{Int64}}, Vector{String}}\n\nSimulates genomic positions and alleles for multiple chromosomes.\n\nArguments\n\nchrom_lengths::Vector{Int64}: Vector containing the length of each chromosome\nchrom_loci_counts::Vector{Int64}: Vector containing the number of loci to generate for each chromosome\nn_alleles::Int64: Number of alleles to generate per locus\nallele_choices::Vector{String}: Vector of possible alleles to choose from (default: [\"A\", \"T\", \"C\", \"G\", \"D\"])\nallele_weights::Weights: Weights for sampling alleles (default: normalized weights favoring A,T,C,G over D)\nrng::TaskLocalRNG: Random number generator for reproducibility (default: global RNG)\nverbose::Bool: Whether to show progress bar (default: false)\n\nReturns\n\nTuple{Vector{Vector{Int64}}, Vector{String}}: A tuple containing:\nA vector of vectors, where each inner vector contains the positions for a chromosome\nA vector of strings, where each string contains tab-separated locus information in the format: \"chromN\\tposition\\tallalleles\\tchosen_allele\"\n\nThrows\n\nArgumentError: If input argument lengths don't match or if invalid number of alleles is requested\n\nExample\n\njulia> chrom_lengths, chrom_loci_counts = simulatechromstruct(l=100, n_chroms=7, max_pos=135_000_000);\n\njulia> positions, loci_alleles = simulateposandalleles(chrom_lengths=chrom_lengths, chrom_loci_counts=chrom_loci_counts, n_alleles=2);\n\njulia> length(positions) == length(chrom_lengths)\ntrue\n\njulia> length(loci_alleles) == sum(chrom_loci_counts)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.simulatetrials-Tuple{}","page":"Home","title":"GenomicBreedingCore.simulatetrials","text":"simulatetrials(;\n    genomes::Genomes,\n    f_add_dom_epi::Matrix{Float64} = [\n        0.01 0.25 0.10\n        0.05 0.50 0.25\n        0.10 0.25 0.00\n    ],\n    n_years::Int64 = 2,\n    n_seasons::Int64 = 4,\n    n_harvests::Int64 = 2,\n    n_sites::Int64 = 4,\n    n_replications::Int64 = 2,\n    n_blocks::Union{Missing,Int64} = missing,\n    n_rows::Union{Missing,Int64} = missing,\n    n_cols::Union{Missing,Int64} = missing,\n    proportion_of_variance::Union{Missing,Matrix{Float64}} = missing,\n    sparsity::Float64 = 0.0,\n    seed::Int64 = 42,\n    verbose::Bool = true,\n)::Tuple{Trials,Vector{SimulatedEffects}}\n\nArguments\n\ngenomes: Genome struct includes the n entries x p loci-alleles combinations (p = l loci x a-1 alleles)\nf_add_dom_epi: n_traits x 3 numeric matrix of loci proportion with additive, dominance and epistasis effects, i.e. each column refers to:\nf_additive: proportion of the l loci with non-zero additive effects on the phenotype\nf_dominance: proportion of the l*f_additive additive effects loci with additional dominance effects\nf_epistasis: proportion of the l*f_additive additive effects loci with additional epistasis effects\n(default = [0.01 0.25 0.10; 0.05 0.50 0.25; 0.10 0.25 0.00])\nn_years: Number of years (default = 2)\nn_seasons: Number of seasons (default = 4)\nn_harvests: Number of harvests (default = 2)\nn_sites: Number of sites (default = 4)\nn_replications: Number of replications (default = 2)\nn_blocks: Number of blocks across the entire field layout (default = missing)\nn_rows: Number of rows across the entire field layout (default = missing)\nn_cols: Number of columns across the entire field layout (default = missing)\nproportion_of_variance: 9 x n_traits numeric matrix of scaled/non-scaled proportion of variances allocated to   genetic and environmental effects (default = missing; values will be sampled from a uniform distribution  followed by a biased sample on the first row, i.e. additive effects row).  The rows correspond to the variance allocated to:\nadditive genetic effects\ndominance genetic effects\nepistasis genetic effects\nyears effects\nseasons effects\nsites effects\nenvironmental interactions\nspatial interactions\nGxE interactiions\nseed: Randomisation seed (default = 42)\nsparsity: Proportion of missing data (default = 0.0)\nverbose: Show trials simulation progress bar? (default = true)\n\nOutputs\n\nTrials struct of simulated phenotype data\nVector of SimulatedEffects each corresponding to each trait-year-season-harvest-site-replication combination\n\nDetails\n\nThe function simulates trial data by:\n\nGenerating genetic effects (additive, dominance, epistasis)\nSimulating environmental effects for:\nYears, seasons, sites\nEnvironmental interactions\nSpatial field effects (blocks, rows, columns)\nGenotype-by-environment interactions\nCombining effects according to specified variance proportions\nApplying optional sparsity to create missing data\n\nThe field layout is optimized to have:\n\nNumber of rows ≤ number of columns\nBlocks divided along columns\nEven distribution of entries and replications\n\nExamples\n\njulia> genomes::Genomes = simulategenomes(n=100, l=2_000, n_alleles=3, verbose=false);\n\njulia> trials::Trials, vector_of_effects::Array{SimulatedEffects,1} = simulatetrials(genomes=genomes, sparsity=0.25, verbose=false);\n\njulia> size(trials.phenotypes)\n(12800, 3)\n\njulia> size(trials.traits)\n(3,)\n\njulia> unique(trials.entries) == genomes.entries\ntrue\n\njulia> unique(trials.populations) == unique(genomes.populations)\ntrue\n\njulia> abs(mean(ismissing.(trials.phenotypes)) - 0.25) < 0.00001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.slice-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.slice","text":"slice(\n    genomes::Genomes; \n    idx_entries::Union{Nothing, Vector{Int64}} = nothing,\n    idx_loci_alleles::Union{Nothing, Vector{Int64}} = nothing,\n    verbose::Bool = false\n)::Genomes\n\nCreate a subset of a Genomes struct by selecting specific entries and loci-allele combinations.\n\nArguments\n\ngenomes::Genomes: The source genomic data structure to be sliced\nidx_entries::Union{Nothing, Vector{Int64}}: Indices of entries to keep. If nothing, all entries are kept\nidx_loci_alleles::Union{Nothing, Vector{Int64}}: Indices of loci-allele combinations to keep. If nothing, all loci-alleles are kept\nverbose::Bool: If true, displays a progress bar during slicing. Defaults to false\n\nReturns\n\nGenomes: A new Genomes struct containing only the selected entries and loci-allele combinations\n\nPerformance Notes\n\nThe function uses multi-threaded implementation for optimal performance\nProgress bar is available when verbose=true to monitor the slicing operation\nMemory efficient implementation that creates a new pre-allocated structure\n\nBehaviour\n\nBoth index vectors are automatically sorted and deduplicated\nIf both idx_entries and idx_loci_alleles are nothing, returns a clone of the input\nMaintains all relationships and structure of the original genomic data\nPreserves population assignments and allele frequencies for selected entries\n\nValidation\n\nPerforms dimension checks on both input and output genomic structures\nValidates that all indices are within proper bounds\nEnsures data consistency throughout the slicing operation\n\nThrows\n\nArgumentError: If input Genomes struct is corrupted or indices are out of bounds\nDimensionMismatch: If the resulting sliced genome has inconsistent dimensions\n\nExamples\n\njulia> genomes = simulategenomes(n=100, l=1_000, n_alleles=4, verbose=false);\n\njulia> sliced_genomes = slice(genomes, idx_entries=collect(1:10), idx_loci_alleles=collect(1:300));\n\njulia> dimensions(sliced_genomes)\nDict{String, Int64} with 7 entries:\n  \"n_entries\"      => 10\n  \"n_chr\"          => 1\n  \"n_loci\"         => 100\n  \"n_loci_alleles\" => 300\n  \"n_populations\"  => 1\n  \"n_missing\"      => 0\n  \"max_n_alleles\"  => 4\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.slice-Tuple{Phenomes}","page":"Home","title":"GenomicBreedingCore.slice","text":"slice(phenomes::Phenomes; idx_entries::Union{Nothing, Vector{Int64}}=nothing, idx_traits::Union{Nothing, Vector{Int64}}=nothing)::Phenomes\n\nCreate a new Phenomes object containing a subset of the original data by selecting specific entries and traits.\n\nArguments\n\nphenomes::Phenomes: The original Phenomes object to slice\nidx_entries::Union{Nothing, Vector{Int64}}=nothing: Indices of entries to keep. If nothing, all entries are kept\nidx_traits::Union{Nothing, Vector{Int64}}=nothing: Indices of traits to keep. If nothing, all traits are kept\n\nReturns\n\nPhenomes: A new Phenomes object containing only the selected entries and traits\n\nNotes\n\nThe function preserves the original structure while reducing dimensions\nIndices must be within valid ranges (1 to nentries/ntraits)\nDuplicate indices are automatically removed\nThe resulting object maintains all relationships between entries, populations, traits, and phenotypes\n\nThrows\n\nArgumentError: If the input Phenomes struct is corrupted or if indices are out of bounds\nDimensionMismatch: If the slicing operation results in invalid dimensions\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> sliced_phenomes = slice(phenomes, idx_entries=collect(1:5); idx_traits=collect(2:3));\n\njulia> dimensions(sliced_phenomes)\nDict{String, Int64} with 8 entries:\n  \"n_total\"       => 10\n  \"n_zeroes\"      => 10\n  \"n_nan\"         => 0\n  \"n_entries\"     => 5\n  \"n_traits\"      => 2\n  \"n_inf\"         => 0\n  \"n_populations\" => 1\n  \"n_missing\"     => 0\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.slice-Tuple{Trials}","page":"Home","title":"GenomicBreedingCore.slice","text":"slice(\n    trials::Trials; \n    traits::Union{Nothing, Vector{String}} = nothing,\n    populations::Union{Nothing, Vector{String}} = nothing,\n    entries::Union{Nothing, Vector{String}} = nothing,\n    years::Union{Nothing, Vector{String}} = nothing,\n    harvests::Union{Nothing, Vector{String}} = nothing,\n    seasons::Union{Nothing, Vector{String}} = nothing,\n    sites::Union{Nothing, Vector{String}} = nothing,\n    replications::Union{Nothing, Vector{String}} = nothing,\n    blocks::Union{Nothing, Vector{String}} = nothing,\n    rows::Union{Nothing, Vector{String}} = nothing,\n    cols::Union{Nothing, Vector{String}} = nothing,\n)::Trials\n\nCreate a subset of a Trials struct by filtering its components based on specified criteria.\n\nArguments\n\ntrials::Trials: The source trials data structure to be sliced\ntraits::Vector{String}: Selected trait names to include\npopulations::Vector{String}: Selected population names to include\nentries::Vector{String}: Selected entry names to include\nyears::Vector{String}: Selected years to include\nharvests::Vector{String}: Selected harvest identifiers to include\nseasons::Vector{String}: Selected seasons to include\nsites::Vector{String}: Selected site names to include\nreplications::Vector{String}: Selected replication identifiers to include\nblocks::Vector{String}: Selected block identifiers to include\nrows::Vector{String}: Selected row identifiers to include\ncols::Vector{String}: Selected column identifiers to include\n\nAll arguments except trials are optional. When an argument is not provided (i.e., nothing),  all values for that category are included in the slice.\n\nReturns\n\nA new Trials struct containing only the selected data\n\nThrows\n\nArgumentError: If invalid names are provided for any category or if no data remains after filtering\nDimensionMismatch: If the resulting sliced trials structure has inconsistent dimensions\nArgumentError: If the input trials structure is corrupted\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> sliced_trials = slice(trials, traits=trials.traits[2:3], years=[unique(trials.years)[1]], seasons=unique(trials.seasons)[2:3]);\n\njulia> dimensions(sliced_trials)\nDict{String, Int64} with 16 entries:\n  \"n_zeroes\"       => 0\n  \"n_harvests\"     => 2\n  \"n_nan\"          => 0\n  \"n_entries\"      => 100\n  \"n_traits\"       => 2\n  \"n_seasons\"      => 2\n  \"n_blocks\"       => 10\n  \"n_rows\"         => 10\n  \"n_missing\"      => 0\n  \"n_inf\"          => 0\n  \"n_total\"        => 6400\n  \"n_replications\" => 2\n  \"n_years\"        => 1\n  \"n_sites\"        => 4\n  \"n_cols\"         => 20\n  \"n_populations\"  => 1\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.sparsities-Tuple{Genomes}","page":"Home","title":"GenomicBreedingCore.sparsities","text":"sparsities(genomes::Genomes) -> Tuple{Vector{Float64}, Vector{Float64}}\n\nCalculate the sparsity (proportion of missing data) for each entry and locus in a Genomes object.\n\nReturns a tuple of two vectors:\n\nFirst vector contains sparsity values for each entry (row-wise mean of missing values)\nSecond vector contains sparsity values for each locus (column-wise mean of missing values)\n\nThe function processes the data in parallel using multiple threads for performance optimization.\n\nArguments\n\ngenomes::Genomes: A Genomes object containing allele frequency data with potentially missing values\n\nReturns\n\nTuple{Vector{Float64}, Vector{Float64}}: A tuple containing:\nVector of entry sparsities (values between 0.0 and 1.0)\nVector of locus sparsities (values between 0.0 and 1.0)\n\nExample\n\njulia> genomes = simulategenomes(n=100, l=1_000, sparsity=0.25, verbose=false);\n\njulia> entry_sparsities, locus_sparsities = sparsities(genomes);\n\njulia> abs(0.25 - mean(entry_sparsities)) < 0.0001\ntrue\n\njulia> abs(0.25 - mean(locus_sparsities)) < 0.0001\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.summarise-Tuple{Vector{CV}}","page":"Home","title":"GenomicBreedingCore.summarise","text":"summarise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}\n\nSummarize cross-validation results from a vector of CV structs into two DataFrames.\n\nReturns\n\nA tuple containing two DataFrames:\nSummary DataFrame with mean metrics across entries, replications, and folds\nContains means and standard deviations of correlation coefficients\nIncludes average training and validation set sizes\nGrouped by training population, validation population, trait, and model\nEntry-level DataFrame with phenotype prediction statistics\nContains true phenotype values, predicted means (μ), and standard deviations (σ)\nGrouped by training population, validation population, trait, model, and entry\n\nArguments\n\ncvs::Vector{CV}: Vector of CV structs containing cross-validation results\n\nNotes\n\nValidates dimensions of input CV structs before processing\nHandles missing values in phenotype predictions\n\nThrows\n\nArgumentError: If any CV struct in the input vector has inconsistent dimensions\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(\"cor\" => 0.0, \"rmse\" => 1.0); fit_1.trait = \"trait_1\";\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit_1, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit_1.metrics);\n\njulia> fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(\"cor\" => 1.0, \"rmse\" => 0.0); fit_2.trait = \"trait_1\";\n\njulia> cv_2 = CV(\"replication_2\", \"fold_2\", fit_2, [\"population_2\"], [\"entry_2\"], [0.0], [0.0], fit_2.metrics);\n\njulia> cvs = [cv_1, cv_2];\n\njulia> df_summary, df_summary_per_entry = summarise(cvs);\n\njulia> size(df_summary)\n(2, 8)\n\njulia> size(df_summary_per_entry)\n(2, 8)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.tabularise","page":"Home","title":"GenomicBreedingCore.tabularise","text":"tabularise(fit::Fit, metric::String = \"cor\")::DataFrame\n\nConvert a Fit struct into a DataFrame for easier data manipulation and analysis.\n\nArguments\n\nfit::Fit: A Fit struct containing model results and parameters\nmetric::String = \"cor\": The metric to extract from fit.metrics dictionary (default: \"cor\")\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nmodel: The model name\ntrait: The trait name\npopulation: Semicolon-separated string of unique population names\nmetric: The specified metric value from fit.metrics\nb_hat_labels: Labels for the effect sizes\nb_hat: Estimated effect sizes\n\nExamples\n\njulia> fit = Fit(n=100, l=10_000); fit.b_hat = rand(10_000); fit.model=\"some_model\"; fit.trait=\"some_trait\"; \n\njulia> fit.metrics = Dict(\"cor\" => rand(), \"rmse\" => rand()); fit.populations .= \"pop_1\";\n\njulia> df = tabularise(fit);\n\njulia> size(df)\n(10000, 6)\n\n\n\n\n\n","category":"function"},{"location":"#GenomicBreedingCore.tabularise-Tuple{Phenomes}","page":"Home","title":"GenomicBreedingCore.tabularise","text":"tabularise(phenomes::Phenomes)::DataFrame\n\nConvert a Phenomes struct into a tabular format as a DataFrame.\n\nThe resulting DataFrame contains the following columns:\n\nid: Integer index for each entry\nentries: Entry identifiers\npopulations: Population assignments\nAdditional columns for each trait in phenomes.traits\n\nArguments\n\nphenomes::Phenomes: A valid Phenomes struct containing phenotypic data\n\nReturns\n\nDataFrame: A DataFrame with entries as rows and traits as columns\n\nThrows\n\nArgumentError: If the Phenomes struct dimensions are inconsistent\n\nExamples\n\njulia> phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(\"entry_\", 1:10); phenomes.populations .= \"pop_1\"; phenomes.traits = [\"A\", \"B\", \"C\"]; phenomes.phenotypes = fill(0.0, 10,3);\n\njulia> tabularise(phenomes)\n10×6 DataFrame\n Row │ id     entries   populations  A         B         C        \n     │ Int64  String    String       Float64?  Float64?  Float64? \n─────┼────────────────────────────────────────────────────────────\n   1 │     1  entry_1   pop_1             0.0       0.0       0.0\n   2 │     2  entry_2   pop_1             0.0       0.0       0.0\n   3 │     3  entry_3   pop_1             0.0       0.0       0.0\n   4 │     4  entry_4   pop_1             0.0       0.0       0.0\n   5 │     5  entry_5   pop_1             0.0       0.0       0.0\n   6 │     6  entry_6   pop_1             0.0       0.0       0.0\n   7 │     7  entry_7   pop_1             0.0       0.0       0.0\n   8 │     8  entry_8   pop_1             0.0       0.0       0.0\n   9 │     9  entry_9   pop_1             0.0       0.0       0.0\n  10 │    10  entry_10  pop_1             0.0       0.0       0.0\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.tabularise-Tuple{Trials}","page":"Home","title":"GenomicBreedingCore.tabularise","text":"tabularise(trials::Trials)::DataFrame\n\nConvert a Trials struct into a DataFrame representation for easier data manipulation and analysis.\n\nArguments\n\ntrials::Trials: A valid Trials struct containing experimental field trial data.\n\nReturns\n\nDataFrame: A DataFrame with the following columns:\nid: Unique identifier for each trial observation\nyears: Year of the trial\nseasons: Season identifier\nharvests: Harvest identifier\nsites: Location/site identifier\nreplications: Replication number\nblocks: Block identifier\nrows: Row position\ncols: Column position\nentries: Entry identifier\npopulations: Population identifier\nAdditional columns for each trait in trials.traits\n\nThrows\n\nArgumentError: If the Trials struct dimensions are inconsistent\n\nExamples\n\njulia> trials, _ = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> size(df)\n(12800, 14)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.tabularise-Tuple{Vector{CV}}","page":"Home","title":"GenomicBreedingCore.tabularise","text":"tabularise(cvs::Vector{CV})::Tuple{DataFrame,DataFrame}\n\nConvert a vector of CV (Cross-Validation) structs into two DataFrames containing metrics and predictions.\n\nArguments\n\ncvs::Vector{CV}: Vector of CV structs containing cross-validation results\n\nReturns\n\nTuple{DataFrame,DataFrame}: A tuple of two DataFrames:\ndf_across_entries: Contains aggregated metrics across entries with columns:\ntraining_population: Semicolon-separated list of training populations\nvalidation_population: Semicolon-separated list of validation populations\ntrait: Name of the trait\nmodel: Name of the model used\nreplication: Replication identifier\nfold: Fold identifier\ntraining_size: Number of entries in training set\nvalidation_size: Number of entries in validation set\nAdditional columns for each metric (e.g., cor, rmse)\ndf_per_entry: Contains per-entry predictions with columns:\ntraining_population: Training population identifier\nvalidation_population: Validation population identifier\nentry: Entry identifier\ntrait: Name of the trait\nmodel: Name of the model used\nreplication: Replication identifier\nfold: Fold identifier\ny_true: True values\ny_pred: Predicted values\n\nThrows\n\nArgumentError: If input vector is empty or if any CV struct is corrupted\n\nNotes\n\nWarns if there are empty CV structs resulting from insufficient training sizes or fixed traits\nMetrics are extracted from the metrics dictionary in each CV struct\nPopulation identifiers are sorted and joined with semicolons when multiple populations exist\n\nExamples\n\njulia> fit_1 = Fit(n=1, l=2); fit_1.metrics = Dict(\"cor\" => 0.0, \"rmse\" => 1.0); fit_1.trait = \"trait_1\";\n\njulia> cv_1 = CV(\"replication_1\", \"fold_1\", fit_1, [\"population_1\"], [\"entry_1\"], [0.0], [0.0], fit_1.metrics);\n\njulia> fit_2 = Fit(n=1, l=2); fit_2.metrics = Dict(\"cor\" => 1.0, \"rmse\" => 0.0); fit_2.trait = \"trait_1\";\n\njulia> cv_2 = CV(\"replication_2\", \"fold_2\", fit_2, [\"population_2\"], [\"entry_2\"], [0.0], [0.0], fit_2.metrics);\n\njulia> cvs = [cv_1, cv_2];\n\njulia> df_across_entries, df_per_entry = tabularise(cvs);\n\njulia> names(df_across_entries)\n10-element Vector{String}:\n \"training_population\"\n \"validation_population\"\n \"trait\"\n \"model\"\n \"replication\"\n \"fold\"\n \"training_size\"\n \"validation_size\"\n \"cor\"\n \"rmse\"\n\njulia> df_across_entries[!, [:cor, :rmse]]\n2×2 DataFrame\n Row │ cor      rmse    \n     │ Float64  Float64 \n─────┼──────────────────\n   1 │     0.0      1.0\n   2 │     1.0      0.0\n\njulia> names(df_per_entry)\n9-element Vector{String}:\n \"training_population\"\n \"validation_population\"\n \"entry\"\n \"trait\"\n \"model\"\n \"replication\"\n \"fold\"\n \"y_true\"\n \"y_pred\"\n\njulia> df_per_entry[!, [:entry, :y_true, :y_pred]]\n2×3 DataFrame\n Row │ entry    y_true   y_pred  \n     │ String   Float64  Float64 \n─────┼───────────────────────────\n   1 │ entry_1      0.0      0.0\n   2 │ entry_2      0.0      0.0\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.trialsmodelsfomulae!-Tuple{DataFrames.DataFrame}","page":"Home","title":"GenomicBreedingCore.trialsmodelsfomulae!","text":"trialsmodelsfomulae!(df::DataFrame; trait::String, max_levels::Int64 = 100)::Tuple{Vector{String},Vector{Int64}}\n\nGenerate mixed model formulae for analyzing multi-environment trial data.\n\nArguments\n\ndf::DataFrame: Input DataFrame containing trial data, will be modified in-place\ntrait::String: Name of the response variable column\nmax_levels::Int64=100: Maximum number of factor levels allowed in interaction terms\n\nReturns\n\nA tuple containing:\n\nVector{String}: Collection of mixed model formulae with increasing complexity\nVector{Int64}: Corresponding number of factor levels for each formula\n\nDetails\n\nThe function:\n\nIdentifies available trial design variables (nesters, spatial components, targets)\nCreates interaction terms between variables and adds them to the DataFrame\nGenerates model formulae considering:\nSingle and multi-environment models\nFixed and random entry effects\nSpatial error components\nNested random effects\nFilters redundant models and sorts by complexity\n\nNotes\n\nWarns if trials are unreplicated\nThrows error if only one entry is present\nAutomatically removes block effects when both row and column effects are present\nRemoves redundant nesting structures\n\nExamples\n\njulia> trials, _simulated_effects = simulatetrials(genomes = simulategenomes(verbose=false), verbose=false);\n\njulia> df = tabularise(trials);\n\njulia> size(df)\n(12800, 14)\n\njulia> formulae, n_levels = trialsmodelsfomulae!(df, trait=\"trait_1\");\n\njulia> size(df)\n(12800, 134)\n\njulia> length(formulae)\n76\n\njulia> sum(n_levels .== sort(n_levels))\n76\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingCore.@string2formula-Tuple{Any}","page":"Home","title":"GenomicBreedingCore.@string2formula","text":"@string2formula(x::String)\n\nConvert a string representation of a formula into a Formula object.\n\nThis macro parses a string containing a formula expression and evaluates it into a proper Formula object that can be used in statistical modeling.\n\nArguments\n\nx::String: A string containing the formula expression (e.g., \"y ~ x + z\")\n\nReturns\n\nFormula: A Formula object representing the parsed expression\n\n\n\n\n\n","category":"macro"},{"location":"#GenomicBreedingCore.@stringevaluation-Tuple{Any}","page":"Home","title":"GenomicBreedingCore.@stringevaluation","text":"@stringevaluation(x)\n\nParse and evaluate a string expression at compile time.\n\nArguments\n\nx: A string containing a Julia expression to be parsed.\n\nReturns\n\nThe parsed expression as an Expr object ready for evaluation.\n\n\n\n\n\n","category":"macro"}]
}
